import 'package:codegen/src/scalars/coercers.dart';

class InputBigintComparisonExp {
  factory InputBigintComparisonExp({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      InputBigintComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputBigintComparisonExp._(this._$data);

  factory InputBigintComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as int?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as int?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as int?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as int?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as int?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as int?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return InputBigintComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $_eq => (_$data['_eq'] as int?);
  int? get $_gt => (_$data['_gt'] as int?);
  int? get $_gte => (_$data['_gte'] as int?);
  List<int>? get $_in => (_$data['_in'] as List<int>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  int? get $_lt => (_$data['_lt'] as int?);
  int? get $_lte => (_$data['_lte'] as int?);
  int? get $_neq => (_$data['_neq'] as int?);
  List<int>? get $_nin => (_$data['_nin'] as List<int>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputBigintComparisonExp<InputBigintComparisonExp> get copyWith =>
      CopyWith$InputBigintComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputBigintComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputBigintComparisonExp<TRes> {
  factory CopyWith$InputBigintComparisonExp(
    InputBigintComparisonExp instance,
    TRes Function(InputBigintComparisonExp) then,
  ) = _CopyWithImpl$InputBigintComparisonExp;

  factory CopyWith$InputBigintComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputBigintComparisonExp;

  TRes call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  });
}

class _CopyWithImpl$InputBigintComparisonExp<TRes>
    implements CopyWith$InputBigintComparisonExp<TRes> {
  _CopyWithImpl$InputBigintComparisonExp(
    this._instance,
    this._then,
  );

  final InputBigintComparisonExp _instance;

  final TRes Function(InputBigintComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputBigintComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as int?),
        if ($_gt != _undefined) '_gt': ($_gt as int?),
        if ($_gte != _undefined) '_gte': ($_gte as int?),
        if ($_in != _undefined) '_in': ($_in as List<int>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as int?),
        if ($_lte != _undefined) '_lte': ($_lte as int?),
        if ($_neq != _undefined) '_neq': ($_neq as int?),
        if ($_nin != _undefined) '_nin': ($_nin as List<int>?),
      }));
}

class _CopyWithStubImpl$InputBigintComparisonExp<TRes>
    implements CopyWith$InputBigintComparisonExp<TRes> {
  _CopyWithStubImpl$InputBigintComparisonExp(this._res);

  TRes _res;

  call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      _res;
}

class InputBooleanComparisonExp {
  factory InputBooleanComparisonExp({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  }) =>
      InputBooleanComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputBooleanComparisonExp._(this._$data);

  factory InputBooleanComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as bool?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as bool?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as bool?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as bool)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as bool?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as bool?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as bool?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as bool)).toList();
    }
    return InputBooleanComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get $_eq => (_$data['_eq'] as bool?);
  bool? get $_gt => (_$data['_gt'] as bool?);
  bool? get $_gte => (_$data['_gte'] as bool?);
  List<bool>? get $_in => (_$data['_in'] as List<bool>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  bool? get $_lt => (_$data['_lt'] as bool?);
  bool? get $_lte => (_$data['_lte'] as bool?);
  bool? get $_neq => (_$data['_neq'] as bool?);
  List<bool>? get $_nin => (_$data['_nin'] as List<bool>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputBooleanComparisonExp<InputBooleanComparisonExp> get copyWith =>
      CopyWith$InputBooleanComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputBooleanComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputBooleanComparisonExp<TRes> {
  factory CopyWith$InputBooleanComparisonExp(
    InputBooleanComparisonExp instance,
    TRes Function(InputBooleanComparisonExp) then,
  ) = _CopyWithImpl$InputBooleanComparisonExp;

  factory CopyWith$InputBooleanComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputBooleanComparisonExp;

  TRes call({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  });
}

class _CopyWithImpl$InputBooleanComparisonExp<TRes>
    implements CopyWith$InputBooleanComparisonExp<TRes> {
  _CopyWithImpl$InputBooleanComparisonExp(
    this._instance,
    this._then,
  );

  final InputBooleanComparisonExp _instance;

  final TRes Function(InputBooleanComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputBooleanComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as bool?),
        if ($_gt != _undefined) '_gt': ($_gt as bool?),
        if ($_gte != _undefined) '_gte': ($_gte as bool?),
        if ($_in != _undefined) '_in': ($_in as List<bool>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as bool?),
        if ($_lte != _undefined) '_lte': ($_lte as bool?),
        if ($_neq != _undefined) '_neq': ($_neq as bool?),
        if ($_nin != _undefined) '_nin': ($_nin as List<bool>?),
      }));
}

class _CopyWithStubImpl$InputBooleanComparisonExp<TRes>
    implements CopyWith$InputBooleanComparisonExp<TRes> {
  _CopyWithStubImpl$InputBooleanComparisonExp(this._res);

  TRes _res;

  call({
    bool? $_eq,
    bool? $_gt,
    bool? $_gte,
    List<bool>? $_in,
    bool? $_isNull,
    bool? $_lt,
    bool? $_lte,
    bool? $_neq,
    List<bool>? $_nin,
  }) =>
      _res;
}

class InputByteaComparisonExp {
  factory InputByteaComparisonExp({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      InputByteaComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputByteaComparisonExp._(this._$data);

  factory InputByteaComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as int?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as int?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as int?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as int?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as int?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as int?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return InputByteaComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $_eq => (_$data['_eq'] as int?);
  int? get $_gt => (_$data['_gt'] as int?);
  int? get $_gte => (_$data['_gte'] as int?);
  List<int>? get $_in => (_$data['_in'] as List<int>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  int? get $_lt => (_$data['_lt'] as int?);
  int? get $_lte => (_$data['_lte'] as int?);
  int? get $_neq => (_$data['_neq'] as int?);
  List<int>? get $_nin => (_$data['_nin'] as List<int>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputByteaComparisonExp<InputByteaComparisonExp> get copyWith =>
      CopyWith$InputByteaComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputByteaComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputByteaComparisonExp<TRes> {
  factory CopyWith$InputByteaComparisonExp(
    InputByteaComparisonExp instance,
    TRes Function(InputByteaComparisonExp) then,
  ) = _CopyWithImpl$InputByteaComparisonExp;

  factory CopyWith$InputByteaComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputByteaComparisonExp;

  TRes call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  });
}

class _CopyWithImpl$InputByteaComparisonExp<TRes>
    implements CopyWith$InputByteaComparisonExp<TRes> {
  _CopyWithImpl$InputByteaComparisonExp(
    this._instance,
    this._then,
  );

  final InputByteaComparisonExp _instance;

  final TRes Function(InputByteaComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputByteaComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as int?),
        if ($_gt != _undefined) '_gt': ($_gt as int?),
        if ($_gte != _undefined) '_gte': ($_gte as int?),
        if ($_in != _undefined) '_in': ($_in as List<int>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as int?),
        if ($_lte != _undefined) '_lte': ($_lte as int?),
        if ($_neq != _undefined) '_neq': ($_neq as int?),
        if ($_nin != _undefined) '_nin': ($_nin as List<int>?),
      }));
}

class _CopyWithStubImpl$InputByteaComparisonExp<TRes>
    implements CopyWith$InputByteaComparisonExp<TRes> {
  _CopyWithStubImpl$InputByteaComparisonExp(this._res);

  TRes _res;

  call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      _res;
}

class InputCitextComparisonExp {
  factory InputCitextComparisonExp({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      InputCitextComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_ilike != null) r'_ilike': $_ilike,
        if ($_in != null) r'_in': $_in,
        if ($_iregex != null) r'_iregex': $_iregex,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_like != null) r'_like': $_like,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nilike != null) r'_nilike': $_nilike,
        if ($_nin != null) r'_nin': $_nin,
        if ($_niregex != null) r'_niregex': $_niregex,
        if ($_nlike != null) r'_nlike': $_nlike,
        if ($_nregex != null) r'_nregex': $_nregex,
        if ($_nsimilar != null) r'_nsimilar': $_nsimilar,
        if ($_regex != null) r'_regex': $_regex,
        if ($_similar != null) r'_similar': $_similar,
      });

  InputCitextComparisonExp._(this._$data);

  factory InputCitextComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as String?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as String?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as String?);
    }
    if (data.containsKey('_ilike')) {
      final l$$_ilike = data['_ilike'];
      result$data['_ilike'] = (l$$_ilike as String?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_iregex')) {
      final l$$_iregex = data['_iregex'];
      result$data['_iregex'] = (l$$_iregex as String?);
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_like')) {
      final l$$_like = data['_like'];
      result$data['_like'] = (l$$_like as String?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as String?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as String?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as String?);
    }
    if (data.containsKey('_nilike')) {
      final l$$_nilike = data['_nilike'];
      result$data['_nilike'] = (l$$_nilike as String?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_niregex')) {
      final l$$_niregex = data['_niregex'];
      result$data['_niregex'] = (l$$_niregex as String?);
    }
    if (data.containsKey('_nlike')) {
      final l$$_nlike = data['_nlike'];
      result$data['_nlike'] = (l$$_nlike as String?);
    }
    if (data.containsKey('_nregex')) {
      final l$$_nregex = data['_nregex'];
      result$data['_nregex'] = (l$$_nregex as String?);
    }
    if (data.containsKey('_nsimilar')) {
      final l$$_nsimilar = data['_nsimilar'];
      result$data['_nsimilar'] = (l$$_nsimilar as String?);
    }
    if (data.containsKey('_regex')) {
      final l$$_regex = data['_regex'];
      result$data['_regex'] = (l$$_regex as String?);
    }
    if (data.containsKey('_similar')) {
      final l$$_similar = data['_similar'];
      result$data['_similar'] = (l$$_similar as String?);
    }
    return InputCitextComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $_eq => (_$data['_eq'] as String?);
  String? get $_gt => (_$data['_gt'] as String?);
  String? get $_gte => (_$data['_gte'] as String?);
  String? get $_ilike => (_$data['_ilike'] as String?);
  List<String>? get $_in => (_$data['_in'] as List<String>?);
  String? get $_iregex => (_$data['_iregex'] as String?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  String? get $_like => (_$data['_like'] as String?);
  String? get $_lt => (_$data['_lt'] as String?);
  String? get $_lte => (_$data['_lte'] as String?);
  String? get $_neq => (_$data['_neq'] as String?);
  String? get $_nilike => (_$data['_nilike'] as String?);
  List<String>? get $_nin => (_$data['_nin'] as List<String>?);
  String? get $_niregex => (_$data['_niregex'] as String?);
  String? get $_nlike => (_$data['_nlike'] as String?);
  String? get $_nregex => (_$data['_nregex'] as String?);
  String? get $_nsimilar => (_$data['_nsimilar'] as String?);
  String? get $_regex => (_$data['_regex'] as String?);
  String? get $_similar => (_$data['_similar'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_ilike')) {
      final l$$_ilike = $_ilike;
      result$data['_ilike'] = l$$_ilike;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_iregex')) {
      final l$$_iregex = $_iregex;
      result$data['_iregex'] = l$$_iregex;
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_like')) {
      final l$$_like = $_like;
      result$data['_like'] = l$$_like;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nilike')) {
      final l$$_nilike = $_nilike;
      result$data['_nilike'] = l$$_nilike;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('_niregex')) {
      final l$$_niregex = $_niregex;
      result$data['_niregex'] = l$$_niregex;
    }
    if (_$data.containsKey('_nlike')) {
      final l$$_nlike = $_nlike;
      result$data['_nlike'] = l$$_nlike;
    }
    if (_$data.containsKey('_nregex')) {
      final l$$_nregex = $_nregex;
      result$data['_nregex'] = l$$_nregex;
    }
    if (_$data.containsKey('_nsimilar')) {
      final l$$_nsimilar = $_nsimilar;
      result$data['_nsimilar'] = l$$_nsimilar;
    }
    if (_$data.containsKey('_regex')) {
      final l$$_regex = $_regex;
      result$data['_regex'] = l$$_regex;
    }
    if (_$data.containsKey('_similar')) {
      final l$$_similar = $_similar;
      result$data['_similar'] = l$$_similar;
    }
    return result$data;
  }

  CopyWith$InputCitextComparisonExp<InputCitextComparisonExp> get copyWith =>
      CopyWith$InputCitextComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputCitextComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_ilike = $_ilike;
    final lOther$$_ilike = other.$_ilike;
    if (_$data.containsKey('_ilike') != other._$data.containsKey('_ilike')) {
      return false;
    }
    if (l$$_ilike != lOther$$_ilike) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_iregex = $_iregex;
    final lOther$$_iregex = other.$_iregex;
    if (_$data.containsKey('_iregex') != other._$data.containsKey('_iregex')) {
      return false;
    }
    if (l$$_iregex != lOther$$_iregex) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_like = $_like;
    final lOther$$_like = other.$_like;
    if (_$data.containsKey('_like') != other._$data.containsKey('_like')) {
      return false;
    }
    if (l$$_like != lOther$$_like) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nilike = $_nilike;
    final lOther$$_nilike = other.$_nilike;
    if (_$data.containsKey('_nilike') != other._$data.containsKey('_nilike')) {
      return false;
    }
    if (l$$_nilike != lOther$$_nilike) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    final l$$_niregex = $_niregex;
    final lOther$$_niregex = other.$_niregex;
    if (_$data.containsKey('_niregex') !=
        other._$data.containsKey('_niregex')) {
      return false;
    }
    if (l$$_niregex != lOther$$_niregex) {
      return false;
    }
    final l$$_nlike = $_nlike;
    final lOther$$_nlike = other.$_nlike;
    if (_$data.containsKey('_nlike') != other._$data.containsKey('_nlike')) {
      return false;
    }
    if (l$$_nlike != lOther$$_nlike) {
      return false;
    }
    final l$$_nregex = $_nregex;
    final lOther$$_nregex = other.$_nregex;
    if (_$data.containsKey('_nregex') != other._$data.containsKey('_nregex')) {
      return false;
    }
    if (l$$_nregex != lOther$$_nregex) {
      return false;
    }
    final l$$_nsimilar = $_nsimilar;
    final lOther$$_nsimilar = other.$_nsimilar;
    if (_$data.containsKey('_nsimilar') !=
        other._$data.containsKey('_nsimilar')) {
      return false;
    }
    if (l$$_nsimilar != lOther$$_nsimilar) {
      return false;
    }
    final l$$_regex = $_regex;
    final lOther$$_regex = other.$_regex;
    if (_$data.containsKey('_regex') != other._$data.containsKey('_regex')) {
      return false;
    }
    if (l$$_regex != lOther$$_regex) {
      return false;
    }
    final l$$_similar = $_similar;
    final lOther$$_similar = other.$_similar;
    if (_$data.containsKey('_similar') !=
        other._$data.containsKey('_similar')) {
      return false;
    }
    if (l$$_similar != lOther$$_similar) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_ilike = $_ilike;
    final l$$_in = $_in;
    final l$$_iregex = $_iregex;
    final l$$_isNull = $_isNull;
    final l$$_like = $_like;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nilike = $_nilike;
    final l$$_nin = $_nin;
    final l$$_niregex = $_niregex;
    final l$$_nlike = $_nlike;
    final l$$_nregex = $_nregex;
    final l$$_nsimilar = $_nsimilar;
    final l$$_regex = $_regex;
    final l$$_similar = $_similar;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_ilike') ? l$$_ilike : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_iregex') ? l$$_iregex : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_like') ? l$$_like : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nilike') ? l$$_nilike : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
      _$data.containsKey('_niregex') ? l$$_niregex : const {},
      _$data.containsKey('_nlike') ? l$$_nlike : const {},
      _$data.containsKey('_nregex') ? l$$_nregex : const {},
      _$data.containsKey('_nsimilar') ? l$$_nsimilar : const {},
      _$data.containsKey('_regex') ? l$$_regex : const {},
      _$data.containsKey('_similar') ? l$$_similar : const {},
    ]);
  }
}

abstract class CopyWith$InputCitextComparisonExp<TRes> {
  factory CopyWith$InputCitextComparisonExp(
    InputCitextComparisonExp instance,
    TRes Function(InputCitextComparisonExp) then,
  ) = _CopyWithImpl$InputCitextComparisonExp;

  factory CopyWith$InputCitextComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputCitextComparisonExp;

  TRes call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  });
}

class _CopyWithImpl$InputCitextComparisonExp<TRes>
    implements CopyWith$InputCitextComparisonExp<TRes> {
  _CopyWithImpl$InputCitextComparisonExp(
    this._instance,
    this._then,
  );

  final InputCitextComparisonExp _instance;

  final TRes Function(InputCitextComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_ilike = _undefined,
    Object? $_in = _undefined,
    Object? $_iregex = _undefined,
    Object? $_isNull = _undefined,
    Object? $_like = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nilike = _undefined,
    Object? $_nin = _undefined,
    Object? $_niregex = _undefined,
    Object? $_nlike = _undefined,
    Object? $_nregex = _undefined,
    Object? $_nsimilar = _undefined,
    Object? $_regex = _undefined,
    Object? $_similar = _undefined,
  }) =>
      _then(InputCitextComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as String?),
        if ($_gt != _undefined) '_gt': ($_gt as String?),
        if ($_gte != _undefined) '_gte': ($_gte as String?),
        if ($_ilike != _undefined) '_ilike': ($_ilike as String?),
        if ($_in != _undefined) '_in': ($_in as List<String>?),
        if ($_iregex != _undefined) '_iregex': ($_iregex as String?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_like != _undefined) '_like': ($_like as String?),
        if ($_lt != _undefined) '_lt': ($_lt as String?),
        if ($_lte != _undefined) '_lte': ($_lte as String?),
        if ($_neq != _undefined) '_neq': ($_neq as String?),
        if ($_nilike != _undefined) '_nilike': ($_nilike as String?),
        if ($_nin != _undefined) '_nin': ($_nin as List<String>?),
        if ($_niregex != _undefined) '_niregex': ($_niregex as String?),
        if ($_nlike != _undefined) '_nlike': ($_nlike as String?),
        if ($_nregex != _undefined) '_nregex': ($_nregex as String?),
        if ($_nsimilar != _undefined) '_nsimilar': ($_nsimilar as String?),
        if ($_regex != _undefined) '_regex': ($_regex as String?),
        if ($_similar != _undefined) '_similar': ($_similar as String?),
      }));
}

class _CopyWithStubImpl$InputCitextComparisonExp<TRes>
    implements CopyWith$InputCitextComparisonExp<TRes> {
  _CopyWithStubImpl$InputCitextComparisonExp(this._res);

  TRes _res;

  call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      _res;
}

class InputIntComparisonExp {
  factory InputIntComparisonExp({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      InputIntComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputIntComparisonExp._(this._$data);

  factory InputIntComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as int?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as int?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as int?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as int?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as int?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as int?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return InputIntComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $_eq => (_$data['_eq'] as int?);
  int? get $_gt => (_$data['_gt'] as int?);
  int? get $_gte => (_$data['_gte'] as int?);
  List<int>? get $_in => (_$data['_in'] as List<int>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  int? get $_lt => (_$data['_lt'] as int?);
  int? get $_lte => (_$data['_lte'] as int?);
  int? get $_neq => (_$data['_neq'] as int?);
  List<int>? get $_nin => (_$data['_nin'] as List<int>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputIntComparisonExp<InputIntComparisonExp> get copyWith =>
      CopyWith$InputIntComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputIntComparisonExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputIntComparisonExp<TRes> {
  factory CopyWith$InputIntComparisonExp(
    InputIntComparisonExp instance,
    TRes Function(InputIntComparisonExp) then,
  ) = _CopyWithImpl$InputIntComparisonExp;

  factory CopyWith$InputIntComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputIntComparisonExp;

  TRes call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  });
}

class _CopyWithImpl$InputIntComparisonExp<TRes>
    implements CopyWith$InputIntComparisonExp<TRes> {
  _CopyWithImpl$InputIntComparisonExp(
    this._instance,
    this._then,
  );

  final InputIntComparisonExp _instance;

  final TRes Function(InputIntComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputIntComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as int?),
        if ($_gt != _undefined) '_gt': ($_gt as int?),
        if ($_gte != _undefined) '_gte': ($_gte as int?),
        if ($_in != _undefined) '_in': ($_in as List<int>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as int?),
        if ($_lte != _undefined) '_lte': ($_lte as int?),
        if ($_neq != _undefined) '_neq': ($_neq as int?),
        if ($_nin != _undefined) '_nin': ($_nin as List<int>?),
      }));
}

class _CopyWithStubImpl$InputIntComparisonExp<TRes>
    implements CopyWith$InputIntComparisonExp<TRes> {
  _CopyWithStubImpl$InputIntComparisonExp(this._res);

  TRes _res;

  call({
    int? $_eq,
    int? $_gt,
    int? $_gte,
    List<int>? $_in,
    bool? $_isNull,
    int? $_lt,
    int? $_lte,
    int? $_neq,
    List<int>? $_nin,
  }) =>
      _res;
}

class InputJsonbCastExp {
  factory InputJsonbCastExp({InputStringComparisonExp? $String}) =>
      InputJsonbCastExp._({
        if ($String != null) r'String': $String,
      });

  InputJsonbCastExp._(this._$data);

  factory InputJsonbCastExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('String')) {
      final l$$String = data['String'];
      result$data['String'] = l$$String == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$$String as Map<String, dynamic>));
    }
    return InputJsonbCastExp._(result$data);
  }

  Map<String, dynamic> _$data;

  InputStringComparisonExp? get $String =>
      (_$data['String'] as InputStringComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('String')) {
      final l$$String = $String;
      result$data['String'] = l$$String?.toJson();
    }
    return result$data;
  }

  CopyWith$InputJsonbCastExp<InputJsonbCastExp> get copyWith =>
      CopyWith$InputJsonbCastExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputJsonbCastExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$String = $String;
    final lOther$$String = other.$String;
    if (_$data.containsKey('String') != other._$data.containsKey('String')) {
      return false;
    }
    if (l$$String != lOther$$String) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$String = $String;
    return Object.hashAll(
        [_$data.containsKey('String') ? l$$String : const {}]);
  }
}

abstract class CopyWith$InputJsonbCastExp<TRes> {
  factory CopyWith$InputJsonbCastExp(
    InputJsonbCastExp instance,
    TRes Function(InputJsonbCastExp) then,
  ) = _CopyWithImpl$InputJsonbCastExp;

  factory CopyWith$InputJsonbCastExp.stub(TRes res) =
      _CopyWithStubImpl$InputJsonbCastExp;

  TRes call({InputStringComparisonExp? $String});
  CopyWith$InputStringComparisonExp<TRes> get $String;
}

class _CopyWithImpl$InputJsonbCastExp<TRes>
    implements CopyWith$InputJsonbCastExp<TRes> {
  _CopyWithImpl$InputJsonbCastExp(
    this._instance,
    this._then,
  );

  final InputJsonbCastExp _instance;

  final TRes Function(InputJsonbCastExp) _then;

  static const _undefined = {};

  TRes call({Object? $String = _undefined}) => _then(InputJsonbCastExp._({
        ..._instance._$data,
        if ($String != _undefined)
          'String': ($String as InputStringComparisonExp?),
      }));
  CopyWith$InputStringComparisonExp<TRes> get $String {
    final local$$String = _instance.$String;
    return local$$String == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$$String, (e) => call($String: e));
  }
}

class _CopyWithStubImpl$InputJsonbCastExp<TRes>
    implements CopyWith$InputJsonbCastExp<TRes> {
  _CopyWithStubImpl$InputJsonbCastExp(this._res);

  TRes _res;

  call({InputStringComparisonExp? $String}) => _res;
  CopyWith$InputStringComparisonExp<TRes> get $String =>
      CopyWith$InputStringComparisonExp.stub(_res);
}

class InputJsonbComparisonExp {
  factory InputJsonbComparisonExp({
    InputJsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  }) =>
      InputJsonbComparisonExp._({
        if ($_cast != null) r'_cast': $_cast,
        if ($_containedIn != null) r'_containedIn': $_containedIn,
        if ($_contains != null) r'_contains': $_contains,
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_hasKey != null) r'_hasKey': $_hasKey,
        if ($_hasKeysAll != null) r'_hasKeysAll': $_hasKeysAll,
        if ($_hasKeysAny != null) r'_hasKeysAny': $_hasKeysAny,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputJsonbComparisonExp._(this._$data);

  factory InputJsonbComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_cast')) {
      final l$$_cast = data['_cast'];
      result$data['_cast'] = l$$_cast == null
          ? null
          : InputJsonbCastExp.fromJson((l$$_cast as Map<String, dynamic>));
    }
    if (data.containsKey('_containedIn')) {
      final l$$_containedIn = data['_containedIn'];
      result$data['_containedIn'] = (l$$_containedIn as Map<String, dynamic>?);
    }
    if (data.containsKey('_contains')) {
      final l$$_contains = data['_contains'];
      result$data['_contains'] = (l$$_contains as Map<String, dynamic>?);
    }
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as Map<String, dynamic>?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as Map<String, dynamic>?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as Map<String, dynamic>?);
    }
    if (data.containsKey('_hasKey')) {
      final l$$_hasKey = data['_hasKey'];
      result$data['_hasKey'] = (l$$_hasKey as String?);
    }
    if (data.containsKey('_hasKeysAll')) {
      final l$$_hasKeysAll = data['_hasKeysAll'];
      result$data['_hasKeysAll'] = (l$$_hasKeysAll as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('_hasKeysAny')) {
      final l$$_hasKeysAny = data['_hasKeysAny'];
      result$data['_hasKeysAny'] = (l$$_hasKeysAny as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => (e as Map<String, dynamic>))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as Map<String, dynamic>?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as Map<String, dynamic>?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as Map<String, dynamic>?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => (e as Map<String, dynamic>))
          .toList();
    }
    return InputJsonbComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  InputJsonbCastExp? get $_cast => (_$data['_cast'] as InputJsonbCastExp?);
  Map<String, dynamic>? get $_containedIn =>
      (_$data['_containedIn'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_contains =>
      (_$data['_contains'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_eq => (_$data['_eq'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_gt => (_$data['_gt'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_gte => (_$data['_gte'] as Map<String, dynamic>?);
  String? get $_hasKey => (_$data['_hasKey'] as String?);
  List<String>? get $_hasKeysAll => (_$data['_hasKeysAll'] as List<String>?);
  List<String>? get $_hasKeysAny => (_$data['_hasKeysAny'] as List<String>?);
  List<Map<String, dynamic>>? get $_in =>
      (_$data['_in'] as List<Map<String, dynamic>>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  Map<String, dynamic>? get $_lt => (_$data['_lt'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_lte => (_$data['_lte'] as Map<String, dynamic>?);
  Map<String, dynamic>? get $_neq => (_$data['_neq'] as Map<String, dynamic>?);
  List<Map<String, dynamic>>? get $_nin =>
      (_$data['_nin'] as List<Map<String, dynamic>>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_cast')) {
      final l$$_cast = $_cast;
      result$data['_cast'] = l$$_cast?.toJson();
    }
    if (_$data.containsKey('_containedIn')) {
      final l$$_containedIn = $_containedIn;
      result$data['_containedIn'] = l$$_containedIn;
    }
    if (_$data.containsKey('_contains')) {
      final l$$_contains = $_contains;
      result$data['_contains'] = l$$_contains;
    }
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_hasKey')) {
      final l$$_hasKey = $_hasKey;
      result$data['_hasKey'] = l$$_hasKey;
    }
    if (_$data.containsKey('_hasKeysAll')) {
      final l$$_hasKeysAll = $_hasKeysAll;
      result$data['_hasKeysAll'] = l$$_hasKeysAll?.map((e) => e).toList();
    }
    if (_$data.containsKey('_hasKeysAny')) {
      final l$$_hasKeysAny = $_hasKeysAny;
      result$data['_hasKeysAny'] = l$$_hasKeysAny?.map((e) => e).toList();
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputJsonbComparisonExp<InputJsonbComparisonExp> get copyWith =>
      CopyWith$InputJsonbComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputJsonbComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_cast = $_cast;
    final lOther$$_cast = other.$_cast;
    if (_$data.containsKey('_cast') != other._$data.containsKey('_cast')) {
      return false;
    }
    if (l$$_cast != lOther$$_cast) {
      return false;
    }
    final l$$_containedIn = $_containedIn;
    final lOther$$_containedIn = other.$_containedIn;
    if (_$data.containsKey('_containedIn') !=
        other._$data.containsKey('_containedIn')) {
      return false;
    }
    if (l$$_containedIn != lOther$$_containedIn) {
      return false;
    }
    final l$$_contains = $_contains;
    final lOther$$_contains = other.$_contains;
    if (_$data.containsKey('_contains') !=
        other._$data.containsKey('_contains')) {
      return false;
    }
    if (l$$_contains != lOther$$_contains) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_hasKey = $_hasKey;
    final lOther$$_hasKey = other.$_hasKey;
    if (_$data.containsKey('_hasKey') != other._$data.containsKey('_hasKey')) {
      return false;
    }
    if (l$$_hasKey != lOther$$_hasKey) {
      return false;
    }
    final l$$_hasKeysAll = $_hasKeysAll;
    final lOther$$_hasKeysAll = other.$_hasKeysAll;
    if (_$data.containsKey('_hasKeysAll') !=
        other._$data.containsKey('_hasKeysAll')) {
      return false;
    }
    if (l$$_hasKeysAll != null && lOther$$_hasKeysAll != null) {
      if (l$$_hasKeysAll.length != lOther$$_hasKeysAll.length) {
        return false;
      }
      for (int i = 0; i < l$$_hasKeysAll.length; i++) {
        final l$$_hasKeysAll$entry = l$$_hasKeysAll[i];
        final lOther$$_hasKeysAll$entry = lOther$$_hasKeysAll[i];
        if (l$$_hasKeysAll$entry != lOther$$_hasKeysAll$entry) {
          return false;
        }
      }
    } else if (l$$_hasKeysAll != lOther$$_hasKeysAll) {
      return false;
    }
    final l$$_hasKeysAny = $_hasKeysAny;
    final lOther$$_hasKeysAny = other.$_hasKeysAny;
    if (_$data.containsKey('_hasKeysAny') !=
        other._$data.containsKey('_hasKeysAny')) {
      return false;
    }
    if (l$$_hasKeysAny != null && lOther$$_hasKeysAny != null) {
      if (l$$_hasKeysAny.length != lOther$$_hasKeysAny.length) {
        return false;
      }
      for (int i = 0; i < l$$_hasKeysAny.length; i++) {
        final l$$_hasKeysAny$entry = l$$_hasKeysAny[i];
        final lOther$$_hasKeysAny$entry = lOther$$_hasKeysAny[i];
        if (l$$_hasKeysAny$entry != lOther$$_hasKeysAny$entry) {
          return false;
        }
      }
    } else if (l$$_hasKeysAny != lOther$$_hasKeysAny) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_cast = $_cast;
    final l$$_containedIn = $_containedIn;
    final l$$_contains = $_contains;
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_hasKey = $_hasKey;
    final l$$_hasKeysAll = $_hasKeysAll;
    final l$$_hasKeysAny = $_hasKeysAny;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_cast') ? l$$_cast : const {},
      _$data.containsKey('_containedIn') ? l$$_containedIn : const {},
      _$data.containsKey('_contains') ? l$$_contains : const {},
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_hasKey') ? l$$_hasKey : const {},
      _$data.containsKey('_hasKeysAll')
          ? l$$_hasKeysAll == null
              ? null
              : Object.hashAll(l$$_hasKeysAll.map((v) => v))
          : const {},
      _$data.containsKey('_hasKeysAny')
          ? l$$_hasKeysAny == null
              ? null
              : Object.hashAll(l$$_hasKeysAny.map((v) => v))
          : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputJsonbComparisonExp<TRes> {
  factory CopyWith$InputJsonbComparisonExp(
    InputJsonbComparisonExp instance,
    TRes Function(InputJsonbComparisonExp) then,
  ) = _CopyWithImpl$InputJsonbComparisonExp;

  factory CopyWith$InputJsonbComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputJsonbComparisonExp;

  TRes call({
    InputJsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  });
  CopyWith$InputJsonbCastExp<TRes> get $_cast;
}

class _CopyWithImpl$InputJsonbComparisonExp<TRes>
    implements CopyWith$InputJsonbComparisonExp<TRes> {
  _CopyWithImpl$InputJsonbComparisonExp(
    this._instance,
    this._then,
  );

  final InputJsonbComparisonExp _instance;

  final TRes Function(InputJsonbComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_cast = _undefined,
    Object? $_containedIn = _undefined,
    Object? $_contains = _undefined,
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_hasKey = _undefined,
    Object? $_hasKeysAll = _undefined,
    Object? $_hasKeysAny = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputJsonbComparisonExp._({
        ..._instance._$data,
        if ($_cast != _undefined) '_cast': ($_cast as InputJsonbCastExp?),
        if ($_containedIn != _undefined)
          '_containedIn': ($_containedIn as Map<String, dynamic>?),
        if ($_contains != _undefined)
          '_contains': ($_contains as Map<String, dynamic>?),
        if ($_eq != _undefined) '_eq': ($_eq as Map<String, dynamic>?),
        if ($_gt != _undefined) '_gt': ($_gt as Map<String, dynamic>?),
        if ($_gte != _undefined) '_gte': ($_gte as Map<String, dynamic>?),
        if ($_hasKey != _undefined) '_hasKey': ($_hasKey as String?),
        if ($_hasKeysAll != _undefined)
          '_hasKeysAll': ($_hasKeysAll as List<String>?),
        if ($_hasKeysAny != _undefined)
          '_hasKeysAny': ($_hasKeysAny as List<String>?),
        if ($_in != _undefined) '_in': ($_in as List<Map<String, dynamic>>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as Map<String, dynamic>?),
        if ($_lte != _undefined) '_lte': ($_lte as Map<String, dynamic>?),
        if ($_neq != _undefined) '_neq': ($_neq as Map<String, dynamic>?),
        if ($_nin != _undefined) '_nin': ($_nin as List<Map<String, dynamic>>?),
      }));
  CopyWith$InputJsonbCastExp<TRes> get $_cast {
    final local$$_cast = _instance.$_cast;
    return local$$_cast == null
        ? CopyWith$InputJsonbCastExp.stub(_then(_instance))
        : CopyWith$InputJsonbCastExp(local$$_cast, (e) => call($_cast: e));
  }
}

class _CopyWithStubImpl$InputJsonbComparisonExp<TRes>
    implements CopyWith$InputJsonbComparisonExp<TRes> {
  _CopyWithStubImpl$InputJsonbComparisonExp(this._res);

  TRes _res;

  call({
    InputJsonbCastExp? $_cast,
    Map<String, dynamic>? $_containedIn,
    Map<String, dynamic>? $_contains,
    Map<String, dynamic>? $_eq,
    Map<String, dynamic>? $_gt,
    Map<String, dynamic>? $_gte,
    String? $_hasKey,
    List<String>? $_hasKeysAll,
    List<String>? $_hasKeysAny,
    List<Map<String, dynamic>>? $_in,
    bool? $_isNull,
    Map<String, dynamic>? $_lt,
    Map<String, dynamic>? $_lte,
    Map<String, dynamic>? $_neq,
    List<Map<String, dynamic>>? $_nin,
  }) =>
      _res;
  CopyWith$InputJsonbCastExp<TRes> get $_cast =>
      CopyWith$InputJsonbCastExp.stub(_res);
}

class InputStringComparisonExp {
  factory InputStringComparisonExp({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      InputStringComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_ilike != null) r'_ilike': $_ilike,
        if ($_in != null) r'_in': $_in,
        if ($_iregex != null) r'_iregex': $_iregex,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_like != null) r'_like': $_like,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nilike != null) r'_nilike': $_nilike,
        if ($_nin != null) r'_nin': $_nin,
        if ($_niregex != null) r'_niregex': $_niregex,
        if ($_nlike != null) r'_nlike': $_nlike,
        if ($_nregex != null) r'_nregex': $_nregex,
        if ($_nsimilar != null) r'_nsimilar': $_nsimilar,
        if ($_regex != null) r'_regex': $_regex,
        if ($_similar != null) r'_similar': $_similar,
      });

  InputStringComparisonExp._(this._$data);

  factory InputStringComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as String?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as String?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as String?);
    }
    if (data.containsKey('_ilike')) {
      final l$$_ilike = data['_ilike'];
      result$data['_ilike'] = (l$$_ilike as String?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_iregex')) {
      final l$$_iregex = data['_iregex'];
      result$data['_iregex'] = (l$$_iregex as String?);
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_like')) {
      final l$$_like = data['_like'];
      result$data['_like'] = (l$$_like as String?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as String?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as String?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as String?);
    }
    if (data.containsKey('_nilike')) {
      final l$$_nilike = data['_nilike'];
      result$data['_nilike'] = (l$$_nilike as String?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_niregex')) {
      final l$$_niregex = data['_niregex'];
      result$data['_niregex'] = (l$$_niregex as String?);
    }
    if (data.containsKey('_nlike')) {
      final l$$_nlike = data['_nlike'];
      result$data['_nlike'] = (l$$_nlike as String?);
    }
    if (data.containsKey('_nregex')) {
      final l$$_nregex = data['_nregex'];
      result$data['_nregex'] = (l$$_nregex as String?);
    }
    if (data.containsKey('_nsimilar')) {
      final l$$_nsimilar = data['_nsimilar'];
      result$data['_nsimilar'] = (l$$_nsimilar as String?);
    }
    if (data.containsKey('_regex')) {
      final l$$_regex = data['_regex'];
      result$data['_regex'] = (l$$_regex as String?);
    }
    if (data.containsKey('_similar')) {
      final l$$_similar = data['_similar'];
      result$data['_similar'] = (l$$_similar as String?);
    }
    return InputStringComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $_eq => (_$data['_eq'] as String?);
  String? get $_gt => (_$data['_gt'] as String?);
  String? get $_gte => (_$data['_gte'] as String?);
  String? get $_ilike => (_$data['_ilike'] as String?);
  List<String>? get $_in => (_$data['_in'] as List<String>?);
  String? get $_iregex => (_$data['_iregex'] as String?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  String? get $_like => (_$data['_like'] as String?);
  String? get $_lt => (_$data['_lt'] as String?);
  String? get $_lte => (_$data['_lte'] as String?);
  String? get $_neq => (_$data['_neq'] as String?);
  String? get $_nilike => (_$data['_nilike'] as String?);
  List<String>? get $_nin => (_$data['_nin'] as List<String>?);
  String? get $_niregex => (_$data['_niregex'] as String?);
  String? get $_nlike => (_$data['_nlike'] as String?);
  String? get $_nregex => (_$data['_nregex'] as String?);
  String? get $_nsimilar => (_$data['_nsimilar'] as String?);
  String? get $_regex => (_$data['_regex'] as String?);
  String? get $_similar => (_$data['_similar'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_ilike')) {
      final l$$_ilike = $_ilike;
      result$data['_ilike'] = l$$_ilike;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_iregex')) {
      final l$$_iregex = $_iregex;
      result$data['_iregex'] = l$$_iregex;
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_like')) {
      final l$$_like = $_like;
      result$data['_like'] = l$$_like;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nilike')) {
      final l$$_nilike = $_nilike;
      result$data['_nilike'] = l$$_nilike;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    if (_$data.containsKey('_niregex')) {
      final l$$_niregex = $_niregex;
      result$data['_niregex'] = l$$_niregex;
    }
    if (_$data.containsKey('_nlike')) {
      final l$$_nlike = $_nlike;
      result$data['_nlike'] = l$$_nlike;
    }
    if (_$data.containsKey('_nregex')) {
      final l$$_nregex = $_nregex;
      result$data['_nregex'] = l$$_nregex;
    }
    if (_$data.containsKey('_nsimilar')) {
      final l$$_nsimilar = $_nsimilar;
      result$data['_nsimilar'] = l$$_nsimilar;
    }
    if (_$data.containsKey('_regex')) {
      final l$$_regex = $_regex;
      result$data['_regex'] = l$$_regex;
    }
    if (_$data.containsKey('_similar')) {
      final l$$_similar = $_similar;
      result$data['_similar'] = l$$_similar;
    }
    return result$data;
  }

  CopyWith$InputStringComparisonExp<InputStringComparisonExp> get copyWith =>
      CopyWith$InputStringComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputStringComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_ilike = $_ilike;
    final lOther$$_ilike = other.$_ilike;
    if (_$data.containsKey('_ilike') != other._$data.containsKey('_ilike')) {
      return false;
    }
    if (l$$_ilike != lOther$$_ilike) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_iregex = $_iregex;
    final lOther$$_iregex = other.$_iregex;
    if (_$data.containsKey('_iregex') != other._$data.containsKey('_iregex')) {
      return false;
    }
    if (l$$_iregex != lOther$$_iregex) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_like = $_like;
    final lOther$$_like = other.$_like;
    if (_$data.containsKey('_like') != other._$data.containsKey('_like')) {
      return false;
    }
    if (l$$_like != lOther$$_like) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nilike = $_nilike;
    final lOther$$_nilike = other.$_nilike;
    if (_$data.containsKey('_nilike') != other._$data.containsKey('_nilike')) {
      return false;
    }
    if (l$$_nilike != lOther$$_nilike) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    final l$$_niregex = $_niregex;
    final lOther$$_niregex = other.$_niregex;
    if (_$data.containsKey('_niregex') !=
        other._$data.containsKey('_niregex')) {
      return false;
    }
    if (l$$_niregex != lOther$$_niregex) {
      return false;
    }
    final l$$_nlike = $_nlike;
    final lOther$$_nlike = other.$_nlike;
    if (_$data.containsKey('_nlike') != other._$data.containsKey('_nlike')) {
      return false;
    }
    if (l$$_nlike != lOther$$_nlike) {
      return false;
    }
    final l$$_nregex = $_nregex;
    final lOther$$_nregex = other.$_nregex;
    if (_$data.containsKey('_nregex') != other._$data.containsKey('_nregex')) {
      return false;
    }
    if (l$$_nregex != lOther$$_nregex) {
      return false;
    }
    final l$$_nsimilar = $_nsimilar;
    final lOther$$_nsimilar = other.$_nsimilar;
    if (_$data.containsKey('_nsimilar') !=
        other._$data.containsKey('_nsimilar')) {
      return false;
    }
    if (l$$_nsimilar != lOther$$_nsimilar) {
      return false;
    }
    final l$$_regex = $_regex;
    final lOther$$_regex = other.$_regex;
    if (_$data.containsKey('_regex') != other._$data.containsKey('_regex')) {
      return false;
    }
    if (l$$_regex != lOther$$_regex) {
      return false;
    }
    final l$$_similar = $_similar;
    final lOther$$_similar = other.$_similar;
    if (_$data.containsKey('_similar') !=
        other._$data.containsKey('_similar')) {
      return false;
    }
    if (l$$_similar != lOther$$_similar) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_ilike = $_ilike;
    final l$$_in = $_in;
    final l$$_iregex = $_iregex;
    final l$$_isNull = $_isNull;
    final l$$_like = $_like;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nilike = $_nilike;
    final l$$_nin = $_nin;
    final l$$_niregex = $_niregex;
    final l$$_nlike = $_nlike;
    final l$$_nregex = $_nregex;
    final l$$_nsimilar = $_nsimilar;
    final l$$_regex = $_regex;
    final l$$_similar = $_similar;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_ilike') ? l$$_ilike : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_iregex') ? l$$_iregex : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_like') ? l$$_like : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nilike') ? l$$_nilike : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
      _$data.containsKey('_niregex') ? l$$_niregex : const {},
      _$data.containsKey('_nlike') ? l$$_nlike : const {},
      _$data.containsKey('_nregex') ? l$$_nregex : const {},
      _$data.containsKey('_nsimilar') ? l$$_nsimilar : const {},
      _$data.containsKey('_regex') ? l$$_regex : const {},
      _$data.containsKey('_similar') ? l$$_similar : const {},
    ]);
  }
}

abstract class CopyWith$InputStringComparisonExp<TRes> {
  factory CopyWith$InputStringComparisonExp(
    InputStringComparisonExp instance,
    TRes Function(InputStringComparisonExp) then,
  ) = _CopyWithImpl$InputStringComparisonExp;

  factory CopyWith$InputStringComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputStringComparisonExp;

  TRes call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  });
}

class _CopyWithImpl$InputStringComparisonExp<TRes>
    implements CopyWith$InputStringComparisonExp<TRes> {
  _CopyWithImpl$InputStringComparisonExp(
    this._instance,
    this._then,
  );

  final InputStringComparisonExp _instance;

  final TRes Function(InputStringComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_ilike = _undefined,
    Object? $_in = _undefined,
    Object? $_iregex = _undefined,
    Object? $_isNull = _undefined,
    Object? $_like = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nilike = _undefined,
    Object? $_nin = _undefined,
    Object? $_niregex = _undefined,
    Object? $_nlike = _undefined,
    Object? $_nregex = _undefined,
    Object? $_nsimilar = _undefined,
    Object? $_regex = _undefined,
    Object? $_similar = _undefined,
  }) =>
      _then(InputStringComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as String?),
        if ($_gt != _undefined) '_gt': ($_gt as String?),
        if ($_gte != _undefined) '_gte': ($_gte as String?),
        if ($_ilike != _undefined) '_ilike': ($_ilike as String?),
        if ($_in != _undefined) '_in': ($_in as List<String>?),
        if ($_iregex != _undefined) '_iregex': ($_iregex as String?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_like != _undefined) '_like': ($_like as String?),
        if ($_lt != _undefined) '_lt': ($_lt as String?),
        if ($_lte != _undefined) '_lte': ($_lte as String?),
        if ($_neq != _undefined) '_neq': ($_neq as String?),
        if ($_nilike != _undefined) '_nilike': ($_nilike as String?),
        if ($_nin != _undefined) '_nin': ($_nin as List<String>?),
        if ($_niregex != _undefined) '_niregex': ($_niregex as String?),
        if ($_nlike != _undefined) '_nlike': ($_nlike as String?),
        if ($_nregex != _undefined) '_nregex': ($_nregex as String?),
        if ($_nsimilar != _undefined) '_nsimilar': ($_nsimilar as String?),
        if ($_regex != _undefined) '_regex': ($_regex as String?),
        if ($_similar != _undefined) '_similar': ($_similar as String?),
      }));
}

class _CopyWithStubImpl$InputStringComparisonExp<TRes>
    implements CopyWith$InputStringComparisonExp<TRes> {
  _CopyWithStubImpl$InputStringComparisonExp(this._res);

  TRes _res;

  call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    String? $_ilike,
    List<String>? $_in,
    String? $_iregex,
    bool? $_isNull,
    String? $_like,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    String? $_nilike,
    List<String>? $_nin,
    String? $_niregex,
    String? $_nlike,
    String? $_nregex,
    String? $_nsimilar,
    String? $_regex,
    String? $_similar,
  }) =>
      _res;
}

class InputTimestamptzComparisonExp {
  factory InputTimestamptzComparisonExp({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  }) =>
      InputTimestamptzComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputTimestamptzComparisonExp._(this._$data);

  factory InputTimestamptzComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] =
          l$$_eq == null ? null : fromGraphQLTimestamptzToDartDateTime(l$$_eq);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] =
          l$$_gt == null ? null : fromGraphQLTimestamptzToDartDateTime(l$$_gt);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = l$$_gte == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$$_gte);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] = (l$$_in as List<dynamic>?)
          ?.map((e) => fromGraphQLTimestamptzToDartDateTime(e))
          .toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] =
          l$$_lt == null ? null : fromGraphQLTimestamptzToDartDateTime(l$$_lt);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = l$$_lte == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$$_lte);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$$_neq);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] = (l$$_nin as List<dynamic>?)
          ?.map((e) => fromGraphQLTimestamptzToDartDateTime(e))
          .toList();
    }
    return InputTimestamptzComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get $_eq => (_$data['_eq'] as DateTime?);
  DateTime? get $_gt => (_$data['_gt'] as DateTime?);
  DateTime? get $_gte => (_$data['_gte'] as DateTime?);
  List<DateTime>? get $_in => (_$data['_in'] as List<DateTime>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  DateTime? get $_lt => (_$data['_lt'] as DateTime?);
  DateTime? get $_lte => (_$data['_lte'] as DateTime?);
  DateTime? get $_neq => (_$data['_neq'] as DateTime?);
  List<DateTime>? get $_nin => (_$data['_nin'] as List<DateTime>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] =
          l$$_eq == null ? null : fromDartDateTimeToGraphQLTimestamptz(l$$_eq);
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] =
          l$$_gt == null ? null : fromDartDateTimeToGraphQLTimestamptz(l$$_gt);
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$$_gte);
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] =
          l$$_in?.map((e) => fromDartDateTimeToGraphQLTimestamptz(e)).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] =
          l$$_lt == null ? null : fromDartDateTimeToGraphQLTimestamptz(l$$_lt);
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$$_lte);
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$$_neq);
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] =
          l$$_nin?.map((e) => fromDartDateTimeToGraphQLTimestamptz(e)).toList();
    }
    return result$data;
  }

  CopyWith$InputTimestamptzComparisonExp<InputTimestamptzComparisonExp>
      get copyWith => CopyWith$InputTimestamptzComparisonExp(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputTimestamptzComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputTimestamptzComparisonExp<TRes> {
  factory CopyWith$InputTimestamptzComparisonExp(
    InputTimestamptzComparisonExp instance,
    TRes Function(InputTimestamptzComparisonExp) then,
  ) = _CopyWithImpl$InputTimestamptzComparisonExp;

  factory CopyWith$InputTimestamptzComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputTimestamptzComparisonExp;

  TRes call({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  });
}

class _CopyWithImpl$InputTimestamptzComparisonExp<TRes>
    implements CopyWith$InputTimestamptzComparisonExp<TRes> {
  _CopyWithImpl$InputTimestamptzComparisonExp(
    this._instance,
    this._then,
  );

  final InputTimestamptzComparisonExp _instance;

  final TRes Function(InputTimestamptzComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputTimestamptzComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as DateTime?),
        if ($_gt != _undefined) '_gt': ($_gt as DateTime?),
        if ($_gte != _undefined) '_gte': ($_gte as DateTime?),
        if ($_in != _undefined) '_in': ($_in as List<DateTime>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as DateTime?),
        if ($_lte != _undefined) '_lte': ($_lte as DateTime?),
        if ($_neq != _undefined) '_neq': ($_neq as DateTime?),
        if ($_nin != _undefined) '_nin': ($_nin as List<DateTime>?),
      }));
}

class _CopyWithStubImpl$InputTimestamptzComparisonExp<TRes>
    implements CopyWith$InputTimestamptzComparisonExp<TRes> {
  _CopyWithStubImpl$InputTimestamptzComparisonExp(this._res);

  TRes _res;

  call({
    DateTime? $_eq,
    DateTime? $_gt,
    DateTime? $_gte,
    List<DateTime>? $_in,
    bool? $_isNull,
    DateTime? $_lt,
    DateTime? $_lte,
    DateTime? $_neq,
    List<DateTime>? $_nin,
  }) =>
      _res;
}

class InputUuidComparisonExp {
  factory InputUuidComparisonExp({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    List<String>? $_in,
    bool? $_isNull,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    List<String>? $_nin,
  }) =>
      InputUuidComparisonExp._({
        if ($_eq != null) r'_eq': $_eq,
        if ($_gt != null) r'_gt': $_gt,
        if ($_gte != null) r'_gte': $_gte,
        if ($_in != null) r'_in': $_in,
        if ($_isNull != null) r'_isNull': $_isNull,
        if ($_lt != null) r'_lt': $_lt,
        if ($_lte != null) r'_lte': $_lte,
        if ($_neq != null) r'_neq': $_neq,
        if ($_nin != null) r'_nin': $_nin,
      });

  InputUuidComparisonExp._(this._$data);

  factory InputUuidComparisonExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_eq')) {
      final l$$_eq = data['_eq'];
      result$data['_eq'] = (l$$_eq as String?);
    }
    if (data.containsKey('_gt')) {
      final l$$_gt = data['_gt'];
      result$data['_gt'] = (l$$_gt as String?);
    }
    if (data.containsKey('_gte')) {
      final l$$_gte = data['_gte'];
      result$data['_gte'] = (l$$_gte as String?);
    }
    if (data.containsKey('_in')) {
      final l$$_in = data['_in'];
      result$data['_in'] =
          (l$$_in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('_isNull')) {
      final l$$_isNull = data['_isNull'];
      result$data['_isNull'] = (l$$_isNull as bool?);
    }
    if (data.containsKey('_lt')) {
      final l$$_lt = data['_lt'];
      result$data['_lt'] = (l$$_lt as String?);
    }
    if (data.containsKey('_lte')) {
      final l$$_lte = data['_lte'];
      result$data['_lte'] = (l$$_lte as String?);
    }
    if (data.containsKey('_neq')) {
      final l$$_neq = data['_neq'];
      result$data['_neq'] = (l$$_neq as String?);
    }
    if (data.containsKey('_nin')) {
      final l$$_nin = data['_nin'];
      result$data['_nin'] =
          (l$$_nin as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return InputUuidComparisonExp._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $_eq => (_$data['_eq'] as String?);
  String? get $_gt => (_$data['_gt'] as String?);
  String? get $_gte => (_$data['_gte'] as String?);
  List<String>? get $_in => (_$data['_in'] as List<String>?);
  bool? get $_isNull => (_$data['_isNull'] as bool?);
  String? get $_lt => (_$data['_lt'] as String?);
  String? get $_lte => (_$data['_lte'] as String?);
  String? get $_neq => (_$data['_neq'] as String?);
  List<String>? get $_nin => (_$data['_nin'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_eq')) {
      final l$$_eq = $_eq;
      result$data['_eq'] = l$$_eq;
    }
    if (_$data.containsKey('_gt')) {
      final l$$_gt = $_gt;
      result$data['_gt'] = l$$_gt;
    }
    if (_$data.containsKey('_gte')) {
      final l$$_gte = $_gte;
      result$data['_gte'] = l$$_gte;
    }
    if (_$data.containsKey('_in')) {
      final l$$_in = $_in;
      result$data['_in'] = l$$_in?.map((e) => e).toList();
    }
    if (_$data.containsKey('_isNull')) {
      final l$$_isNull = $_isNull;
      result$data['_isNull'] = l$$_isNull;
    }
    if (_$data.containsKey('_lt')) {
      final l$$_lt = $_lt;
      result$data['_lt'] = l$$_lt;
    }
    if (_$data.containsKey('_lte')) {
      final l$$_lte = $_lte;
      result$data['_lte'] = l$$_lte;
    }
    if (_$data.containsKey('_neq')) {
      final l$$_neq = $_neq;
      result$data['_neq'] = l$$_neq;
    }
    if (_$data.containsKey('_nin')) {
      final l$$_nin = $_nin;
      result$data['_nin'] = l$$_nin?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputUuidComparisonExp<InputUuidComparisonExp> get copyWith =>
      CopyWith$InputUuidComparisonExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputUuidComparisonExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_eq = $_eq;
    final lOther$$_eq = other.$_eq;
    if (_$data.containsKey('_eq') != other._$data.containsKey('_eq')) {
      return false;
    }
    if (l$$_eq != lOther$$_eq) {
      return false;
    }
    final l$$_gt = $_gt;
    final lOther$$_gt = other.$_gt;
    if (_$data.containsKey('_gt') != other._$data.containsKey('_gt')) {
      return false;
    }
    if (l$$_gt != lOther$$_gt) {
      return false;
    }
    final l$$_gte = $_gte;
    final lOther$$_gte = other.$_gte;
    if (_$data.containsKey('_gte') != other._$data.containsKey('_gte')) {
      return false;
    }
    if (l$$_gte != lOther$$_gte) {
      return false;
    }
    final l$$_in = $_in;
    final lOther$$_in = other.$_in;
    if (_$data.containsKey('_in') != other._$data.containsKey('_in')) {
      return false;
    }
    if (l$$_in != null && lOther$$_in != null) {
      if (l$$_in.length != lOther$$_in.length) {
        return false;
      }
      for (int i = 0; i < l$$_in.length; i++) {
        final l$$_in$entry = l$$_in[i];
        final lOther$$_in$entry = lOther$$_in[i];
        if (l$$_in$entry != lOther$$_in$entry) {
          return false;
        }
      }
    } else if (l$$_in != lOther$$_in) {
      return false;
    }
    final l$$_isNull = $_isNull;
    final lOther$$_isNull = other.$_isNull;
    if (_$data.containsKey('_isNull') != other._$data.containsKey('_isNull')) {
      return false;
    }
    if (l$$_isNull != lOther$$_isNull) {
      return false;
    }
    final l$$_lt = $_lt;
    final lOther$$_lt = other.$_lt;
    if (_$data.containsKey('_lt') != other._$data.containsKey('_lt')) {
      return false;
    }
    if (l$$_lt != lOther$$_lt) {
      return false;
    }
    final l$$_lte = $_lte;
    final lOther$$_lte = other.$_lte;
    if (_$data.containsKey('_lte') != other._$data.containsKey('_lte')) {
      return false;
    }
    if (l$$_lte != lOther$$_lte) {
      return false;
    }
    final l$$_neq = $_neq;
    final lOther$$_neq = other.$_neq;
    if (_$data.containsKey('_neq') != other._$data.containsKey('_neq')) {
      return false;
    }
    if (l$$_neq != lOther$$_neq) {
      return false;
    }
    final l$$_nin = $_nin;
    final lOther$$_nin = other.$_nin;
    if (_$data.containsKey('_nin') != other._$data.containsKey('_nin')) {
      return false;
    }
    if (l$$_nin != null && lOther$$_nin != null) {
      if (l$$_nin.length != lOther$$_nin.length) {
        return false;
      }
      for (int i = 0; i < l$$_nin.length; i++) {
        final l$$_nin$entry = l$$_nin[i];
        final lOther$$_nin$entry = lOther$$_nin[i];
        if (l$$_nin$entry != lOther$$_nin$entry) {
          return false;
        }
      }
    } else if (l$$_nin != lOther$$_nin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_eq = $_eq;
    final l$$_gt = $_gt;
    final l$$_gte = $_gte;
    final l$$_in = $_in;
    final l$$_isNull = $_isNull;
    final l$$_lt = $_lt;
    final l$$_lte = $_lte;
    final l$$_neq = $_neq;
    final l$$_nin = $_nin;
    return Object.hashAll([
      _$data.containsKey('_eq') ? l$$_eq : const {},
      _$data.containsKey('_gt') ? l$$_gt : const {},
      _$data.containsKey('_gte') ? l$$_gte : const {},
      _$data.containsKey('_in')
          ? l$$_in == null
              ? null
              : Object.hashAll(l$$_in.map((v) => v))
          : const {},
      _$data.containsKey('_isNull') ? l$$_isNull : const {},
      _$data.containsKey('_lt') ? l$$_lt : const {},
      _$data.containsKey('_lte') ? l$$_lte : const {},
      _$data.containsKey('_neq') ? l$$_neq : const {},
      _$data.containsKey('_nin')
          ? l$$_nin == null
              ? null
              : Object.hashAll(l$$_nin.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$InputUuidComparisonExp<TRes> {
  factory CopyWith$InputUuidComparisonExp(
    InputUuidComparisonExp instance,
    TRes Function(InputUuidComparisonExp) then,
  ) = _CopyWithImpl$InputUuidComparisonExp;

  factory CopyWith$InputUuidComparisonExp.stub(TRes res) =
      _CopyWithStubImpl$InputUuidComparisonExp;

  TRes call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    List<String>? $_in,
    bool? $_isNull,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    List<String>? $_nin,
  });
}

class _CopyWithImpl$InputUuidComparisonExp<TRes>
    implements CopyWith$InputUuidComparisonExp<TRes> {
  _CopyWithImpl$InputUuidComparisonExp(
    this._instance,
    this._then,
  );

  final InputUuidComparisonExp _instance;

  final TRes Function(InputUuidComparisonExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_eq = _undefined,
    Object? $_gt = _undefined,
    Object? $_gte = _undefined,
    Object? $_in = _undefined,
    Object? $_isNull = _undefined,
    Object? $_lt = _undefined,
    Object? $_lte = _undefined,
    Object? $_neq = _undefined,
    Object? $_nin = _undefined,
  }) =>
      _then(InputUuidComparisonExp._({
        ..._instance._$data,
        if ($_eq != _undefined) '_eq': ($_eq as String?),
        if ($_gt != _undefined) '_gt': ($_gt as String?),
        if ($_gte != _undefined) '_gte': ($_gte as String?),
        if ($_in != _undefined) '_in': ($_in as List<String>?),
        if ($_isNull != _undefined) '_isNull': ($_isNull as bool?),
        if ($_lt != _undefined) '_lt': ($_lt as String?),
        if ($_lte != _undefined) '_lte': ($_lte as String?),
        if ($_neq != _undefined) '_neq': ($_neq as String?),
        if ($_nin != _undefined) '_nin': ($_nin as List<String>?),
      }));
}

class _CopyWithStubImpl$InputUuidComparisonExp<TRes>
    implements CopyWith$InputUuidComparisonExp<TRes> {
  _CopyWithStubImpl$InputUuidComparisonExp(this._res);

  TRes _res;

  call({
    String? $_eq,
    String? $_gt,
    String? $_gte,
    List<String>? $_in,
    bool? $_isNull,
    String? $_lt,
    String? $_lte,
    String? $_neq,
    List<String>? $_nin,
  }) =>
      _res;
}

class InputauthProviderRequestsAppendInput {
  factory InputauthProviderRequestsAppendInput(
          {Map<String, dynamic>? options}) =>
      InputauthProviderRequestsAppendInput._({
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsAppendInput._(this._$data);

  factory InputauthProviderRequestsAppendInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as Map<String, dynamic>?);
    }
    return InputauthProviderRequestsAppendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Map<String, dynamic>? get options =>
      (_$data['options'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsAppendInput<
          InputauthProviderRequestsAppendInput>
      get copyWith => CopyWith$InputauthProviderRequestsAppendInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsAppendInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$options = options;
    return Object.hashAll(
        [_$data.containsKey('options') ? l$options : const {}]);
  }
}

abstract class CopyWith$InputauthProviderRequestsAppendInput<TRes> {
  factory CopyWith$InputauthProviderRequestsAppendInput(
    InputauthProviderRequestsAppendInput instance,
    TRes Function(InputauthProviderRequestsAppendInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsAppendInput;

  factory CopyWith$InputauthProviderRequestsAppendInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsAppendInput;

  TRes call({Map<String, dynamic>? options});
}

class _CopyWithImpl$InputauthProviderRequestsAppendInput<TRes>
    implements CopyWith$InputauthProviderRequestsAppendInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsAppendInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsAppendInput _instance;

  final TRes Function(InputauthProviderRequestsAppendInput) _then;

  static const _undefined = {};

  TRes call({Object? options = _undefined}) =>
      _then(InputauthProviderRequestsAppendInput._({
        ..._instance._$data,
        if (options != _undefined)
          'options': (options as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsAppendInput<TRes>
    implements CopyWith$InputauthProviderRequestsAppendInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsAppendInput(this._res);

  TRes _res;

  call({Map<String, dynamic>? options}) => _res;
}

class InputauthProviderRequestsBoolExp {
  factory InputauthProviderRequestsBoolExp({
    List<InputauthProviderRequestsBoolExp>? $_and,
    InputauthProviderRequestsBoolExp? $_not,
    List<InputauthProviderRequestsBoolExp>? $_or,
    InputUuidComparisonExp? id,
    InputJsonbComparisonExp? options,
  }) =>
      InputauthProviderRequestsBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (id != null) r'id': id,
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsBoolExp._(this._$data);

  factory InputauthProviderRequestsBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputauthProviderRequestsBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthProviderRequestsBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputauthProviderRequestsBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = l$options == null
          ? null
          : InputJsonbComparisonExp.fromJson(
              (l$options as Map<String, dynamic>));
    }
    return InputauthProviderRequestsBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthProviderRequestsBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthProviderRequestsBoolExp>?);
  InputauthProviderRequestsBoolExp? get $_not =>
      (_$data['_not'] as InputauthProviderRequestsBoolExp?);
  List<InputauthProviderRequestsBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthProviderRequestsBoolExp>?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputJsonbComparisonExp? get options =>
      (_$data['options'] as InputJsonbComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsBoolExp<InputauthProviderRequestsBoolExp>
      get copyWith => CopyWith$InputauthProviderRequestsBoolExp(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$id = id;
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('options') ? l$options : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsBoolExp<TRes> {
  factory CopyWith$InputauthProviderRequestsBoolExp(
    InputauthProviderRequestsBoolExp instance,
    TRes Function(InputauthProviderRequestsBoolExp) then,
  ) = _CopyWithImpl$InputauthProviderRequestsBoolExp;

  factory CopyWith$InputauthProviderRequestsBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsBoolExp;

  TRes call({
    List<InputauthProviderRequestsBoolExp>? $_and,
    InputauthProviderRequestsBoolExp? $_not,
    List<InputauthProviderRequestsBoolExp>? $_or,
    InputUuidComparisonExp? id,
    InputJsonbComparisonExp? options,
  });
  TRes $_and(
      Iterable<InputauthProviderRequestsBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthProviderRequestsBoolExp<
                      InputauthProviderRequestsBoolExp>>?)
          _fn);
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthProviderRequestsBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthProviderRequestsBoolExp<
                      InputauthProviderRequestsBoolExp>>?)
          _fn);
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputJsonbComparisonExp<TRes> get options;
}

class _CopyWithImpl$InputauthProviderRequestsBoolExp<TRes>
    implements CopyWith$InputauthProviderRequestsBoolExp<TRes> {
  _CopyWithImpl$InputauthProviderRequestsBoolExp(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsBoolExp _instance;

  final TRes Function(InputauthProviderRequestsBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? id = _undefined,
    Object? options = _undefined,
  }) =>
      _then(InputauthProviderRequestsBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthProviderRequestsBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as InputauthProviderRequestsBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthProviderRequestsBoolExp>?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (options != _undefined)
          'options': (options as InputJsonbComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputauthProviderRequestsBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthProviderRequestsBoolExp<
                          InputauthProviderRequestsBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and
              ?.map((e) => CopyWith$InputauthProviderRequestsBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthProviderRequestsBoolExp.stub(_then(_instance))
        : CopyWith$InputauthProviderRequestsBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthProviderRequestsBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthProviderRequestsBoolExp<
                          InputauthProviderRequestsBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or
              ?.map((e) => CopyWith$InputauthProviderRequestsBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputJsonbComparisonExp<TRes> get options {
    final local$options = _instance.options;
    return local$options == null
        ? CopyWith$InputJsonbComparisonExp.stub(_then(_instance))
        : CopyWith$InputJsonbComparisonExp(
            local$options, (e) => call(options: e));
  }
}

class _CopyWithStubImpl$InputauthProviderRequestsBoolExp<TRes>
    implements CopyWith$InputauthProviderRequestsBoolExp<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthProviderRequestsBoolExp>? $_and,
    InputauthProviderRequestsBoolExp? $_not,
    List<InputauthProviderRequestsBoolExp>? $_or,
    InputUuidComparisonExp? id,
    InputJsonbComparisonExp? options,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get $_not =>
      CopyWith$InputauthProviderRequestsBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputJsonbComparisonExp<TRes> get options =>
      CopyWith$InputJsonbComparisonExp.stub(_res);
}

class InputauthProviderRequestsDeleteAtPathInput {
  factory InputauthProviderRequestsDeleteAtPathInput({List<String>? options}) =>
      InputauthProviderRequestsDeleteAtPathInput._({
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsDeleteAtPathInput._(this._$data);

  factory InputauthProviderRequestsDeleteAtPathInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] =
          (l$options as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return InputauthProviderRequestsDeleteAtPathInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get options => (_$data['options'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsDeleteAtPathInput<
          InputauthProviderRequestsDeleteAtPathInput>
      get copyWith => CopyWith$InputauthProviderRequestsDeleteAtPathInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsDeleteAtPathInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != null && lOther$options != null) {
      if (l$options.length != lOther$options.length) {
        return false;
      }
      for (int i = 0; i < l$options.length; i++) {
        final l$options$entry = l$options[i];
        final lOther$options$entry = lOther$options[i];
        if (l$options$entry != lOther$options$entry) {
          return false;
        }
      }
    } else if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('options')
          ? l$options == null
              ? null
              : Object.hashAll(l$options.map((v) => v))
          : const {}
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes> {
  factory CopyWith$InputauthProviderRequestsDeleteAtPathInput(
    InputauthProviderRequestsDeleteAtPathInput instance,
    TRes Function(InputauthProviderRequestsDeleteAtPathInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsDeleteAtPathInput;

  factory CopyWith$InputauthProviderRequestsDeleteAtPathInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsDeleteAtPathInput;

  TRes call({List<String>? options});
}

class _CopyWithImpl$InputauthProviderRequestsDeleteAtPathInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsDeleteAtPathInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsDeleteAtPathInput _instance;

  final TRes Function(InputauthProviderRequestsDeleteAtPathInput) _then;

  static const _undefined = {};

  TRes call({Object? options = _undefined}) =>
      _then(InputauthProviderRequestsDeleteAtPathInput._({
        ..._instance._$data,
        if (options != _undefined) 'options': (options as List<String>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsDeleteAtPathInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsDeleteAtPathInput(this._res);

  TRes _res;

  call({List<String>? options}) => _res;
}

class InputauthProviderRequestsDeleteElemInput {
  factory InputauthProviderRequestsDeleteElemInput({int? options}) =>
      InputauthProviderRequestsDeleteElemInput._({
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsDeleteElemInput._(this._$data);

  factory InputauthProviderRequestsDeleteElemInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as int?);
    }
    return InputauthProviderRequestsDeleteElemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get options => (_$data['options'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsDeleteElemInput<
          InputauthProviderRequestsDeleteElemInput>
      get copyWith => CopyWith$InputauthProviderRequestsDeleteElemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsDeleteElemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$options = options;
    return Object.hashAll(
        [_$data.containsKey('options') ? l$options : const {}]);
  }
}

abstract class CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> {
  factory CopyWith$InputauthProviderRequestsDeleteElemInput(
    InputauthProviderRequestsDeleteElemInput instance,
    TRes Function(InputauthProviderRequestsDeleteElemInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsDeleteElemInput;

  factory CopyWith$InputauthProviderRequestsDeleteElemInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsDeleteElemInput;

  TRes call({int? options});
}

class _CopyWithImpl$InputauthProviderRequestsDeleteElemInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsDeleteElemInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsDeleteElemInput _instance;

  final TRes Function(InputauthProviderRequestsDeleteElemInput) _then;

  static const _undefined = {};

  TRes call({Object? options = _undefined}) =>
      _then(InputauthProviderRequestsDeleteElemInput._({
        ..._instance._$data,
        if (options != _undefined) 'options': (options as int?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsDeleteElemInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsDeleteElemInput(this._res);

  TRes _res;

  call({int? options}) => _res;
}

class InputauthProviderRequestsDeleteKeyInput {
  factory InputauthProviderRequestsDeleteKeyInput({String? options}) =>
      InputauthProviderRequestsDeleteKeyInput._({
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsDeleteKeyInput._(this._$data);

  factory InputauthProviderRequestsDeleteKeyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as String?);
    }
    return InputauthProviderRequestsDeleteKeyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get options => (_$data['options'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsDeleteKeyInput<
          InputauthProviderRequestsDeleteKeyInput>
      get copyWith => CopyWith$InputauthProviderRequestsDeleteKeyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsDeleteKeyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$options = options;
    return Object.hashAll(
        [_$data.containsKey('options') ? l$options : const {}]);
  }
}

abstract class CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> {
  factory CopyWith$InputauthProviderRequestsDeleteKeyInput(
    InputauthProviderRequestsDeleteKeyInput instance,
    TRes Function(InputauthProviderRequestsDeleteKeyInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsDeleteKeyInput;

  factory CopyWith$InputauthProviderRequestsDeleteKeyInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsDeleteKeyInput;

  TRes call({String? options});
}

class _CopyWithImpl$InputauthProviderRequestsDeleteKeyInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsDeleteKeyInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsDeleteKeyInput _instance;

  final TRes Function(InputauthProviderRequestsDeleteKeyInput) _then;

  static const _undefined = {};

  TRes call({Object? options = _undefined}) =>
      _then(InputauthProviderRequestsDeleteKeyInput._({
        ..._instance._$data,
        if (options != _undefined) 'options': (options as String?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsDeleteKeyInput<TRes>
    implements CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsDeleteKeyInput(this._res);

  TRes _res;

  call({String? options}) => _res;
}

class InputauthProviderRequestsInsertInput {
  factory InputauthProviderRequestsInsertInput({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      InputauthProviderRequestsInsertInput._({
        if (id != null) r'id': id,
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsInsertInput._(this._$data);

  factory InputauthProviderRequestsInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as Map<String, dynamic>?);
    }
    return InputauthProviderRequestsInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  Map<String, dynamic>? get options =>
      (_$data['options'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsInsertInput<
          InputauthProviderRequestsInsertInput>
      get copyWith => CopyWith$InputauthProviderRequestsInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('options') ? l$options : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsInsertInput<TRes> {
  factory CopyWith$InputauthProviderRequestsInsertInput(
    InputauthProviderRequestsInsertInput instance,
    TRes Function(InputauthProviderRequestsInsertInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsInsertInput;

  factory CopyWith$InputauthProviderRequestsInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsInsertInput;

  TRes call({
    String? id,
    Map<String, dynamic>? options,
  });
}

class _CopyWithImpl$InputauthProviderRequestsInsertInput<TRes>
    implements CopyWith$InputauthProviderRequestsInsertInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsInsertInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsInsertInput _instance;

  final TRes Function(InputauthProviderRequestsInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? options = _undefined,
  }) =>
      _then(InputauthProviderRequestsInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (options != _undefined)
          'options': (options as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsInsertInput<TRes>
    implements CopyWith$InputauthProviderRequestsInsertInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      _res;
}

class InputauthProviderRequestsOnConflict {
  factory InputauthProviderRequestsOnConflict({
    required EnumauthProviderRequestsConstraint constraint,
    required List<EnumauthProviderRequestsUpdateColumn> update_columns,
    InputauthProviderRequestsBoolExp? where,
  }) =>
      InputauthProviderRequestsOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthProviderRequestsOnConflict._(this._$data);

  factory InputauthProviderRequestsOnConflict.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthProviderRequestsConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map(
            (e) => fromJson$EnumauthProviderRequestsUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthProviderRequestsBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthProviderRequestsOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthProviderRequestsConstraint get constraint =>
      (_$data['constraint'] as EnumauthProviderRequestsConstraint);
  List<EnumauthProviderRequestsUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthProviderRequestsUpdateColumn>);
  InputauthProviderRequestsBoolExp? get where =>
      (_$data['where'] as InputauthProviderRequestsBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthProviderRequestsConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthProviderRequestsUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsOnConflict<
          InputauthProviderRequestsOnConflict>
      get copyWith => CopyWith$InputauthProviderRequestsOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsOnConflict<TRes> {
  factory CopyWith$InputauthProviderRequestsOnConflict(
    InputauthProviderRequestsOnConflict instance,
    TRes Function(InputauthProviderRequestsOnConflict) then,
  ) = _CopyWithImpl$InputauthProviderRequestsOnConflict;

  factory CopyWith$InputauthProviderRequestsOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsOnConflict;

  TRes call({
    EnumauthProviderRequestsConstraint? constraint,
    List<EnumauthProviderRequestsUpdateColumn>? update_columns,
    InputauthProviderRequestsBoolExp? where,
  });
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthProviderRequestsOnConflict<TRes>
    implements CopyWith$InputauthProviderRequestsOnConflict<TRes> {
  _CopyWithImpl$InputauthProviderRequestsOnConflict(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsOnConflict _instance;

  final TRes Function(InputauthProviderRequestsOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthProviderRequestsOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthProviderRequestsConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthProviderRequestsUpdateColumn>),
        if (where != _undefined)
          'where': (where as InputauthProviderRequestsBoolExp?),
      }));
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthProviderRequestsBoolExp.stub(_then(_instance))
        : CopyWith$InputauthProviderRequestsBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthProviderRequestsOnConflict<TRes>
    implements CopyWith$InputauthProviderRequestsOnConflict<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsOnConflict(this._res);

  TRes _res;

  call({
    EnumauthProviderRequestsConstraint? constraint,
    List<EnumauthProviderRequestsUpdateColumn>? update_columns,
    InputauthProviderRequestsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where =>
      CopyWith$InputauthProviderRequestsBoolExp.stub(_res);
}

class InputauthProviderRequestsOrderBy {
  factory InputauthProviderRequestsOrderBy({
    EnumOrderBy? id,
    EnumOrderBy? options,
  }) =>
      InputauthProviderRequestsOrderBy._({
        if (id != null) r'id': id,
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsOrderBy._(this._$data);

  factory InputauthProviderRequestsOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = l$options == null
          ? null
          : fromJson$EnumOrderBy((l$options as String));
    }
    return InputauthProviderRequestsOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get options => (_$data['options'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] =
          l$options == null ? null : toJson$EnumOrderBy(l$options);
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsOrderBy<InputauthProviderRequestsOrderBy>
      get copyWith => CopyWith$InputauthProviderRequestsOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('options') ? l$options : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsOrderBy<TRes> {
  factory CopyWith$InputauthProviderRequestsOrderBy(
    InputauthProviderRequestsOrderBy instance,
    TRes Function(InputauthProviderRequestsOrderBy) then,
  ) = _CopyWithImpl$InputauthProviderRequestsOrderBy;

  factory CopyWith$InputauthProviderRequestsOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsOrderBy;

  TRes call({
    EnumOrderBy? id,
    EnumOrderBy? options,
  });
}

class _CopyWithImpl$InputauthProviderRequestsOrderBy<TRes>
    implements CopyWith$InputauthProviderRequestsOrderBy<TRes> {
  _CopyWithImpl$InputauthProviderRequestsOrderBy(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsOrderBy _instance;

  final TRes Function(InputauthProviderRequestsOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? options = _undefined,
  }) =>
      _then(InputauthProviderRequestsOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (options != _undefined) 'options': (options as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsOrderBy<TRes>
    implements CopyWith$InputauthProviderRequestsOrderBy<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? id,
    EnumOrderBy? options,
  }) =>
      _res;
}

class InputauthProviderRequestsPkColumnsInput {
  factory InputauthProviderRequestsPkColumnsInput({required String id}) =>
      InputauthProviderRequestsPkColumnsInput._({
        r'id': id,
      });

  InputauthProviderRequestsPkColumnsInput._(this._$data);

  factory InputauthProviderRequestsPkColumnsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputauthProviderRequestsPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputauthProviderRequestsPkColumnsInput<
          InputauthProviderRequestsPkColumnsInput>
      get copyWith => CopyWith$InputauthProviderRequestsPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputauthProviderRequestsPkColumnsInput<TRes> {
  factory CopyWith$InputauthProviderRequestsPkColumnsInput(
    InputauthProviderRequestsPkColumnsInput instance,
    TRes Function(InputauthProviderRequestsPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsPkColumnsInput;

  factory CopyWith$InputauthProviderRequestsPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthProviderRequestsPkColumnsInput<TRes>
    implements CopyWith$InputauthProviderRequestsPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsPkColumnsInput _instance;

  final TRes Function(InputauthProviderRequestsPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthProviderRequestsPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsPkColumnsInput<TRes>
    implements CopyWith$InputauthProviderRequestsPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthProviderRequestsPrependInput {
  factory InputauthProviderRequestsPrependInput(
          {Map<String, dynamic>? options}) =>
      InputauthProviderRequestsPrependInput._({
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsPrependInput._(this._$data);

  factory InputauthProviderRequestsPrependInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as Map<String, dynamic>?);
    }
    return InputauthProviderRequestsPrependInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Map<String, dynamic>? get options =>
      (_$data['options'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsPrependInput<
          InputauthProviderRequestsPrependInput>
      get copyWith => CopyWith$InputauthProviderRequestsPrependInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsPrependInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$options = options;
    return Object.hashAll(
        [_$data.containsKey('options') ? l$options : const {}]);
  }
}

abstract class CopyWith$InputauthProviderRequestsPrependInput<TRes> {
  factory CopyWith$InputauthProviderRequestsPrependInput(
    InputauthProviderRequestsPrependInput instance,
    TRes Function(InputauthProviderRequestsPrependInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsPrependInput;

  factory CopyWith$InputauthProviderRequestsPrependInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsPrependInput;

  TRes call({Map<String, dynamic>? options});
}

class _CopyWithImpl$InputauthProviderRequestsPrependInput<TRes>
    implements CopyWith$InputauthProviderRequestsPrependInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsPrependInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsPrependInput _instance;

  final TRes Function(InputauthProviderRequestsPrependInput) _then;

  static const _undefined = {};

  TRes call({Object? options = _undefined}) =>
      _then(InputauthProviderRequestsPrependInput._({
        ..._instance._$data,
        if (options != _undefined)
          'options': (options as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsPrependInput<TRes>
    implements CopyWith$InputauthProviderRequestsPrependInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsPrependInput(this._res);

  TRes _res;

  call({Map<String, dynamic>? options}) => _res;
}

class InputauthProviderRequestsSetInput {
  factory InputauthProviderRequestsSetInput({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      InputauthProviderRequestsSetInput._({
        if (id != null) r'id': id,
        if (options != null) r'options': options,
      });

  InputauthProviderRequestsSetInput._(this._$data);

  factory InputauthProviderRequestsSetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as Map<String, dynamic>?);
    }
    return InputauthProviderRequestsSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  Map<String, dynamic>? get options =>
      (_$data['options'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequestsSetInput<InputauthProviderRequestsSetInput>
      get copyWith => CopyWith$InputauthProviderRequestsSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('options') ? l$options : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsSetInput<TRes> {
  factory CopyWith$InputauthProviderRequestsSetInput(
    InputauthProviderRequestsSetInput instance,
    TRes Function(InputauthProviderRequestsSetInput) then,
  ) = _CopyWithImpl$InputauthProviderRequestsSetInput;

  factory CopyWith$InputauthProviderRequestsSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsSetInput;

  TRes call({
    String? id,
    Map<String, dynamic>? options,
  });
}

class _CopyWithImpl$InputauthProviderRequestsSetInput<TRes>
    implements CopyWith$InputauthProviderRequestsSetInput<TRes> {
  _CopyWithImpl$InputauthProviderRequestsSetInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsSetInput _instance;

  final TRes Function(InputauthProviderRequestsSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? options = _undefined,
  }) =>
      _then(InputauthProviderRequestsSetInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (options != _undefined)
          'options': (options as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequestsSetInput<TRes>
    implements CopyWith$InputauthProviderRequestsSetInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsSetInput(this._res);

  TRes _res;

  call({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      _res;
}

class InputauthProviderRequestsUpdates {
  factory InputauthProviderRequestsUpdates({
    InputauthProviderRequestsAppendInput? $_append,
    InputauthProviderRequestsDeleteAtPathInput? $_deleteAtPath,
    InputauthProviderRequestsDeleteElemInput? $_deleteElem,
    InputauthProviderRequestsDeleteKeyInput? $_deleteKey,
    InputauthProviderRequestsPrependInput? $_prepend,
    InputauthProviderRequestsSetInput? $_set,
    required InputauthProviderRequestsBoolExp where,
  }) =>
      InputauthProviderRequestsUpdates._({
        if ($_append != null) r'_append': $_append,
        if ($_deleteAtPath != null) r'_deleteAtPath': $_deleteAtPath,
        if ($_deleteElem != null) r'_deleteElem': $_deleteElem,
        if ($_deleteKey != null) r'_deleteKey': $_deleteKey,
        if ($_prepend != null) r'_prepend': $_prepend,
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthProviderRequestsUpdates._(this._$data);

  factory InputauthProviderRequestsUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_append')) {
      final l$$_append = data['_append'];
      result$data['_append'] = l$$_append == null
          ? null
          : InputauthProviderRequestsAppendInput.fromJson(
              (l$$_append as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteAtPath')) {
      final l$$_deleteAtPath = data['_deleteAtPath'];
      result$data['_deleteAtPath'] = l$$_deleteAtPath == null
          ? null
          : InputauthProviderRequestsDeleteAtPathInput.fromJson(
              (l$$_deleteAtPath as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteElem')) {
      final l$$_deleteElem = data['_deleteElem'];
      result$data['_deleteElem'] = l$$_deleteElem == null
          ? null
          : InputauthProviderRequestsDeleteElemInput.fromJson(
              (l$$_deleteElem as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteKey')) {
      final l$$_deleteKey = data['_deleteKey'];
      result$data['_deleteKey'] = l$$_deleteKey == null
          ? null
          : InputauthProviderRequestsDeleteKeyInput.fromJson(
              (l$$_deleteKey as Map<String, dynamic>));
    }
    if (data.containsKey('_prepend')) {
      final l$$_prepend = data['_prepend'];
      result$data['_prepend'] = l$$_prepend == null
          ? null
          : InputauthProviderRequestsPrependInput.fromJson(
              (l$$_prepend as Map<String, dynamic>));
    }
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthProviderRequestsSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] = InputauthProviderRequestsBoolExp.fromJson(
        (l$where as Map<String, dynamic>));
    return InputauthProviderRequestsUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthProviderRequestsAppendInput? get $_append =>
      (_$data['_append'] as InputauthProviderRequestsAppendInput?);
  InputauthProviderRequestsDeleteAtPathInput? get $_deleteAtPath =>
      (_$data['_deleteAtPath'] as InputauthProviderRequestsDeleteAtPathInput?);
  InputauthProviderRequestsDeleteElemInput? get $_deleteElem =>
      (_$data['_deleteElem'] as InputauthProviderRequestsDeleteElemInput?);
  InputauthProviderRequestsDeleteKeyInput? get $_deleteKey =>
      (_$data['_deleteKey'] as InputauthProviderRequestsDeleteKeyInput?);
  InputauthProviderRequestsPrependInput? get $_prepend =>
      (_$data['_prepend'] as InputauthProviderRequestsPrependInput?);
  InputauthProviderRequestsSetInput? get $_set =>
      (_$data['_set'] as InputauthProviderRequestsSetInput?);
  InputauthProviderRequestsBoolExp get where =>
      (_$data['where'] as InputauthProviderRequestsBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_append')) {
      final l$$_append = $_append;
      result$data['_append'] = l$$_append?.toJson();
    }
    if (_$data.containsKey('_deleteAtPath')) {
      final l$$_deleteAtPath = $_deleteAtPath;
      result$data['_deleteAtPath'] = l$$_deleteAtPath?.toJson();
    }
    if (_$data.containsKey('_deleteElem')) {
      final l$$_deleteElem = $_deleteElem;
      result$data['_deleteElem'] = l$$_deleteElem?.toJson();
    }
    if (_$data.containsKey('_deleteKey')) {
      final l$$_deleteKey = $_deleteKey;
      result$data['_deleteKey'] = l$$_deleteKey?.toJson();
    }
    if (_$data.containsKey('_prepend')) {
      final l$$_prepend = $_prepend;
      result$data['_prepend'] = l$$_prepend?.toJson();
    }
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthProviderRequestsUpdates<InputauthProviderRequestsUpdates>
      get copyWith => CopyWith$InputauthProviderRequestsUpdates(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequestsUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_append = $_append;
    final lOther$$_append = other.$_append;
    if (_$data.containsKey('_append') != other._$data.containsKey('_append')) {
      return false;
    }
    if (l$$_append != lOther$$_append) {
      return false;
    }
    final l$$_deleteAtPath = $_deleteAtPath;
    final lOther$$_deleteAtPath = other.$_deleteAtPath;
    if (_$data.containsKey('_deleteAtPath') !=
        other._$data.containsKey('_deleteAtPath')) {
      return false;
    }
    if (l$$_deleteAtPath != lOther$$_deleteAtPath) {
      return false;
    }
    final l$$_deleteElem = $_deleteElem;
    final lOther$$_deleteElem = other.$_deleteElem;
    if (_$data.containsKey('_deleteElem') !=
        other._$data.containsKey('_deleteElem')) {
      return false;
    }
    if (l$$_deleteElem != lOther$$_deleteElem) {
      return false;
    }
    final l$$_deleteKey = $_deleteKey;
    final lOther$$_deleteKey = other.$_deleteKey;
    if (_$data.containsKey('_deleteKey') !=
        other._$data.containsKey('_deleteKey')) {
      return false;
    }
    if (l$$_deleteKey != lOther$$_deleteKey) {
      return false;
    }
    final l$$_prepend = $_prepend;
    final lOther$$_prepend = other.$_prepend;
    if (_$data.containsKey('_prepend') !=
        other._$data.containsKey('_prepend')) {
      return false;
    }
    if (l$$_prepend != lOther$$_prepend) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_append = $_append;
    final l$$_deleteAtPath = $_deleteAtPath;
    final l$$_deleteElem = $_deleteElem;
    final l$$_deleteKey = $_deleteKey;
    final l$$_prepend = $_prepend;
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_append') ? l$$_append : const {},
      _$data.containsKey('_deleteAtPath') ? l$$_deleteAtPath : const {},
      _$data.containsKey('_deleteElem') ? l$$_deleteElem : const {},
      _$data.containsKey('_deleteKey') ? l$$_deleteKey : const {},
      _$data.containsKey('_prepend') ? l$$_prepend : const {},
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequestsUpdates<TRes> {
  factory CopyWith$InputauthProviderRequestsUpdates(
    InputauthProviderRequestsUpdates instance,
    TRes Function(InputauthProviderRequestsUpdates) then,
  ) = _CopyWithImpl$InputauthProviderRequestsUpdates;

  factory CopyWith$InputauthProviderRequestsUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequestsUpdates;

  TRes call({
    InputauthProviderRequestsAppendInput? $_append,
    InputauthProviderRequestsDeleteAtPathInput? $_deleteAtPath,
    InputauthProviderRequestsDeleteElemInput? $_deleteElem,
    InputauthProviderRequestsDeleteKeyInput? $_deleteKey,
    InputauthProviderRequestsPrependInput? $_prepend,
    InputauthProviderRequestsSetInput? $_set,
    InputauthProviderRequestsBoolExp? where,
  });
  CopyWith$InputauthProviderRequestsAppendInput<TRes> get $_append;
  CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes> get $_deleteAtPath;
  CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> get $_deleteElem;
  CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> get $_deleteKey;
  CopyWith$InputauthProviderRequestsPrependInput<TRes> get $_prepend;
  CopyWith$InputauthProviderRequestsSetInput<TRes> get $_set;
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthProviderRequestsUpdates<TRes>
    implements CopyWith$InputauthProviderRequestsUpdates<TRes> {
  _CopyWithImpl$InputauthProviderRequestsUpdates(
    this._instance,
    this._then,
  );

  final InputauthProviderRequestsUpdates _instance;

  final TRes Function(InputauthProviderRequestsUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_append = _undefined,
    Object? $_deleteAtPath = _undefined,
    Object? $_deleteElem = _undefined,
    Object? $_deleteKey = _undefined,
    Object? $_prepend = _undefined,
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthProviderRequestsUpdates._({
        ..._instance._$data,
        if ($_append != _undefined)
          '_append': ($_append as InputauthProviderRequestsAppendInput?),
        if ($_deleteAtPath != _undefined)
          '_deleteAtPath':
              ($_deleteAtPath as InputauthProviderRequestsDeleteAtPathInput?),
        if ($_deleteElem != _undefined)
          '_deleteElem':
              ($_deleteElem as InputauthProviderRequestsDeleteElemInput?),
        if ($_deleteKey != _undefined)
          '_deleteKey':
              ($_deleteKey as InputauthProviderRequestsDeleteKeyInput?),
        if ($_prepend != _undefined)
          '_prepend': ($_prepend as InputauthProviderRequestsPrependInput?),
        if ($_set != _undefined)
          '_set': ($_set as InputauthProviderRequestsSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthProviderRequestsBoolExp),
      }));
  CopyWith$InputauthProviderRequestsAppendInput<TRes> get $_append {
    final local$$_append = _instance.$_append;
    return local$$_append == null
        ? CopyWith$InputauthProviderRequestsAppendInput.stub(_then(_instance))
        : CopyWith$InputauthProviderRequestsAppendInput(
            local$$_append, (e) => call($_append: e));
  }

  CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes> get $_deleteAtPath {
    final local$$_deleteAtPath = _instance.$_deleteAtPath;
    return local$$_deleteAtPath == null
        ? CopyWith$InputauthProviderRequestsDeleteAtPathInput.stub(
            _then(_instance))
        : CopyWith$InputauthProviderRequestsDeleteAtPathInput(
            local$$_deleteAtPath, (e) => call($_deleteAtPath: e));
  }

  CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> get $_deleteElem {
    final local$$_deleteElem = _instance.$_deleteElem;
    return local$$_deleteElem == null
        ? CopyWith$InputauthProviderRequestsDeleteElemInput.stub(
            _then(_instance))
        : CopyWith$InputauthProviderRequestsDeleteElemInput(
            local$$_deleteElem, (e) => call($_deleteElem: e));
  }

  CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> get $_deleteKey {
    final local$$_deleteKey = _instance.$_deleteKey;
    return local$$_deleteKey == null
        ? CopyWith$InputauthProviderRequestsDeleteKeyInput.stub(
            _then(_instance))
        : CopyWith$InputauthProviderRequestsDeleteKeyInput(
            local$$_deleteKey, (e) => call($_deleteKey: e));
  }

  CopyWith$InputauthProviderRequestsPrependInput<TRes> get $_prepend {
    final local$$_prepend = _instance.$_prepend;
    return local$$_prepend == null
        ? CopyWith$InputauthProviderRequestsPrependInput.stub(_then(_instance))
        : CopyWith$InputauthProviderRequestsPrependInput(
            local$$_prepend, (e) => call($_prepend: e));
  }

  CopyWith$InputauthProviderRequestsSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthProviderRequestsSetInput.stub(_then(_instance))
        : CopyWith$InputauthProviderRequestsSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthProviderRequestsBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthProviderRequestsUpdates<TRes>
    implements CopyWith$InputauthProviderRequestsUpdates<TRes> {
  _CopyWithStubImpl$InputauthProviderRequestsUpdates(this._res);

  TRes _res;

  call({
    InputauthProviderRequestsAppendInput? $_append,
    InputauthProviderRequestsDeleteAtPathInput? $_deleteAtPath,
    InputauthProviderRequestsDeleteElemInput? $_deleteElem,
    InputauthProviderRequestsDeleteKeyInput? $_deleteKey,
    InputauthProviderRequestsPrependInput? $_prepend,
    InputauthProviderRequestsSetInput? $_set,
    InputauthProviderRequestsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthProviderRequestsAppendInput<TRes> get $_append =>
      CopyWith$InputauthProviderRequestsAppendInput.stub(_res);
  CopyWith$InputauthProviderRequestsDeleteAtPathInput<TRes>
      get $_deleteAtPath =>
          CopyWith$InputauthProviderRequestsDeleteAtPathInput.stub(_res);
  CopyWith$InputauthProviderRequestsDeleteElemInput<TRes> get $_deleteElem =>
      CopyWith$InputauthProviderRequestsDeleteElemInput.stub(_res);
  CopyWith$InputauthProviderRequestsDeleteKeyInput<TRes> get $_deleteKey =>
      CopyWith$InputauthProviderRequestsDeleteKeyInput.stub(_res);
  CopyWith$InputauthProviderRequestsPrependInput<TRes> get $_prepend =>
      CopyWith$InputauthProviderRequestsPrependInput.stub(_res);
  CopyWith$InputauthProviderRequestsSetInput<TRes> get $_set =>
      CopyWith$InputauthProviderRequestsSetInput.stub(_res);
  CopyWith$InputauthProviderRequestsBoolExp<TRes> get where =>
      CopyWith$InputauthProviderRequestsBoolExp.stub(_res);
}

class InputauthProviderRequests_streamCursorInput {
  factory InputauthProviderRequests_streamCursorInput({
    required InputauthProviderRequests_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthProviderRequests_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthProviderRequests_streamCursorInput._(this._$data);

  factory InputauthProviderRequests_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthProviderRequests_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthProviderRequests_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthProviderRequests_streamCursorValueInput get initialValue =>
      (_$data['initialValue']
          as InputauthProviderRequests_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequests_streamCursorInput<
          InputauthProviderRequests_streamCursorInput>
      get copyWith => CopyWith$InputauthProviderRequests_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequests_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequests_streamCursorInput<TRes> {
  factory CopyWith$InputauthProviderRequests_streamCursorInput(
    InputauthProviderRequests_streamCursorInput instance,
    TRes Function(InputauthProviderRequests_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthProviderRequests_streamCursorInput;

  factory CopyWith$InputauthProviderRequests_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviderRequests_streamCursorInput;

  TRes call({
    InputauthProviderRequests_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes>
      get initialValue;
}

class _CopyWithImpl$InputauthProviderRequests_streamCursorInput<TRes>
    implements CopyWith$InputauthProviderRequests_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthProviderRequests_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequests_streamCursorInput _instance;

  final TRes Function(InputauthProviderRequests_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthProviderRequests_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue': (initialValue
              as InputauthProviderRequests_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes>
      get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthProviderRequests_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthProviderRequests_streamCursorInput<TRes>
    implements CopyWith$InputauthProviderRequests_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequests_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthProviderRequests_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes>
      get initialValue =>
          CopyWith$InputauthProviderRequests_streamCursorValueInput.stub(_res);
}

class InputauthProviderRequests_streamCursorValueInput {
  factory InputauthProviderRequests_streamCursorValueInput({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      InputauthProviderRequests_streamCursorValueInput._({
        if (id != null) r'id': id,
        if (options != null) r'options': options,
      });

  InputauthProviderRequests_streamCursorValueInput._(this._$data);

  factory InputauthProviderRequests_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('options')) {
      final l$options = data['options'];
      result$data['options'] = (l$options as Map<String, dynamic>?);
    }
    return InputauthProviderRequests_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  Map<String, dynamic>? get options =>
      (_$data['options'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('options')) {
      final l$options = options;
      result$data['options'] = l$options;
    }
    return result$data;
  }

  CopyWith$InputauthProviderRequests_streamCursorValueInput<
          InputauthProviderRequests_streamCursorValueInput>
      get copyWith => CopyWith$InputauthProviderRequests_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviderRequests_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$options = options;
    final lOther$options = other.options;
    if (_$data.containsKey('options') != other._$data.containsKey('options')) {
      return false;
    }
    if (l$options != lOther$options) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$options = options;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('options') ? l$options : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthProviderRequests_streamCursorValueInput(
    InputauthProviderRequests_streamCursorValueInput instance,
    TRes Function(InputauthProviderRequests_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthProviderRequests_streamCursorValueInput;

  factory CopyWith$InputauthProviderRequests_streamCursorValueInput.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthProviderRequests_streamCursorValueInput;

  TRes call({
    String? id,
    Map<String, dynamic>? options,
  });
}

class _CopyWithImpl$InputauthProviderRequests_streamCursorValueInput<TRes>
    implements CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthProviderRequests_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthProviderRequests_streamCursorValueInput _instance;

  final TRes Function(InputauthProviderRequests_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? options = _undefined,
  }) =>
      _then(InputauthProviderRequests_streamCursorValueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (options != _undefined)
          'options': (options as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputauthProviderRequests_streamCursorValueInput<TRes>
    implements CopyWith$InputauthProviderRequests_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthProviderRequests_streamCursorValueInput(this._res);

  TRes _res;

  call({
    String? id,
    Map<String, dynamic>? options,
  }) =>
      _res;
}

class InputauthProvidersBoolExp {
  factory InputauthProvidersBoolExp({
    List<InputauthProvidersBoolExp>? $_and,
    InputauthProvidersBoolExp? $_not,
    List<InputauthProvidersBoolExp>? $_or,
    InputStringComparisonExp? id,
    InputauthUserProvidersBoolExp? userProviders,
  }) =>
      InputauthProvidersBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (id != null) r'id': id,
        if (userProviders != null) r'userProviders': userProviders,
      });

  InputauthProvidersBoolExp._(this._$data);

  factory InputauthProvidersBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              InputauthProvidersBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthProvidersBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              InputauthProvidersBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputStringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('userProviders')) {
      final l$userProviders = data['userProviders'];
      result$data['userProviders'] = l$userProviders == null
          ? null
          : InputauthUserProvidersBoolExp.fromJson(
              (l$userProviders as Map<String, dynamic>));
    }
    return InputauthProvidersBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthProvidersBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthProvidersBoolExp>?);
  InputauthProvidersBoolExp? get $_not =>
      (_$data['_not'] as InputauthProvidersBoolExp?);
  List<InputauthProvidersBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthProvidersBoolExp>?);
  InputStringComparisonExp? get id =>
      (_$data['id'] as InputStringComparisonExp?);
  InputauthUserProvidersBoolExp? get userProviders =>
      (_$data['userProviders'] as InputauthUserProvidersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('userProviders')) {
      final l$userProviders = userProviders;
      result$data['userProviders'] = l$userProviders?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProvidersBoolExp<InputauthProvidersBoolExp> get copyWith =>
      CopyWith$InputauthProvidersBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userProviders = userProviders;
    final lOther$userProviders = other.userProviders;
    if (_$data.containsKey('userProviders') !=
        other._$data.containsKey('userProviders')) {
      return false;
    }
    if (l$userProviders != lOther$userProviders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$id = id;
    final l$userProviders = userProviders;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userProviders') ? l$userProviders : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProvidersBoolExp<TRes> {
  factory CopyWith$InputauthProvidersBoolExp(
    InputauthProvidersBoolExp instance,
    TRes Function(InputauthProvidersBoolExp) then,
  ) = _CopyWithImpl$InputauthProvidersBoolExp;

  factory CopyWith$InputauthProvidersBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersBoolExp;

  TRes call({
    List<InputauthProvidersBoolExp>? $_and,
    InputauthProvidersBoolExp? $_not,
    List<InputauthProvidersBoolExp>? $_or,
    InputStringComparisonExp? id,
    InputauthUserProvidersBoolExp? userProviders,
  });
  TRes $_and(
      Iterable<InputauthProvidersBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthProvidersBoolExp<
                      InputauthProvidersBoolExp>>?)
          _fn);
  CopyWith$InputauthProvidersBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthProvidersBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthProvidersBoolExp<
                      InputauthProvidersBoolExp>>?)
          _fn);
  CopyWith$InputStringComparisonExp<TRes> get id;
  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders;
}

class _CopyWithImpl$InputauthProvidersBoolExp<TRes>
    implements CopyWith$InputauthProvidersBoolExp<TRes> {
  _CopyWithImpl$InputauthProvidersBoolExp(
    this._instance,
    this._then,
  );

  final InputauthProvidersBoolExp _instance;

  final TRes Function(InputauthProvidersBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? id = _undefined,
    Object? userProviders = _undefined,
  }) =>
      _then(InputauthProvidersBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthProvidersBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputauthProvidersBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthProvidersBoolExp>?),
        if (id != _undefined) 'id': (id as InputStringComparisonExp?),
        if (userProviders != _undefined)
          'userProviders': (userProviders as InputauthUserProvidersBoolExp?),
      }));
  TRes $_and(
          Iterable<InputauthProvidersBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthProvidersBoolExp<
                          InputauthProvidersBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(
              _instance.$_and?.map((e) => CopyWith$InputauthProvidersBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthProvidersBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthProvidersBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthProvidersBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthProvidersBoolExp<
                          InputauthProvidersBoolExp>>?)
              _fn) =>
      call(
          $_or:
              _fn(_instance.$_or?.map((e) => CopyWith$InputauthProvidersBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputStringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders {
    final local$userProviders = _instance.userProviders;
    return local$userProviders == null
        ? CopyWith$InputauthUserProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersBoolExp(
            local$userProviders, (e) => call(userProviders: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersBoolExp<TRes>
    implements CopyWith$InputauthProvidersBoolExp<TRes> {
  _CopyWithStubImpl$InputauthProvidersBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthProvidersBoolExp>? $_and,
    InputauthProvidersBoolExp? $_not,
    List<InputauthProvidersBoolExp>? $_or,
    InputStringComparisonExp? id,
    InputauthUserProvidersBoolExp? userProviders,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthProvidersBoolExp<TRes> get $_not =>
      CopyWith$InputauthProvidersBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputStringComparisonExp<TRes> get id =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders =>
      CopyWith$InputauthUserProvidersBoolExp.stub(_res);
}

class InputauthProvidersInsertInput {
  factory InputauthProvidersInsertInput({
    String? id,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  }) =>
      InputauthProvidersInsertInput._({
        if (id != null) r'id': id,
        if (userProviders != null) r'userProviders': userProviders,
      });

  InputauthProvidersInsertInput._(this._$data);

  factory InputauthProvidersInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('userProviders')) {
      final l$userProviders = data['userProviders'];
      result$data['userProviders'] = l$userProviders == null
          ? null
          : InputauthUserProvidersArrRelInsertInput.fromJson(
              (l$userProviders as Map<String, dynamic>));
    }
    return InputauthProvidersInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  InputauthUserProvidersArrRelInsertInput? get userProviders =>
      (_$data['userProviders'] as InputauthUserProvidersArrRelInsertInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('userProviders')) {
      final l$userProviders = userProviders;
      result$data['userProviders'] = l$userProviders?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProvidersInsertInput<InputauthProvidersInsertInput>
      get copyWith => CopyWith$InputauthProvidersInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userProviders = userProviders;
    final lOther$userProviders = other.userProviders;
    if (_$data.containsKey('userProviders') !=
        other._$data.containsKey('userProviders')) {
      return false;
    }
    if (l$userProviders != lOther$userProviders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userProviders = userProviders;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userProviders') ? l$userProviders : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProvidersInsertInput<TRes> {
  factory CopyWith$InputauthProvidersInsertInput(
    InputauthProvidersInsertInput instance,
    TRes Function(InputauthProvidersInsertInput) then,
  ) = _CopyWithImpl$InputauthProvidersInsertInput;

  factory CopyWith$InputauthProvidersInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersInsertInput;

  TRes call({
    String? id,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  });
  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders;
}

class _CopyWithImpl$InputauthProvidersInsertInput<TRes>
    implements CopyWith$InputauthProvidersInsertInput<TRes> {
  _CopyWithImpl$InputauthProvidersInsertInput(
    this._instance,
    this._then,
  );

  final InputauthProvidersInsertInput _instance;

  final TRes Function(InputauthProvidersInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? userProviders = _undefined,
  }) =>
      _then(InputauthProvidersInsertInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (userProviders != _undefined)
          'userProviders':
              (userProviders as InputauthUserProvidersArrRelInsertInput?),
      }));
  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders {
    final local$userProviders = _instance.userProviders;
    return local$userProviders == null
        ? CopyWith$InputauthUserProvidersArrRelInsertInput.stub(
            _then(_instance))
        : CopyWith$InputauthUserProvidersArrRelInsertInput(
            local$userProviders, (e) => call(userProviders: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersInsertInput<TRes>
    implements CopyWith$InputauthProvidersInsertInput<TRes> {
  _CopyWithStubImpl$InputauthProvidersInsertInput(this._res);

  TRes _res;

  call({
    String? id,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  }) =>
      _res;
  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders =>
      CopyWith$InputauthUserProvidersArrRelInsertInput.stub(_res);
}

class InputauthProvidersObjRelInsertInput {
  factory InputauthProvidersObjRelInsertInput({
    required InputauthProvidersInsertInput data,
    InputauthProvidersOnConflict? onConflict,
  }) =>
      InputauthProvidersObjRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthProvidersObjRelInsertInput._(this._$data);

  factory InputauthProvidersObjRelInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = InputauthProvidersInsertInput.fromJson(
        (l$data as Map<String, dynamic>));
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthProvidersOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthProvidersObjRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthProvidersInsertInput get data =>
      (_$data['data'] as InputauthProvidersInsertInput);
  InputauthProvidersOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthProvidersOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProvidersObjRelInsertInput<
          InputauthProvidersObjRelInsertInput>
      get copyWith => CopyWith$InputauthProvidersObjRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersObjRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      l$data,
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProvidersObjRelInsertInput<TRes> {
  factory CopyWith$InputauthProvidersObjRelInsertInput(
    InputauthProvidersObjRelInsertInput instance,
    TRes Function(InputauthProvidersObjRelInsertInput) then,
  ) = _CopyWithImpl$InputauthProvidersObjRelInsertInput;

  factory CopyWith$InputauthProvidersObjRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersObjRelInsertInput;

  TRes call({
    InputauthProvidersInsertInput? data,
    InputauthProvidersOnConflict? onConflict,
  });
  CopyWith$InputauthProvidersInsertInput<TRes> get data;
  CopyWith$InputauthProvidersOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthProvidersObjRelInsertInput<TRes>
    implements CopyWith$InputauthProvidersObjRelInsertInput<TRes> {
  _CopyWithImpl$InputauthProvidersObjRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthProvidersObjRelInsertInput _instance;

  final TRes Function(InputauthProvidersObjRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthProvidersObjRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as InputauthProvidersInsertInput),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthProvidersOnConflict?),
      }));
  CopyWith$InputauthProvidersInsertInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$InputauthProvidersInsertInput(
        local$data, (e) => call(data: e));
  }

  CopyWith$InputauthProvidersOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthProvidersOnConflict.stub(_then(_instance))
        : CopyWith$InputauthProvidersOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersObjRelInsertInput<TRes>
    implements CopyWith$InputauthProvidersObjRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthProvidersObjRelInsertInput(this._res);

  TRes _res;

  call({
    InputauthProvidersInsertInput? data,
    InputauthProvidersOnConflict? onConflict,
  }) =>
      _res;
  CopyWith$InputauthProvidersInsertInput<TRes> get data =>
      CopyWith$InputauthProvidersInsertInput.stub(_res);
  CopyWith$InputauthProvidersOnConflict<TRes> get onConflict =>
      CopyWith$InputauthProvidersOnConflict.stub(_res);
}

class InputauthProvidersOnConflict {
  factory InputauthProvidersOnConflict({
    required EnumauthProvidersConstraint constraint,
    required List<EnumauthProvidersUpdateColumn> update_columns,
    InputauthProvidersBoolExp? where,
  }) =>
      InputauthProvidersOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthProvidersOnConflict._(this._$data);

  factory InputauthProvidersOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthProvidersConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumauthProvidersUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthProvidersBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthProvidersOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthProvidersConstraint get constraint =>
      (_$data['constraint'] as EnumauthProvidersConstraint);
  List<EnumauthProvidersUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthProvidersUpdateColumn>);
  InputauthProvidersBoolExp? get where =>
      (_$data['where'] as InputauthProvidersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthProvidersConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthProvidersUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProvidersOnConflict<InputauthProvidersOnConflict>
      get copyWith => CopyWith$InputauthProvidersOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProvidersOnConflict<TRes> {
  factory CopyWith$InputauthProvidersOnConflict(
    InputauthProvidersOnConflict instance,
    TRes Function(InputauthProvidersOnConflict) then,
  ) = _CopyWithImpl$InputauthProvidersOnConflict;

  factory CopyWith$InputauthProvidersOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersOnConflict;

  TRes call({
    EnumauthProvidersConstraint? constraint,
    List<EnumauthProvidersUpdateColumn>? update_columns,
    InputauthProvidersBoolExp? where,
  });
  CopyWith$InputauthProvidersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthProvidersOnConflict<TRes>
    implements CopyWith$InputauthProvidersOnConflict<TRes> {
  _CopyWithImpl$InputauthProvidersOnConflict(
    this._instance,
    this._then,
  );

  final InputauthProvidersOnConflict _instance;

  final TRes Function(InputauthProvidersOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthProvidersOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthProvidersConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthProvidersUpdateColumn>),
        if (where != _undefined) 'where': (where as InputauthProvidersBoolExp?),
      }));
  CopyWith$InputauthProvidersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthProvidersBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersOnConflict<TRes>
    implements CopyWith$InputauthProvidersOnConflict<TRes> {
  _CopyWithStubImpl$InputauthProvidersOnConflict(this._res);

  TRes _res;

  call({
    EnumauthProvidersConstraint? constraint,
    List<EnumauthProvidersUpdateColumn>? update_columns,
    InputauthProvidersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthProvidersBoolExp<TRes> get where =>
      CopyWith$InputauthProvidersBoolExp.stub(_res);
}

class InputauthProvidersOrderBy {
  factory InputauthProvidersOrderBy({
    EnumOrderBy? id,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  }) =>
      InputauthProvidersOrderBy._({
        if (id != null) r'id': id,
        if (userProvidersAggregate != null)
          r'userProvidersAggregate': userProvidersAggregate,
      });

  InputauthProvidersOrderBy._(this._$data);

  factory InputauthProvidersOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('userProvidersAggregate')) {
      final l$userProvidersAggregate = data['userProvidersAggregate'];
      result$data['userProvidersAggregate'] = l$userProvidersAggregate == null
          ? null
          : InputauthUserProvidersAggregateOrderBy.fromJson(
              (l$userProvidersAggregate as Map<String, dynamic>));
    }
    return InputauthProvidersOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  InputauthUserProvidersAggregateOrderBy? get userProvidersAggregate =>
      (_$data['userProvidersAggregate']
          as InputauthUserProvidersAggregateOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('userProvidersAggregate')) {
      final l$userProvidersAggregate = userProvidersAggregate;
      result$data['userProvidersAggregate'] =
          l$userProvidersAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthProvidersOrderBy<InputauthProvidersOrderBy> get copyWith =>
      CopyWith$InputauthProvidersOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$userProvidersAggregate = userProvidersAggregate;
    final lOther$userProvidersAggregate = other.userProvidersAggregate;
    if (_$data.containsKey('userProvidersAggregate') !=
        other._$data.containsKey('userProvidersAggregate')) {
      return false;
    }
    if (l$userProvidersAggregate != lOther$userProvidersAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$userProvidersAggregate = userProvidersAggregate;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('userProvidersAggregate')
          ? l$userProvidersAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProvidersOrderBy<TRes> {
  factory CopyWith$InputauthProvidersOrderBy(
    InputauthProvidersOrderBy instance,
    TRes Function(InputauthProvidersOrderBy) then,
  ) = _CopyWithImpl$InputauthProvidersOrderBy;

  factory CopyWith$InputauthProvidersOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersOrderBy;

  TRes call({
    EnumOrderBy? id,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  });
  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate;
}

class _CopyWithImpl$InputauthProvidersOrderBy<TRes>
    implements CopyWith$InputauthProvidersOrderBy<TRes> {
  _CopyWithImpl$InputauthProvidersOrderBy(
    this._instance,
    this._then,
  );

  final InputauthProvidersOrderBy _instance;

  final TRes Function(InputauthProvidersOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? id = _undefined,
    Object? userProvidersAggregate = _undefined,
  }) =>
      _then(InputauthProvidersOrderBy._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (userProvidersAggregate != _undefined)
          'userProvidersAggregate': (userProvidersAggregate
              as InputauthUserProvidersAggregateOrderBy?),
      }));
  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate {
    final local$userProvidersAggregate = _instance.userProvidersAggregate;
    return local$userProvidersAggregate == null
        ? CopyWith$InputauthUserProvidersAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersAggregateOrderBy(
            local$userProvidersAggregate,
            (e) => call(userProvidersAggregate: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersOrderBy<TRes>
    implements CopyWith$InputauthProvidersOrderBy<TRes> {
  _CopyWithStubImpl$InputauthProvidersOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? id,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  }) =>
      _res;
  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate =>
          CopyWith$InputauthUserProvidersAggregateOrderBy.stub(_res);
}

class InputauthProvidersPkColumnsInput {
  factory InputauthProvidersPkColumnsInput({required String id}) =>
      InputauthProvidersPkColumnsInput._({
        r'id': id,
      });

  InputauthProvidersPkColumnsInput._(this._$data);

  factory InputauthProvidersPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputauthProvidersPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputauthProvidersPkColumnsInput<InputauthProvidersPkColumnsInput>
      get copyWith => CopyWith$InputauthProvidersPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputauthProvidersPkColumnsInput<TRes> {
  factory CopyWith$InputauthProvidersPkColumnsInput(
    InputauthProvidersPkColumnsInput instance,
    TRes Function(InputauthProvidersPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthProvidersPkColumnsInput;

  factory CopyWith$InputauthProvidersPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthProvidersPkColumnsInput<TRes>
    implements CopyWith$InputauthProvidersPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthProvidersPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthProvidersPkColumnsInput _instance;

  final TRes Function(InputauthProvidersPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthProvidersPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputauthProvidersPkColumnsInput<TRes>
    implements CopyWith$InputauthProvidersPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthProvidersPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthProvidersSetInput {
  factory InputauthProvidersSetInput({String? id}) =>
      InputauthProvidersSetInput._({
        if (id != null) r'id': id,
      });

  InputauthProvidersSetInput._(this._$data);

  factory InputauthProvidersSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    return InputauthProvidersSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$InputauthProvidersSetInput<InputauthProvidersSetInput>
      get copyWith => CopyWith$InputauthProvidersSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$InputauthProvidersSetInput<TRes> {
  factory CopyWith$InputauthProvidersSetInput(
    InputauthProvidersSetInput instance,
    TRes Function(InputauthProvidersSetInput) then,
  ) = _CopyWithImpl$InputauthProvidersSetInput;

  factory CopyWith$InputauthProvidersSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersSetInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthProvidersSetInput<TRes>
    implements CopyWith$InputauthProvidersSetInput<TRes> {
  _CopyWithImpl$InputauthProvidersSetInput(
    this._instance,
    this._then,
  );

  final InputauthProvidersSetInput _instance;

  final TRes Function(InputauthProvidersSetInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) => _then(InputauthProvidersSetInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
      }));
}

class _CopyWithStubImpl$InputauthProvidersSetInput<TRes>
    implements CopyWith$InputauthProvidersSetInput<TRes> {
  _CopyWithStubImpl$InputauthProvidersSetInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthProvidersUpdates {
  factory InputauthProvidersUpdates({
    InputauthProvidersSetInput? $_set,
    required InputauthProvidersBoolExp where,
  }) =>
      InputauthProvidersUpdates._({
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthProvidersUpdates._(this._$data);

  factory InputauthProvidersUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthProvidersSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputauthProvidersBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputauthProvidersUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthProvidersSetInput? get $_set =>
      (_$data['_set'] as InputauthProvidersSetInput?);
  InputauthProvidersBoolExp get where =>
      (_$data['where'] as InputauthProvidersBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthProvidersUpdates<InputauthProvidersUpdates> get copyWith =>
      CopyWith$InputauthProvidersUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProvidersUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthProvidersUpdates<TRes> {
  factory CopyWith$InputauthProvidersUpdates(
    InputauthProvidersUpdates instance,
    TRes Function(InputauthProvidersUpdates) then,
  ) = _CopyWithImpl$InputauthProvidersUpdates;

  factory CopyWith$InputauthProvidersUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthProvidersUpdates;

  TRes call({
    InputauthProvidersSetInput? $_set,
    InputauthProvidersBoolExp? where,
  });
  CopyWith$InputauthProvidersSetInput<TRes> get $_set;
  CopyWith$InputauthProvidersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthProvidersUpdates<TRes>
    implements CopyWith$InputauthProvidersUpdates<TRes> {
  _CopyWithImpl$InputauthProvidersUpdates(
    this._instance,
    this._then,
  );

  final InputauthProvidersUpdates _instance;

  final TRes Function(InputauthProvidersUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthProvidersUpdates._({
        ..._instance._$data,
        if ($_set != _undefined) '_set': ($_set as InputauthProvidersSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthProvidersBoolExp),
      }));
  CopyWith$InputauthProvidersSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthProvidersSetInput.stub(_then(_instance))
        : CopyWith$InputauthProvidersSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthProvidersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthProvidersBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthProvidersUpdates<TRes>
    implements CopyWith$InputauthProvidersUpdates<TRes> {
  _CopyWithStubImpl$InputauthProvidersUpdates(this._res);

  TRes _res;

  call({
    InputauthProvidersSetInput? $_set,
    InputauthProvidersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthProvidersSetInput<TRes> get $_set =>
      CopyWith$InputauthProvidersSetInput.stub(_res);
  CopyWith$InputauthProvidersBoolExp<TRes> get where =>
      CopyWith$InputauthProvidersBoolExp.stub(_res);
}

class InputauthProviders_streamCursorInput {
  factory InputauthProviders_streamCursorInput({
    required InputauthProviders_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthProviders_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthProviders_streamCursorInput._(this._$data);

  factory InputauthProviders_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthProviders_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthProviders_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthProviders_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as InputauthProviders_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthProviders_streamCursorInput<
          InputauthProviders_streamCursorInput>
      get copyWith => CopyWith$InputauthProviders_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviders_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthProviders_streamCursorInput<TRes> {
  factory CopyWith$InputauthProviders_streamCursorInput(
    InputauthProviders_streamCursorInput instance,
    TRes Function(InputauthProviders_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthProviders_streamCursorInput;

  factory CopyWith$InputauthProviders_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviders_streamCursorInput;

  TRes call({
    InputauthProviders_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthProviders_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$InputauthProviders_streamCursorInput<TRes>
    implements CopyWith$InputauthProviders_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthProviders_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthProviders_streamCursorInput _instance;

  final TRes Function(InputauthProviders_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthProviders_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue':
              (initialValue as InputauthProviders_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthProviders_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthProviders_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthProviders_streamCursorInput<TRes>
    implements CopyWith$InputauthProviders_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthProviders_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthProviders_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthProviders_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$InputauthProviders_streamCursorValueInput.stub(_res);
}

class InputauthProviders_streamCursorValueInput {
  factory InputauthProviders_streamCursorValueInput({String? id}) =>
      InputauthProviders_streamCursorValueInput._({
        if (id != null) r'id': id,
      });

  InputauthProviders_streamCursorValueInput._(this._$data);

  factory InputauthProviders_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    return InputauthProviders_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$InputauthProviders_streamCursorValueInput<
          InputauthProviders_streamCursorValueInput>
      get copyWith => CopyWith$InputauthProviders_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthProviders_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$InputauthProviders_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthProviders_streamCursorValueInput(
    InputauthProviders_streamCursorValueInput instance,
    TRes Function(InputauthProviders_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthProviders_streamCursorValueInput;

  factory CopyWith$InputauthProviders_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthProviders_streamCursorValueInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthProviders_streamCursorValueInput<TRes>
    implements CopyWith$InputauthProviders_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthProviders_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthProviders_streamCursorValueInput _instance;

  final TRes Function(InputauthProviders_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthProviders_streamCursorValueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
      }));
}

class _CopyWithStubImpl$InputauthProviders_streamCursorValueInput<TRes>
    implements CopyWith$InputauthProviders_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthProviders_streamCursorValueInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthRefreshTokensAggregateOrderBy {
  factory InputauthRefreshTokensAggregateOrderBy({
    EnumOrderBy? count,
    InputauthRefreshTokens_max_order_by? max,
    InputauthRefreshTokens_min_order_by? min,
  }) =>
      InputauthRefreshTokensAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  InputauthRefreshTokensAggregateOrderBy._(this._$data);

  factory InputauthRefreshTokensAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : InputauthRefreshTokens_max_order_by.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : InputauthRefreshTokens_min_order_by.fromJson(
              (l$min as Map<String, dynamic>));
    }
    return InputauthRefreshTokensAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  InputauthRefreshTokens_max_order_by? get max =>
      (_$data['max'] as InputauthRefreshTokens_max_order_by?);
  InputauthRefreshTokens_min_order_by? get min =>
      (_$data['min'] as InputauthRefreshTokens_min_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensAggregateOrderBy<
          InputauthRefreshTokensAggregateOrderBy>
      get copyWith => CopyWith$InputauthRefreshTokensAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes> {
  factory CopyWith$InputauthRefreshTokensAggregateOrderBy(
    InputauthRefreshTokensAggregateOrderBy instance,
    TRes Function(InputauthRefreshTokensAggregateOrderBy) then,
  ) = _CopyWithImpl$InputauthRefreshTokensAggregateOrderBy;

  factory CopyWith$InputauthRefreshTokensAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensAggregateOrderBy;

  TRes call({
    EnumOrderBy? count,
    InputauthRefreshTokens_max_order_by? max,
    InputauthRefreshTokens_min_order_by? min,
  });
  CopyWith$InputauthRefreshTokens_max_order_by<TRes> get max;
  CopyWith$InputauthRefreshTokens_min_order_by<TRes> get min;
}

class _CopyWithImpl$InputauthRefreshTokensAggregateOrderBy<TRes>
    implements CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes> {
  _CopyWithImpl$InputauthRefreshTokensAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensAggregateOrderBy _instance;

  final TRes Function(InputauthRefreshTokensAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(InputauthRefreshTokensAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined)
          'max': (max as InputauthRefreshTokens_max_order_by?),
        if (min != _undefined)
          'min': (min as InputauthRefreshTokens_min_order_by?),
      }));
  CopyWith$InputauthRefreshTokens_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$InputauthRefreshTokens_max_order_by.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokens_max_order_by(
            local$max, (e) => call(max: e));
  }

  CopyWith$InputauthRefreshTokens_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$InputauthRefreshTokens_min_order_by.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokens_min_order_by(
            local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensAggregateOrderBy<TRes>
    implements CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensAggregateOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? count,
    InputauthRefreshTokens_max_order_by? max,
    InputauthRefreshTokens_min_order_by? min,
  }) =>
      _res;
  CopyWith$InputauthRefreshTokens_max_order_by<TRes> get max =>
      CopyWith$InputauthRefreshTokens_max_order_by.stub(_res);
  CopyWith$InputauthRefreshTokens_min_order_by<TRes> get min =>
      CopyWith$InputauthRefreshTokens_min_order_by.stub(_res);
}

class InputauthRefreshTokensArrRelInsertInput {
  factory InputauthRefreshTokensArrRelInsertInput({
    required List<InputauthRefreshTokensInsertInput> data,
    InputauthRefreshTokensOnConflict? onConflict,
  }) =>
      InputauthRefreshTokensArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthRefreshTokensArrRelInsertInput._(this._$data);

  factory InputauthRefreshTokensArrRelInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => InputauthRefreshTokensInsertInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthRefreshTokensOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthRefreshTokensArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthRefreshTokensInsertInput> get data =>
      (_$data['data'] as List<InputauthRefreshTokensInsertInput>);
  InputauthRefreshTokensOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthRefreshTokensOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensArrRelInsertInput<
          InputauthRefreshTokensArrRelInsertInput>
      get copyWith => CopyWith$InputauthRefreshTokensArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> {
  factory CopyWith$InputauthRefreshTokensArrRelInsertInput(
    InputauthRefreshTokensArrRelInsertInput instance,
    TRes Function(InputauthRefreshTokensArrRelInsertInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokensArrRelInsertInput;

  factory CopyWith$InputauthRefreshTokensArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensArrRelInsertInput;

  TRes call({
    List<InputauthRefreshTokensInsertInput>? data,
    InputauthRefreshTokensOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputauthRefreshTokensInsertInput> Function(
              Iterable<
                  CopyWith$InputauthRefreshTokensInsertInput<
                      InputauthRefreshTokensInsertInput>>)
          _fn);
  CopyWith$InputauthRefreshTokensOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthRefreshTokensArrRelInsertInput<TRes>
    implements CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokensArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensArrRelInsertInput _instance;

  final TRes Function(InputauthRefreshTokensArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthRefreshTokensArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputauthRefreshTokensInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthRefreshTokensOnConflict?),
      }));
  TRes data(
          Iterable<InputauthRefreshTokensInsertInput> Function(
                  Iterable<
                      CopyWith$InputauthRefreshTokensInsertInput<
                          InputauthRefreshTokensInsertInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$InputauthRefreshTokensInsertInput(
                    e,
                    (i) => i,
                  ))).toList());
  CopyWith$InputauthRefreshTokensOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthRefreshTokensOnConflict.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensArrRelInsertInput<TRes>
    implements CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputauthRefreshTokensInsertInput>? data,
    InputauthRefreshTokensOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputauthRefreshTokensOnConflict<TRes> get onConflict =>
      CopyWith$InputauthRefreshTokensOnConflict.stub(_res);
}

class InputauthRefreshTokensBoolExp {
  factory InputauthRefreshTokensBoolExp({
    List<InputauthRefreshTokensBoolExp>? $_and,
    InputauthRefreshTokensBoolExp? $_not,
    List<InputauthRefreshTokensBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputTimestamptzComparisonExp? expiresAt,
    InputUuidComparisonExp? refreshToken,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      InputauthRefreshTokensBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokensBoolExp._(this._$data);

  factory InputauthRefreshTokensBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputauthRefreshTokensBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthRefreshTokensBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputauthRefreshTokensBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$expiresAt as Map<String, dynamic>));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : InputUuidComparisonExp.fromJson(
              (l$refreshToken as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersBoolExp.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : InputUuidComparisonExp.fromJson((l$userId as Map<String, dynamic>));
    }
    return InputauthRefreshTokensBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthRefreshTokensBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthRefreshTokensBoolExp>?);
  InputauthRefreshTokensBoolExp? get $_not =>
      (_$data['_not'] as InputauthRefreshTokensBoolExp?);
  List<InputauthRefreshTokensBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthRefreshTokensBoolExp>?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputTimestamptzComparisonExp? get expiresAt =>
      (_$data['expiresAt'] as InputTimestamptzComparisonExp?);
  InputUuidComparisonExp? get refreshToken =>
      (_$data['refreshToken'] as InputUuidComparisonExp?);
  InputusersBoolExp? get user => (_$data['user'] as InputusersBoolExp?);
  InputUuidComparisonExp? get userId =>
      (_$data['userId'] as InputUuidComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt?.toJson();
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensBoolExp<InputauthRefreshTokensBoolExp>
      get copyWith => CopyWith$InputauthRefreshTokensBoolExp(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensBoolExp<TRes> {
  factory CopyWith$InputauthRefreshTokensBoolExp(
    InputauthRefreshTokensBoolExp instance,
    TRes Function(InputauthRefreshTokensBoolExp) then,
  ) = _CopyWithImpl$InputauthRefreshTokensBoolExp;

  factory CopyWith$InputauthRefreshTokensBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensBoolExp;

  TRes call({
    List<InputauthRefreshTokensBoolExp>? $_and,
    InputauthRefreshTokensBoolExp? $_not,
    List<InputauthRefreshTokensBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputTimestamptzComparisonExp? expiresAt,
    InputUuidComparisonExp? refreshToken,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  });
  TRes $_and(
      Iterable<InputauthRefreshTokensBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthRefreshTokensBoolExp<
                      InputauthRefreshTokensBoolExp>>?)
          _fn);
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthRefreshTokensBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthRefreshTokensBoolExp<
                      InputauthRefreshTokensBoolExp>>?)
          _fn);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputTimestamptzComparisonExp<TRes> get expiresAt;
  CopyWith$InputUuidComparisonExp<TRes> get refreshToken;
  CopyWith$InputusersBoolExp<TRes> get user;
  CopyWith$InputUuidComparisonExp<TRes> get userId;
}

class _CopyWithImpl$InputauthRefreshTokensBoolExp<TRes>
    implements CopyWith$InputauthRefreshTokensBoolExp<TRes> {
  _CopyWithImpl$InputauthRefreshTokensBoolExp(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensBoolExp _instance;

  final TRes Function(InputauthRefreshTokensBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokensBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthRefreshTokensBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as InputauthRefreshTokensBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthRefreshTokensBoolExp>?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (expiresAt != _undefined)
          'expiresAt': (expiresAt as InputTimestamptzComparisonExp?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as InputUuidComparisonExp?),
        if (user != _undefined) 'user': (user as InputusersBoolExp?),
        if (userId != _undefined) 'userId': (userId as InputUuidComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputauthRefreshTokensBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthRefreshTokensBoolExp<
                          InputauthRefreshTokensBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and
              ?.map((e) => CopyWith$InputauthRefreshTokensBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthRefreshTokensBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthRefreshTokensBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthRefreshTokensBoolExp<
                          InputauthRefreshTokensBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(
              _instance.$_or?.map((e) => CopyWith$InputauthRefreshTokensBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get expiresAt {
    final local$expiresAt = _instance.expiresAt;
    return local$expiresAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$expiresAt, (e) => call(expiresAt: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get refreshToken {
    final local$refreshToken = _instance.refreshToken;
    return local$refreshToken == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(
            local$refreshToken, (e) => call(refreshToken: e));
  }

  CopyWith$InputusersBoolExp<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$user, (e) => call(user: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$userId, (e) => call(userId: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensBoolExp<TRes>
    implements CopyWith$InputauthRefreshTokensBoolExp<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthRefreshTokensBoolExp>? $_and,
    InputauthRefreshTokensBoolExp? $_not,
    List<InputauthRefreshTokensBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputTimestamptzComparisonExp? expiresAt,
    InputUuidComparisonExp? refreshToken,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get $_not =>
      CopyWith$InputauthRefreshTokensBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get expiresAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get refreshToken =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get user =>
      CopyWith$InputusersBoolExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get userId =>
      CopyWith$InputUuidComparisonExp.stub(_res);
}

class InputauthRefreshTokensInsertInput {
  factory InputauthRefreshTokensInsertInput({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      InputauthRefreshTokensInsertInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokensInsertInput._(this._$data);

  factory InputauthRefreshTokensInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$expiresAt);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersObjRelInsertInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthRefreshTokensInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  DateTime? get expiresAt => (_$data['expiresAt'] as DateTime?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  InputusersObjRelInsertInput? get user =>
      (_$data['user'] as InputusersObjRelInsertInput?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensInsertInput<InputauthRefreshTokensInsertInput>
      get copyWith => CopyWith$InputauthRefreshTokensInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensInsertInput<TRes> {
  factory CopyWith$InputauthRefreshTokensInsertInput(
    InputauthRefreshTokensInsertInput instance,
    TRes Function(InputauthRefreshTokensInsertInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokensInsertInput;

  factory CopyWith$InputauthRefreshTokensInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensInsertInput;

  TRes call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    InputusersObjRelInsertInput? user,
    String? userId,
  });
  CopyWith$InputusersObjRelInsertInput<TRes> get user;
}

class _CopyWithImpl$InputauthRefreshTokensInsertInput<TRes>
    implements CopyWith$InputauthRefreshTokensInsertInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokensInsertInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensInsertInput _instance;

  final TRes Function(InputauthRefreshTokensInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokensInsertInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as DateTime?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (user != _undefined) 'user': (user as InputusersObjRelInsertInput?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
  CopyWith$InputusersObjRelInsertInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputusersObjRelInsertInput(
            local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensInsertInput<TRes>
    implements CopyWith$InputauthRefreshTokensInsertInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensInsertInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      _res;
  CopyWith$InputusersObjRelInsertInput<TRes> get user =>
      CopyWith$InputusersObjRelInsertInput.stub(_res);
}

class InputauthRefreshTokensOnConflict {
  factory InputauthRefreshTokensOnConflict({
    required EnumauthRefreshTokensConstraint constraint,
    required List<EnumauthRefreshTokensUpdateColumn> update_columns,
    InputauthRefreshTokensBoolExp? where,
  }) =>
      InputauthRefreshTokensOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthRefreshTokensOnConflict._(this._$data);

  factory InputauthRefreshTokensOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthRefreshTokensConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumauthRefreshTokensUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthRefreshTokensBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthRefreshTokensOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthRefreshTokensConstraint get constraint =>
      (_$data['constraint'] as EnumauthRefreshTokensConstraint);
  List<EnumauthRefreshTokensUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthRefreshTokensUpdateColumn>);
  InputauthRefreshTokensBoolExp? get where =>
      (_$data['where'] as InputauthRefreshTokensBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthRefreshTokensConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthRefreshTokensUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensOnConflict<InputauthRefreshTokensOnConflict>
      get copyWith => CopyWith$InputauthRefreshTokensOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensOnConflict<TRes> {
  factory CopyWith$InputauthRefreshTokensOnConflict(
    InputauthRefreshTokensOnConflict instance,
    TRes Function(InputauthRefreshTokensOnConflict) then,
  ) = _CopyWithImpl$InputauthRefreshTokensOnConflict;

  factory CopyWith$InputauthRefreshTokensOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensOnConflict;

  TRes call({
    EnumauthRefreshTokensConstraint? constraint,
    List<EnumauthRefreshTokensUpdateColumn>? update_columns,
    InputauthRefreshTokensBoolExp? where,
  });
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthRefreshTokensOnConflict<TRes>
    implements CopyWith$InputauthRefreshTokensOnConflict<TRes> {
  _CopyWithImpl$InputauthRefreshTokensOnConflict(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensOnConflict _instance;

  final TRes Function(InputauthRefreshTokensOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthRefreshTokensOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthRefreshTokensConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthRefreshTokensUpdateColumn>),
        if (where != _undefined)
          'where': (where as InputauthRefreshTokensBoolExp?),
      }));
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthRefreshTokensBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensOnConflict<TRes>
    implements CopyWith$InputauthRefreshTokensOnConflict<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensOnConflict(this._res);

  TRes _res;

  call({
    EnumauthRefreshTokensConstraint? constraint,
    List<EnumauthRefreshTokensUpdateColumn>? update_columns,
    InputauthRefreshTokensBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where =>
      CopyWith$InputauthRefreshTokensBoolExp.stub(_res);
}

class InputauthRefreshTokensOrderBy {
  factory InputauthRefreshTokensOrderBy({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      InputauthRefreshTokensOrderBy._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokensOrderBy._(this._$data);

  factory InputauthRefreshTokensOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$expiresAt as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersOrderBy.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthRefreshTokensOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get expiresAt => (_$data['expiresAt'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  InputusersOrderBy? get user => (_$data['user'] as InputusersOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] =
          l$expiresAt == null ? null : toJson$EnumOrderBy(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensOrderBy<InputauthRefreshTokensOrderBy>
      get copyWith => CopyWith$InputauthRefreshTokensOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensOrderBy<TRes> {
  factory CopyWith$InputauthRefreshTokensOrderBy(
    InputauthRefreshTokensOrderBy instance,
    TRes Function(InputauthRefreshTokensOrderBy) then,
  ) = _CopyWithImpl$InputauthRefreshTokensOrderBy;

  factory CopyWith$InputauthRefreshTokensOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensOrderBy;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  });
  CopyWith$InputusersOrderBy<TRes> get user;
}

class _CopyWithImpl$InputauthRefreshTokensOrderBy<TRes>
    implements CopyWith$InputauthRefreshTokensOrderBy<TRes> {
  _CopyWithImpl$InputauthRefreshTokensOrderBy(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensOrderBy _instance;

  final TRes Function(InputauthRefreshTokensOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokensOrderBy._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (user != _undefined) 'user': (user as InputusersOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
  CopyWith$InputusersOrderBy<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersOrderBy.stub(_then(_instance))
        : CopyWith$InputusersOrderBy(local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensOrderBy<TRes>
    implements CopyWith$InputauthRefreshTokensOrderBy<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      _res;
  CopyWith$InputusersOrderBy<TRes> get user =>
      CopyWith$InputusersOrderBy.stub(_res);
}

class InputauthRefreshTokensPkColumnsInput {
  factory InputauthRefreshTokensPkColumnsInput(
          {required String refreshToken}) =>
      InputauthRefreshTokensPkColumnsInput._({
        r'refreshToken': refreshToken,
      });

  InputauthRefreshTokensPkColumnsInput._(this._$data);

  factory InputauthRefreshTokensPkColumnsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$refreshToken = data['refreshToken'];
    result$data['refreshToken'] = (l$refreshToken as String);
    return InputauthRefreshTokensPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get refreshToken => (_$data['refreshToken'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$refreshToken = refreshToken;
    result$data['refreshToken'] = l$refreshToken;
    return result$data;
  }

  CopyWith$InputauthRefreshTokensPkColumnsInput<
          InputauthRefreshTokensPkColumnsInput>
      get copyWith => CopyWith$InputauthRefreshTokensPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refreshToken = refreshToken;
    return Object.hashAll([l$refreshToken]);
  }
}

abstract class CopyWith$InputauthRefreshTokensPkColumnsInput<TRes> {
  factory CopyWith$InputauthRefreshTokensPkColumnsInput(
    InputauthRefreshTokensPkColumnsInput instance,
    TRes Function(InputauthRefreshTokensPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokensPkColumnsInput;

  factory CopyWith$InputauthRefreshTokensPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensPkColumnsInput;

  TRes call({String? refreshToken});
}

class _CopyWithImpl$InputauthRefreshTokensPkColumnsInput<TRes>
    implements CopyWith$InputauthRefreshTokensPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokensPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensPkColumnsInput _instance;

  final TRes Function(InputauthRefreshTokensPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? refreshToken = _undefined}) =>
      _then(InputauthRefreshTokensPkColumnsInput._({
        ..._instance._$data,
        if (refreshToken != _undefined && refreshToken != null)
          'refreshToken': (refreshToken as String),
      }));
}

class _CopyWithStubImpl$InputauthRefreshTokensPkColumnsInput<TRes>
    implements CopyWith$InputauthRefreshTokensPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensPkColumnsInput(this._res);

  TRes _res;

  call({String? refreshToken}) => _res;
}

class InputauthRefreshTokensSetInput {
  factory InputauthRefreshTokensSetInput({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  }) =>
      InputauthRefreshTokensSetInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokensSetInput._(this._$data);

  factory InputauthRefreshTokensSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$expiresAt);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthRefreshTokensSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  DateTime? get expiresAt => (_$data['expiresAt'] as DateTime?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokensSetInput<InputauthRefreshTokensSetInput>
      get copyWith => CopyWith$InputauthRefreshTokensSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensSetInput<TRes> {
  factory CopyWith$InputauthRefreshTokensSetInput(
    InputauthRefreshTokensSetInput instance,
    TRes Function(InputauthRefreshTokensSetInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokensSetInput;

  factory CopyWith$InputauthRefreshTokensSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensSetInput;

  TRes call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  });
}

class _CopyWithImpl$InputauthRefreshTokensSetInput<TRes>
    implements CopyWith$InputauthRefreshTokensSetInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokensSetInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensSetInput _instance;

  final TRes Function(InputauthRefreshTokensSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokensSetInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as DateTime?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthRefreshTokensSetInput<TRes>
    implements CopyWith$InputauthRefreshTokensSetInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensSetInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  }) =>
      _res;
}

class InputauthRefreshTokensUpdates {
  factory InputauthRefreshTokensUpdates({
    InputauthRefreshTokensSetInput? $_set,
    required InputauthRefreshTokensBoolExp where,
  }) =>
      InputauthRefreshTokensUpdates._({
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthRefreshTokensUpdates._(this._$data);

  factory InputauthRefreshTokensUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthRefreshTokensSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] = InputauthRefreshTokensBoolExp.fromJson(
        (l$where as Map<String, dynamic>));
    return InputauthRefreshTokensUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthRefreshTokensSetInput? get $_set =>
      (_$data['_set'] as InputauthRefreshTokensSetInput?);
  InputauthRefreshTokensBoolExp get where =>
      (_$data['where'] as InputauthRefreshTokensBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthRefreshTokensUpdates<InputauthRefreshTokensUpdates>
      get copyWith => CopyWith$InputauthRefreshTokensUpdates(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokensUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokensUpdates<TRes> {
  factory CopyWith$InputauthRefreshTokensUpdates(
    InputauthRefreshTokensUpdates instance,
    TRes Function(InputauthRefreshTokensUpdates) then,
  ) = _CopyWithImpl$InputauthRefreshTokensUpdates;

  factory CopyWith$InputauthRefreshTokensUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokensUpdates;

  TRes call({
    InputauthRefreshTokensSetInput? $_set,
    InputauthRefreshTokensBoolExp? where,
  });
  CopyWith$InputauthRefreshTokensSetInput<TRes> get $_set;
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthRefreshTokensUpdates<TRes>
    implements CopyWith$InputauthRefreshTokensUpdates<TRes> {
  _CopyWithImpl$InputauthRefreshTokensUpdates(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokensUpdates _instance;

  final TRes Function(InputauthRefreshTokensUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthRefreshTokensUpdates._({
        ..._instance._$data,
        if ($_set != _undefined)
          '_set': ($_set as InputauthRefreshTokensSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthRefreshTokensBoolExp),
      }));
  CopyWith$InputauthRefreshTokensSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthRefreshTokensSetInput.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthRefreshTokensBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokensUpdates<TRes>
    implements CopyWith$InputauthRefreshTokensUpdates<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokensUpdates(this._res);

  TRes _res;

  call({
    InputauthRefreshTokensSetInput? $_set,
    InputauthRefreshTokensBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthRefreshTokensSetInput<TRes> get $_set =>
      CopyWith$InputauthRefreshTokensSetInput.stub(_res);
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get where =>
      CopyWith$InputauthRefreshTokensBoolExp.stub(_res);
}

class InputauthRefreshTokens_max_order_by {
  factory InputauthRefreshTokens_max_order_by({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  }) =>
      InputauthRefreshTokens_max_order_by._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokens_max_order_by._(this._$data);

  factory InputauthRefreshTokens_max_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$expiresAt as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthRefreshTokens_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get expiresAt => (_$data['expiresAt'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] =
          l$expiresAt == null ? null : toJson$EnumOrderBy(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokens_max_order_by<
          InputauthRefreshTokens_max_order_by>
      get copyWith => CopyWith$InputauthRefreshTokens_max_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokens_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokens_max_order_by<TRes> {
  factory CopyWith$InputauthRefreshTokens_max_order_by(
    InputauthRefreshTokens_max_order_by instance,
    TRes Function(InputauthRefreshTokens_max_order_by) then,
  ) = _CopyWithImpl$InputauthRefreshTokens_max_order_by;

  factory CopyWith$InputauthRefreshTokens_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokens_max_order_by;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthRefreshTokens_max_order_by<TRes>
    implements CopyWith$InputauthRefreshTokens_max_order_by<TRes> {
  _CopyWithImpl$InputauthRefreshTokens_max_order_by(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokens_max_order_by _instance;

  final TRes Function(InputauthRefreshTokens_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokens_max_order_by._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthRefreshTokens_max_order_by<TRes>
    implements CopyWith$InputauthRefreshTokens_max_order_by<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokens_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthRefreshTokens_min_order_by {
  factory InputauthRefreshTokens_min_order_by({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  }) =>
      InputauthRefreshTokens_min_order_by._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokens_min_order_by._(this._$data);

  factory InputauthRefreshTokens_min_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$expiresAt as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthRefreshTokens_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get expiresAt => (_$data['expiresAt'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] =
          l$expiresAt == null ? null : toJson$EnumOrderBy(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokens_min_order_by<
          InputauthRefreshTokens_min_order_by>
      get copyWith => CopyWith$InputauthRefreshTokens_min_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokens_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokens_min_order_by<TRes> {
  factory CopyWith$InputauthRefreshTokens_min_order_by(
    InputauthRefreshTokens_min_order_by instance,
    TRes Function(InputauthRefreshTokens_min_order_by) then,
  ) = _CopyWithImpl$InputauthRefreshTokens_min_order_by;

  factory CopyWith$InputauthRefreshTokens_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokens_min_order_by;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthRefreshTokens_min_order_by<TRes>
    implements CopyWith$InputauthRefreshTokens_min_order_by<TRes> {
  _CopyWithImpl$InputauthRefreshTokens_min_order_by(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokens_min_order_by _instance;

  final TRes Function(InputauthRefreshTokens_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokens_min_order_by._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthRefreshTokens_min_order_by<TRes>
    implements CopyWith$InputauthRefreshTokens_min_order_by<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokens_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? expiresAt,
    EnumOrderBy? refreshToken,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthRefreshTokens_streamCursorInput {
  factory InputauthRefreshTokens_streamCursorInput({
    required InputauthRefreshTokens_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthRefreshTokens_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthRefreshTokens_streamCursorInput._(this._$data);

  factory InputauthRefreshTokens_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthRefreshTokens_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthRefreshTokens_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthRefreshTokens_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as InputauthRefreshTokens_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokens_streamCursorInput<
          InputauthRefreshTokens_streamCursorInput>
      get copyWith => CopyWith$InputauthRefreshTokens_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokens_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokens_streamCursorInput<TRes> {
  factory CopyWith$InputauthRefreshTokens_streamCursorInput(
    InputauthRefreshTokens_streamCursorInput instance,
    TRes Function(InputauthRefreshTokens_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokens_streamCursorInput;

  factory CopyWith$InputauthRefreshTokens_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokens_streamCursorInput;

  TRes call({
    InputauthRefreshTokens_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$InputauthRefreshTokens_streamCursorInput<TRes>
    implements CopyWith$InputauthRefreshTokens_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokens_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokens_streamCursorInput _instance;

  final TRes Function(InputauthRefreshTokens_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthRefreshTokens_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue':
              (initialValue as InputauthRefreshTokens_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes>
      get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthRefreshTokens_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthRefreshTokens_streamCursorInput<TRes>
    implements CopyWith$InputauthRefreshTokens_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokens_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthRefreshTokens_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes>
      get initialValue =>
          CopyWith$InputauthRefreshTokens_streamCursorValueInput.stub(_res);
}

class InputauthRefreshTokens_streamCursorValueInput {
  factory InputauthRefreshTokens_streamCursorValueInput({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  }) =>
      InputauthRefreshTokens_streamCursorValueInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (userId != null) r'userId': userId,
      });

  InputauthRefreshTokens_streamCursorValueInput._(this._$data);

  factory InputauthRefreshTokens_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$expiresAt);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthRefreshTokens_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  DateTime? get expiresAt => (_$data['expiresAt'] as DateTime?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$expiresAt);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthRefreshTokens_streamCursorValueInput<
          InputauthRefreshTokens_streamCursorValueInput>
      get copyWith => CopyWith$InputauthRefreshTokens_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRefreshTokens_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$expiresAt = expiresAt;
    final l$refreshToken = refreshToken;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthRefreshTokens_streamCursorValueInput(
    InputauthRefreshTokens_streamCursorValueInput instance,
    TRes Function(InputauthRefreshTokens_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthRefreshTokens_streamCursorValueInput;

  factory CopyWith$InputauthRefreshTokens_streamCursorValueInput.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthRefreshTokens_streamCursorValueInput;

  TRes call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  });
}

class _CopyWithImpl$InputauthRefreshTokens_streamCursorValueInput<TRes>
    implements CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthRefreshTokens_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthRefreshTokens_streamCursorValueInput _instance;

  final TRes Function(InputauthRefreshTokens_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? expiresAt = _undefined,
    Object? refreshToken = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthRefreshTokens_streamCursorValueInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as DateTime?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthRefreshTokens_streamCursorValueInput<TRes>
    implements CopyWith$InputauthRefreshTokens_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthRefreshTokens_streamCursorValueInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    DateTime? expiresAt,
    String? refreshToken,
    String? userId,
  }) =>
      _res;
}

class InputauthRolesBoolExp {
  factory InputauthRolesBoolExp({
    List<InputauthRolesBoolExp>? $_and,
    InputauthRolesBoolExp? $_not,
    List<InputauthRolesBoolExp>? $_or,
    InputStringComparisonExp? role,
    InputauthUserRolesBoolExp? userRoles,
    InputusersBoolExp? usersByDefaultRole,
  }) =>
      InputauthRolesBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (role != null) r'role': role,
        if (userRoles != null) r'userRoles': userRoles,
        if (usersByDefaultRole != null)
          r'usersByDefaultRole': usersByDefaultRole,
      });

  InputauthRolesBoolExp._(this._$data);

  factory InputauthRolesBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              InputauthRolesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthRolesBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              InputauthRolesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : InputStringComparisonExp.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('userRoles')) {
      final l$userRoles = data['userRoles'];
      result$data['userRoles'] = l$userRoles == null
          ? null
          : InputauthUserRolesBoolExp.fromJson(
              (l$userRoles as Map<String, dynamic>));
    }
    if (data.containsKey('usersByDefaultRole')) {
      final l$usersByDefaultRole = data['usersByDefaultRole'];
      result$data['usersByDefaultRole'] = l$usersByDefaultRole == null
          ? null
          : InputusersBoolExp.fromJson(
              (l$usersByDefaultRole as Map<String, dynamic>));
    }
    return InputauthRolesBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthRolesBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthRolesBoolExp>?);
  InputauthRolesBoolExp? get $_not =>
      (_$data['_not'] as InputauthRolesBoolExp?);
  List<InputauthRolesBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthRolesBoolExp>?);
  InputStringComparisonExp? get role =>
      (_$data['role'] as InputStringComparisonExp?);
  InputauthUserRolesBoolExp? get userRoles =>
      (_$data['userRoles'] as InputauthUserRolesBoolExp?);
  InputusersBoolExp? get usersByDefaultRole =>
      (_$data['usersByDefaultRole'] as InputusersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('userRoles')) {
      final l$userRoles = userRoles;
      result$data['userRoles'] = l$userRoles?.toJson();
    }
    if (_$data.containsKey('usersByDefaultRole')) {
      final l$usersByDefaultRole = usersByDefaultRole;
      result$data['usersByDefaultRole'] = l$usersByDefaultRole?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRolesBoolExp<InputauthRolesBoolExp> get copyWith =>
      CopyWith$InputauthRolesBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userRoles = userRoles;
    final lOther$userRoles = other.userRoles;
    if (_$data.containsKey('userRoles') !=
        other._$data.containsKey('userRoles')) {
      return false;
    }
    if (l$userRoles != lOther$userRoles) {
      return false;
    }
    final l$usersByDefaultRole = usersByDefaultRole;
    final lOther$usersByDefaultRole = other.usersByDefaultRole;
    if (_$data.containsKey('usersByDefaultRole') !=
        other._$data.containsKey('usersByDefaultRole')) {
      return false;
    }
    if (l$usersByDefaultRole != lOther$usersByDefaultRole) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$role = role;
    final l$userRoles = userRoles;
    final l$usersByDefaultRole = usersByDefaultRole;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userRoles') ? l$userRoles : const {},
      _$data.containsKey('usersByDefaultRole')
          ? l$usersByDefaultRole
          : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRolesBoolExp<TRes> {
  factory CopyWith$InputauthRolesBoolExp(
    InputauthRolesBoolExp instance,
    TRes Function(InputauthRolesBoolExp) then,
  ) = _CopyWithImpl$InputauthRolesBoolExp;

  factory CopyWith$InputauthRolesBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesBoolExp;

  TRes call({
    List<InputauthRolesBoolExp>? $_and,
    InputauthRolesBoolExp? $_not,
    List<InputauthRolesBoolExp>? $_or,
    InputStringComparisonExp? role,
    InputauthUserRolesBoolExp? userRoles,
    InputusersBoolExp? usersByDefaultRole,
  });
  TRes $_and(
      Iterable<InputauthRolesBoolExp>? Function(
              Iterable<CopyWith$InputauthRolesBoolExp<InputauthRolesBoolExp>>?)
          _fn);
  CopyWith$InputauthRolesBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthRolesBoolExp>? Function(
              Iterable<CopyWith$InputauthRolesBoolExp<InputauthRolesBoolExp>>?)
          _fn);
  CopyWith$InputStringComparisonExp<TRes> get role;
  CopyWith$InputauthUserRolesBoolExp<TRes> get userRoles;
  CopyWith$InputusersBoolExp<TRes> get usersByDefaultRole;
}

class _CopyWithImpl$InputauthRolesBoolExp<TRes>
    implements CopyWith$InputauthRolesBoolExp<TRes> {
  _CopyWithImpl$InputauthRolesBoolExp(
    this._instance,
    this._then,
  );

  final InputauthRolesBoolExp _instance;

  final TRes Function(InputauthRolesBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? role = _undefined,
    Object? userRoles = _undefined,
    Object? usersByDefaultRole = _undefined,
  }) =>
      _then(InputauthRolesBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthRolesBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputauthRolesBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<InputauthRolesBoolExp>?),
        if (role != _undefined) 'role': (role as InputStringComparisonExp?),
        if (userRoles != _undefined)
          'userRoles': (userRoles as InputauthUserRolesBoolExp?),
        if (usersByDefaultRole != _undefined)
          'usersByDefaultRole': (usersByDefaultRole as InputusersBoolExp?),
      }));
  TRes $_and(
          Iterable<InputauthRolesBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthRolesBoolExp<InputauthRolesBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$InputauthRolesBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputauthRolesBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRolesBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthRolesBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthRolesBoolExp<InputauthRolesBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$InputauthRolesBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputStringComparisonExp<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$role, (e) => call(role: e));
  }

  CopyWith$InputauthUserRolesBoolExp<TRes> get userRoles {
    final local$userRoles = _instance.userRoles;
    return local$userRoles == null
        ? CopyWith$InputauthUserRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserRolesBoolExp(
            local$userRoles, (e) => call(userRoles: e));
  }

  CopyWith$InputusersBoolExp<TRes> get usersByDefaultRole {
    final local$usersByDefaultRole = _instance.usersByDefaultRole;
    return local$usersByDefaultRole == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(
            local$usersByDefaultRole, (e) => call(usersByDefaultRole: e));
  }
}

class _CopyWithStubImpl$InputauthRolesBoolExp<TRes>
    implements CopyWith$InputauthRolesBoolExp<TRes> {
  _CopyWithStubImpl$InputauthRolesBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthRolesBoolExp>? $_and,
    InputauthRolesBoolExp? $_not,
    List<InputauthRolesBoolExp>? $_or,
    InputStringComparisonExp? role,
    InputauthUserRolesBoolExp? userRoles,
    InputusersBoolExp? usersByDefaultRole,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthRolesBoolExp<TRes> get $_not =>
      CopyWith$InputauthRolesBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputStringComparisonExp<TRes> get role =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputauthUserRolesBoolExp<TRes> get userRoles =>
      CopyWith$InputauthUserRolesBoolExp.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get usersByDefaultRole =>
      CopyWith$InputusersBoolExp.stub(_res);
}

class InputauthRolesInsertInput {
  factory InputauthRolesInsertInput({
    String? role,
    InputauthUserRolesArrRelInsertInput? userRoles,
    InputusersArrRelInsertInput? usersByDefaultRole,
  }) =>
      InputauthRolesInsertInput._({
        if (role != null) r'role': role,
        if (userRoles != null) r'userRoles': userRoles,
        if (usersByDefaultRole != null)
          r'usersByDefaultRole': usersByDefaultRole,
      });

  InputauthRolesInsertInput._(this._$data);

  factory InputauthRolesInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('userRoles')) {
      final l$userRoles = data['userRoles'];
      result$data['userRoles'] = l$userRoles == null
          ? null
          : InputauthUserRolesArrRelInsertInput.fromJson(
              (l$userRoles as Map<String, dynamic>));
    }
    if (data.containsKey('usersByDefaultRole')) {
      final l$usersByDefaultRole = data['usersByDefaultRole'];
      result$data['usersByDefaultRole'] = l$usersByDefaultRole == null
          ? null
          : InputusersArrRelInsertInput.fromJson(
              (l$usersByDefaultRole as Map<String, dynamic>));
    }
    return InputauthRolesInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get role => (_$data['role'] as String?);
  InputauthUserRolesArrRelInsertInput? get userRoles =>
      (_$data['userRoles'] as InputauthUserRolesArrRelInsertInput?);
  InputusersArrRelInsertInput? get usersByDefaultRole =>
      (_$data['usersByDefaultRole'] as InputusersArrRelInsertInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('userRoles')) {
      final l$userRoles = userRoles;
      result$data['userRoles'] = l$userRoles?.toJson();
    }
    if (_$data.containsKey('usersByDefaultRole')) {
      final l$usersByDefaultRole = usersByDefaultRole;
      result$data['usersByDefaultRole'] = l$usersByDefaultRole?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRolesInsertInput<InputauthRolesInsertInput> get copyWith =>
      CopyWith$InputauthRolesInsertInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userRoles = userRoles;
    final lOther$userRoles = other.userRoles;
    if (_$data.containsKey('userRoles') !=
        other._$data.containsKey('userRoles')) {
      return false;
    }
    if (l$userRoles != lOther$userRoles) {
      return false;
    }
    final l$usersByDefaultRole = usersByDefaultRole;
    final lOther$usersByDefaultRole = other.usersByDefaultRole;
    if (_$data.containsKey('usersByDefaultRole') !=
        other._$data.containsKey('usersByDefaultRole')) {
      return false;
    }
    if (l$usersByDefaultRole != lOther$usersByDefaultRole) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$role = role;
    final l$userRoles = userRoles;
    final l$usersByDefaultRole = usersByDefaultRole;
    return Object.hashAll([
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userRoles') ? l$userRoles : const {},
      _$data.containsKey('usersByDefaultRole')
          ? l$usersByDefaultRole
          : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRolesInsertInput<TRes> {
  factory CopyWith$InputauthRolesInsertInput(
    InputauthRolesInsertInput instance,
    TRes Function(InputauthRolesInsertInput) then,
  ) = _CopyWithImpl$InputauthRolesInsertInput;

  factory CopyWith$InputauthRolesInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesInsertInput;

  TRes call({
    String? role,
    InputauthUserRolesArrRelInsertInput? userRoles,
    InputusersArrRelInsertInput? usersByDefaultRole,
  });
  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get userRoles;
  CopyWith$InputusersArrRelInsertInput<TRes> get usersByDefaultRole;
}

class _CopyWithImpl$InputauthRolesInsertInput<TRes>
    implements CopyWith$InputauthRolesInsertInput<TRes> {
  _CopyWithImpl$InputauthRolesInsertInput(
    this._instance,
    this._then,
  );

  final InputauthRolesInsertInput _instance;

  final TRes Function(InputauthRolesInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? role = _undefined,
    Object? userRoles = _undefined,
    Object? usersByDefaultRole = _undefined,
  }) =>
      _then(InputauthRolesInsertInput._({
        ..._instance._$data,
        if (role != _undefined) 'role': (role as String?),
        if (userRoles != _undefined)
          'userRoles': (userRoles as InputauthUserRolesArrRelInsertInput?),
        if (usersByDefaultRole != _undefined)
          'usersByDefaultRole':
              (usersByDefaultRole as InputusersArrRelInsertInput?),
      }));
  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get userRoles {
    final local$userRoles = _instance.userRoles;
    return local$userRoles == null
        ? CopyWith$InputauthUserRolesArrRelInsertInput.stub(_then(_instance))
        : CopyWith$InputauthUserRolesArrRelInsertInput(
            local$userRoles, (e) => call(userRoles: e));
  }

  CopyWith$InputusersArrRelInsertInput<TRes> get usersByDefaultRole {
    final local$usersByDefaultRole = _instance.usersByDefaultRole;
    return local$usersByDefaultRole == null
        ? CopyWith$InputusersArrRelInsertInput.stub(_then(_instance))
        : CopyWith$InputusersArrRelInsertInput(
            local$usersByDefaultRole, (e) => call(usersByDefaultRole: e));
  }
}

class _CopyWithStubImpl$InputauthRolesInsertInput<TRes>
    implements CopyWith$InputauthRolesInsertInput<TRes> {
  _CopyWithStubImpl$InputauthRolesInsertInput(this._res);

  TRes _res;

  call({
    String? role,
    InputauthUserRolesArrRelInsertInput? userRoles,
    InputusersArrRelInsertInput? usersByDefaultRole,
  }) =>
      _res;
  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get userRoles =>
      CopyWith$InputauthUserRolesArrRelInsertInput.stub(_res);
  CopyWith$InputusersArrRelInsertInput<TRes> get usersByDefaultRole =>
      CopyWith$InputusersArrRelInsertInput.stub(_res);
}

class InputauthRolesObjRelInsertInput {
  factory InputauthRolesObjRelInsertInput({
    required InputauthRolesInsertInput data,
    InputauthRolesOnConflict? onConflict,
  }) =>
      InputauthRolesObjRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthRolesObjRelInsertInput._(this._$data);

  factory InputauthRolesObjRelInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] =
        InputauthRolesInsertInput.fromJson((l$data as Map<String, dynamic>));
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthRolesOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthRolesObjRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthRolesInsertInput get data =>
      (_$data['data'] as InputauthRolesInsertInput);
  InputauthRolesOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthRolesOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRolesObjRelInsertInput<InputauthRolesObjRelInsertInput>
      get copyWith => CopyWith$InputauthRolesObjRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesObjRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      l$data,
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRolesObjRelInsertInput<TRes> {
  factory CopyWith$InputauthRolesObjRelInsertInput(
    InputauthRolesObjRelInsertInput instance,
    TRes Function(InputauthRolesObjRelInsertInput) then,
  ) = _CopyWithImpl$InputauthRolesObjRelInsertInput;

  factory CopyWith$InputauthRolesObjRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesObjRelInsertInput;

  TRes call({
    InputauthRolesInsertInput? data,
    InputauthRolesOnConflict? onConflict,
  });
  CopyWith$InputauthRolesInsertInput<TRes> get data;
  CopyWith$InputauthRolesOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthRolesObjRelInsertInput<TRes>
    implements CopyWith$InputauthRolesObjRelInsertInput<TRes> {
  _CopyWithImpl$InputauthRolesObjRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthRolesObjRelInsertInput _instance;

  final TRes Function(InputauthRolesObjRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthRolesObjRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as InputauthRolesInsertInput),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthRolesOnConflict?),
      }));
  CopyWith$InputauthRolesInsertInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$InputauthRolesInsertInput(local$data, (e) => call(data: e));
  }

  CopyWith$InputauthRolesOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthRolesOnConflict.stub(_then(_instance))
        : CopyWith$InputauthRolesOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthRolesObjRelInsertInput<TRes>
    implements CopyWith$InputauthRolesObjRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthRolesObjRelInsertInput(this._res);

  TRes _res;

  call({
    InputauthRolesInsertInput? data,
    InputauthRolesOnConflict? onConflict,
  }) =>
      _res;
  CopyWith$InputauthRolesInsertInput<TRes> get data =>
      CopyWith$InputauthRolesInsertInput.stub(_res);
  CopyWith$InputauthRolesOnConflict<TRes> get onConflict =>
      CopyWith$InputauthRolesOnConflict.stub(_res);
}

class InputauthRolesOnConflict {
  factory InputauthRolesOnConflict({
    required EnumauthRolesConstraint constraint,
    required List<EnumauthRolesUpdateColumn> update_columns,
    InputauthRolesBoolExp? where,
  }) =>
      InputauthRolesOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthRolesOnConflict._(this._$data);

  factory InputauthRolesOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthRolesConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumauthRolesUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthRolesBoolExp.fromJson((l$where as Map<String, dynamic>));
    }
    return InputauthRolesOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthRolesConstraint get constraint =>
      (_$data['constraint'] as EnumauthRolesConstraint);
  List<EnumauthRolesUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthRolesUpdateColumn>);
  InputauthRolesBoolExp? get where =>
      (_$data['where'] as InputauthRolesBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] = toJson$EnumauthRolesConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthRolesUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRolesOnConflict<InputauthRolesOnConflict> get copyWith =>
      CopyWith$InputauthRolesOnConflict(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRolesOnConflict<TRes> {
  factory CopyWith$InputauthRolesOnConflict(
    InputauthRolesOnConflict instance,
    TRes Function(InputauthRolesOnConflict) then,
  ) = _CopyWithImpl$InputauthRolesOnConflict;

  factory CopyWith$InputauthRolesOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesOnConflict;

  TRes call({
    EnumauthRolesConstraint? constraint,
    List<EnumauthRolesUpdateColumn>? update_columns,
    InputauthRolesBoolExp? where,
  });
  CopyWith$InputauthRolesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthRolesOnConflict<TRes>
    implements CopyWith$InputauthRolesOnConflict<TRes> {
  _CopyWithImpl$InputauthRolesOnConflict(
    this._instance,
    this._then,
  );

  final InputauthRolesOnConflict _instance;

  final TRes Function(InputauthRolesOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthRolesOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthRolesConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns': (update_columns as List<EnumauthRolesUpdateColumn>),
        if (where != _undefined) 'where': (where as InputauthRolesBoolExp?),
      }));
  CopyWith$InputauthRolesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRolesBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthRolesOnConflict<TRes>
    implements CopyWith$InputauthRolesOnConflict<TRes> {
  _CopyWithStubImpl$InputauthRolesOnConflict(this._res);

  TRes _res;

  call({
    EnumauthRolesConstraint? constraint,
    List<EnumauthRolesUpdateColumn>? update_columns,
    InputauthRolesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthRolesBoolExp<TRes> get where =>
      CopyWith$InputauthRolesBoolExp.stub(_res);
}

class InputauthRolesOrderBy {
  factory InputauthRolesOrderBy({
    EnumOrderBy? role,
    InputauthUserRolesAggregateOrderBy? userRolesAggregate,
    InputusersAggregateOrderBy? usersByDefaultRoleAggregate,
  }) =>
      InputauthRolesOrderBy._({
        if (role != null) r'role': role,
        if (userRolesAggregate != null)
          r'userRolesAggregate': userRolesAggregate,
        if (usersByDefaultRoleAggregate != null)
          r'usersByDefaultRoleAggregate': usersByDefaultRoleAggregate,
      });

  InputauthRolesOrderBy._(this._$data);

  factory InputauthRolesOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$EnumOrderBy((l$role as String));
    }
    if (data.containsKey('userRolesAggregate')) {
      final l$userRolesAggregate = data['userRolesAggregate'];
      result$data['userRolesAggregate'] = l$userRolesAggregate == null
          ? null
          : InputauthUserRolesAggregateOrderBy.fromJson(
              (l$userRolesAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('usersByDefaultRoleAggregate')) {
      final l$usersByDefaultRoleAggregate = data['usersByDefaultRoleAggregate'];
      result$data['usersByDefaultRoleAggregate'] =
          l$usersByDefaultRoleAggregate == null
              ? null
              : InputusersAggregateOrderBy.fromJson(
                  (l$usersByDefaultRoleAggregate as Map<String, dynamic>));
    }
    return InputauthRolesOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get role => (_$data['role'] as EnumOrderBy?);
  InputauthUserRolesAggregateOrderBy? get userRolesAggregate =>
      (_$data['userRolesAggregate'] as InputauthUserRolesAggregateOrderBy?);
  InputusersAggregateOrderBy? get usersByDefaultRoleAggregate =>
      (_$data['usersByDefaultRoleAggregate'] as InputusersAggregateOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null ? null : toJson$EnumOrderBy(l$role);
    }
    if (_$data.containsKey('userRolesAggregate')) {
      final l$userRolesAggregate = userRolesAggregate;
      result$data['userRolesAggregate'] = l$userRolesAggregate?.toJson();
    }
    if (_$data.containsKey('usersByDefaultRoleAggregate')) {
      final l$usersByDefaultRoleAggregate = usersByDefaultRoleAggregate;
      result$data['usersByDefaultRoleAggregate'] =
          l$usersByDefaultRoleAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthRolesOrderBy<InputauthRolesOrderBy> get copyWith =>
      CopyWith$InputauthRolesOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userRolesAggregate = userRolesAggregate;
    final lOther$userRolesAggregate = other.userRolesAggregate;
    if (_$data.containsKey('userRolesAggregate') !=
        other._$data.containsKey('userRolesAggregate')) {
      return false;
    }
    if (l$userRolesAggregate != lOther$userRolesAggregate) {
      return false;
    }
    final l$usersByDefaultRoleAggregate = usersByDefaultRoleAggregate;
    final lOther$usersByDefaultRoleAggregate =
        other.usersByDefaultRoleAggregate;
    if (_$data.containsKey('usersByDefaultRoleAggregate') !=
        other._$data.containsKey('usersByDefaultRoleAggregate')) {
      return false;
    }
    if (l$usersByDefaultRoleAggregate != lOther$usersByDefaultRoleAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$role = role;
    final l$userRolesAggregate = userRolesAggregate;
    final l$usersByDefaultRoleAggregate = usersByDefaultRoleAggregate;
    return Object.hashAll([
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userRolesAggregate')
          ? l$userRolesAggregate
          : const {},
      _$data.containsKey('usersByDefaultRoleAggregate')
          ? l$usersByDefaultRoleAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRolesOrderBy<TRes> {
  factory CopyWith$InputauthRolesOrderBy(
    InputauthRolesOrderBy instance,
    TRes Function(InputauthRolesOrderBy) then,
  ) = _CopyWithImpl$InputauthRolesOrderBy;

  factory CopyWith$InputauthRolesOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesOrderBy;

  TRes call({
    EnumOrderBy? role,
    InputauthUserRolesAggregateOrderBy? userRolesAggregate,
    InputusersAggregateOrderBy? usersByDefaultRoleAggregate,
  });
  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get userRolesAggregate;
  CopyWith$InputusersAggregateOrderBy<TRes> get usersByDefaultRoleAggregate;
}

class _CopyWithImpl$InputauthRolesOrderBy<TRes>
    implements CopyWith$InputauthRolesOrderBy<TRes> {
  _CopyWithImpl$InputauthRolesOrderBy(
    this._instance,
    this._then,
  );

  final InputauthRolesOrderBy _instance;

  final TRes Function(InputauthRolesOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? role = _undefined,
    Object? userRolesAggregate = _undefined,
    Object? usersByDefaultRoleAggregate = _undefined,
  }) =>
      _then(InputauthRolesOrderBy._({
        ..._instance._$data,
        if (role != _undefined) 'role': (role as EnumOrderBy?),
        if (userRolesAggregate != _undefined)
          'userRolesAggregate':
              (userRolesAggregate as InputauthUserRolesAggregateOrderBy?),
        if (usersByDefaultRoleAggregate != _undefined)
          'usersByDefaultRoleAggregate':
              (usersByDefaultRoleAggregate as InputusersAggregateOrderBy?),
      }));
  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get userRolesAggregate {
    final local$userRolesAggregate = _instance.userRolesAggregate;
    return local$userRolesAggregate == null
        ? CopyWith$InputauthUserRolesAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputauthUserRolesAggregateOrderBy(
            local$userRolesAggregate, (e) => call(userRolesAggregate: e));
  }

  CopyWith$InputusersAggregateOrderBy<TRes> get usersByDefaultRoleAggregate {
    final local$usersByDefaultRoleAggregate =
        _instance.usersByDefaultRoleAggregate;
    return local$usersByDefaultRoleAggregate == null
        ? CopyWith$InputusersAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputusersAggregateOrderBy(local$usersByDefaultRoleAggregate,
            (e) => call(usersByDefaultRoleAggregate: e));
  }
}

class _CopyWithStubImpl$InputauthRolesOrderBy<TRes>
    implements CopyWith$InputauthRolesOrderBy<TRes> {
  _CopyWithStubImpl$InputauthRolesOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? role,
    InputauthUserRolesAggregateOrderBy? userRolesAggregate,
    InputusersAggregateOrderBy? usersByDefaultRoleAggregate,
  }) =>
      _res;
  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get userRolesAggregate =>
      CopyWith$InputauthUserRolesAggregateOrderBy.stub(_res);
  CopyWith$InputusersAggregateOrderBy<TRes> get usersByDefaultRoleAggregate =>
      CopyWith$InputusersAggregateOrderBy.stub(_res);
}

class InputauthRolesPkColumnsInput {
  factory InputauthRolesPkColumnsInput({required String role}) =>
      InputauthRolesPkColumnsInput._({
        r'role': role,
      });

  InputauthRolesPkColumnsInput._(this._$data);

  factory InputauthRolesPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$role = data['role'];
    result$data['role'] = (l$role as String);
    return InputauthRolesPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get role => (_$data['role'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$role = role;
    result$data['role'] = l$role;
    return result$data;
  }

  CopyWith$InputauthRolesPkColumnsInput<InputauthRolesPkColumnsInput>
      get copyWith => CopyWith$InputauthRolesPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$role = role;
    return Object.hashAll([l$role]);
  }
}

abstract class CopyWith$InputauthRolesPkColumnsInput<TRes> {
  factory CopyWith$InputauthRolesPkColumnsInput(
    InputauthRolesPkColumnsInput instance,
    TRes Function(InputauthRolesPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthRolesPkColumnsInput;

  factory CopyWith$InputauthRolesPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesPkColumnsInput;

  TRes call({String? role});
}

class _CopyWithImpl$InputauthRolesPkColumnsInput<TRes>
    implements CopyWith$InputauthRolesPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthRolesPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthRolesPkColumnsInput _instance;

  final TRes Function(InputauthRolesPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? role = _undefined}) =>
      _then(InputauthRolesPkColumnsInput._({
        ..._instance._$data,
        if (role != _undefined && role != null) 'role': (role as String),
      }));
}

class _CopyWithStubImpl$InputauthRolesPkColumnsInput<TRes>
    implements CopyWith$InputauthRolesPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthRolesPkColumnsInput(this._res);

  TRes _res;

  call({String? role}) => _res;
}

class InputauthRolesSetInput {
  factory InputauthRolesSetInput({String? role}) => InputauthRolesSetInput._({
        if (role != null) r'role': role,
      });

  InputauthRolesSetInput._(this._$data);

  factory InputauthRolesSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    return InputauthRolesSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get role => (_$data['role'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    return result$data;
  }

  CopyWith$InputauthRolesSetInput<InputauthRolesSetInput> get copyWith =>
      CopyWith$InputauthRolesSetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$role = role;
    return Object.hashAll([_$data.containsKey('role') ? l$role : const {}]);
  }
}

abstract class CopyWith$InputauthRolesSetInput<TRes> {
  factory CopyWith$InputauthRolesSetInput(
    InputauthRolesSetInput instance,
    TRes Function(InputauthRolesSetInput) then,
  ) = _CopyWithImpl$InputauthRolesSetInput;

  factory CopyWith$InputauthRolesSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesSetInput;

  TRes call({String? role});
}

class _CopyWithImpl$InputauthRolesSetInput<TRes>
    implements CopyWith$InputauthRolesSetInput<TRes> {
  _CopyWithImpl$InputauthRolesSetInput(
    this._instance,
    this._then,
  );

  final InputauthRolesSetInput _instance;

  final TRes Function(InputauthRolesSetInput) _then;

  static const _undefined = {};

  TRes call({Object? role = _undefined}) => _then(InputauthRolesSetInput._({
        ..._instance._$data,
        if (role != _undefined) 'role': (role as String?),
      }));
}

class _CopyWithStubImpl$InputauthRolesSetInput<TRes>
    implements CopyWith$InputauthRolesSetInput<TRes> {
  _CopyWithStubImpl$InputauthRolesSetInput(this._res);

  TRes _res;

  call({String? role}) => _res;
}

class InputauthRolesUpdates {
  factory InputauthRolesUpdates({
    InputauthRolesSetInput? $_set,
    required InputauthRolesBoolExp where,
  }) =>
      InputauthRolesUpdates._({
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthRolesUpdates._(this._$data);

  factory InputauthRolesUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthRolesSetInput.fromJson((l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputauthRolesBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputauthRolesUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthRolesSetInput? get $_set =>
      (_$data['_set'] as InputauthRolesSetInput?);
  InputauthRolesBoolExp get where => (_$data['where'] as InputauthRolesBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthRolesUpdates<InputauthRolesUpdates> get copyWith =>
      CopyWith$InputauthRolesUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRolesUpdates) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthRolesUpdates<TRes> {
  factory CopyWith$InputauthRolesUpdates(
    InputauthRolesUpdates instance,
    TRes Function(InputauthRolesUpdates) then,
  ) = _CopyWithImpl$InputauthRolesUpdates;

  factory CopyWith$InputauthRolesUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthRolesUpdates;

  TRes call({
    InputauthRolesSetInput? $_set,
    InputauthRolesBoolExp? where,
  });
  CopyWith$InputauthRolesSetInput<TRes> get $_set;
  CopyWith$InputauthRolesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthRolesUpdates<TRes>
    implements CopyWith$InputauthRolesUpdates<TRes> {
  _CopyWithImpl$InputauthRolesUpdates(
    this._instance,
    this._then,
  );

  final InputauthRolesUpdates _instance;

  final TRes Function(InputauthRolesUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthRolesUpdates._({
        ..._instance._$data,
        if ($_set != _undefined) '_set': ($_set as InputauthRolesSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthRolesBoolExp),
      }));
  CopyWith$InputauthRolesSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthRolesSetInput.stub(_then(_instance))
        : CopyWith$InputauthRolesSetInput(local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthRolesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthRolesBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthRolesUpdates<TRes>
    implements CopyWith$InputauthRolesUpdates<TRes> {
  _CopyWithStubImpl$InputauthRolesUpdates(this._res);

  TRes _res;

  call({
    InputauthRolesSetInput? $_set,
    InputauthRolesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthRolesSetInput<TRes> get $_set =>
      CopyWith$InputauthRolesSetInput.stub(_res);
  CopyWith$InputauthRolesBoolExp<TRes> get where =>
      CopyWith$InputauthRolesBoolExp.stub(_res);
}

class InputauthRoles_streamCursorInput {
  factory InputauthRoles_streamCursorInput({
    required InputauthRoles_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthRoles_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthRoles_streamCursorInput._(this._$data);

  factory InputauthRoles_streamCursorInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthRoles_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthRoles_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthRoles_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as InputauthRoles_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthRoles_streamCursorInput<InputauthRoles_streamCursorInput>
      get copyWith => CopyWith$InputauthRoles_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRoles_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthRoles_streamCursorInput<TRes> {
  factory CopyWith$InputauthRoles_streamCursorInput(
    InputauthRoles_streamCursorInput instance,
    TRes Function(InputauthRoles_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthRoles_streamCursorInput;

  factory CopyWith$InputauthRoles_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRoles_streamCursorInput;

  TRes call({
    InputauthRoles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthRoles_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$InputauthRoles_streamCursorInput<TRes>
    implements CopyWith$InputauthRoles_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthRoles_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthRoles_streamCursorInput _instance;

  final TRes Function(InputauthRoles_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthRoles_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue':
              (initialValue as InputauthRoles_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthRoles_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthRoles_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthRoles_streamCursorInput<TRes>
    implements CopyWith$InputauthRoles_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthRoles_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthRoles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthRoles_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$InputauthRoles_streamCursorValueInput.stub(_res);
}

class InputauthRoles_streamCursorValueInput {
  factory InputauthRoles_streamCursorValueInput({String? role}) =>
      InputauthRoles_streamCursorValueInput._({
        if (role != null) r'role': role,
      });

  InputauthRoles_streamCursorValueInput._(this._$data);

  factory InputauthRoles_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    return InputauthRoles_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get role => (_$data['role'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    return result$data;
  }

  CopyWith$InputauthRoles_streamCursorValueInput<
          InputauthRoles_streamCursorValueInput>
      get copyWith => CopyWith$InputauthRoles_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthRoles_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$role = role;
    return Object.hashAll([_$data.containsKey('role') ? l$role : const {}]);
  }
}

abstract class CopyWith$InputauthRoles_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthRoles_streamCursorValueInput(
    InputauthRoles_streamCursorValueInput instance,
    TRes Function(InputauthRoles_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthRoles_streamCursorValueInput;

  factory CopyWith$InputauthRoles_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthRoles_streamCursorValueInput;

  TRes call({String? role});
}

class _CopyWithImpl$InputauthRoles_streamCursorValueInput<TRes>
    implements CopyWith$InputauthRoles_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthRoles_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthRoles_streamCursorValueInput _instance;

  final TRes Function(InputauthRoles_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({Object? role = _undefined}) =>
      _then(InputauthRoles_streamCursorValueInput._({
        ..._instance._$data,
        if (role != _undefined) 'role': (role as String?),
      }));
}

class _CopyWithStubImpl$InputauthRoles_streamCursorValueInput<TRes>
    implements CopyWith$InputauthRoles_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthRoles_streamCursorValueInput(this._res);

  TRes _res;

  call({String? role}) => _res;
}

class InputauthUserAuthenticatorsAggregateOrderBy {
  factory InputauthUserAuthenticatorsAggregateOrderBy({
    InputauthUserAuthenticators_avg_order_by? avg,
    EnumOrderBy? count,
    InputauthUserAuthenticators_max_order_by? max,
    InputauthUserAuthenticators_min_order_by? min,
    InputauthUserAuthenticators_stddev_order_by? stddev,
    InputauthUserAuthenticators_stddev_pop_order_by? stddev_pop,
    InputauthUserAuthenticators_stddev_samp_order_by? stddev_samp,
    InputauthUserAuthenticators_sum_order_by? sum,
    InputauthUserAuthenticators_var_pop_order_by? var_pop,
    InputauthUserAuthenticators_var_samp_order_by? var_samp,
    InputauthUserAuthenticators_variance_order_by? variance,
  }) =>
      InputauthUserAuthenticatorsAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddev_pop != null) r'stddev_pop': stddev_pop,
        if (stddev_samp != null) r'stddev_samp': stddev_samp,
        if (sum != null) r'sum': sum,
        if (var_pop != null) r'var_pop': var_pop,
        if (var_samp != null) r'var_samp': var_samp,
        if (variance != null) r'variance': variance,
      });

  InputauthUserAuthenticatorsAggregateOrderBy._(this._$data);

  factory InputauthUserAuthenticatorsAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : InputauthUserAuthenticators_avg_order_by.fromJson(
              (l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : InputauthUserAuthenticators_max_order_by.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : InputauthUserAuthenticators_min_order_by.fromJson(
              (l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : InputauthUserAuthenticators_stddev_order_by.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddev_pop')) {
      final l$stddev_pop = data['stddev_pop'];
      result$data['stddev_pop'] = l$stddev_pop == null
          ? null
          : InputauthUserAuthenticators_stddev_pop_order_by.fromJson(
              (l$stddev_pop as Map<String, dynamic>));
    }
    if (data.containsKey('stddev_samp')) {
      final l$stddev_samp = data['stddev_samp'];
      result$data['stddev_samp'] = l$stddev_samp == null
          ? null
          : InputauthUserAuthenticators_stddev_samp_order_by.fromJson(
              (l$stddev_samp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : InputauthUserAuthenticators_sum_order_by.fromJson(
              (l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('var_pop')) {
      final l$var_pop = data['var_pop'];
      result$data['var_pop'] = l$var_pop == null
          ? null
          : InputauthUserAuthenticators_var_pop_order_by.fromJson(
              (l$var_pop as Map<String, dynamic>));
    }
    if (data.containsKey('var_samp')) {
      final l$var_samp = data['var_samp'];
      result$data['var_samp'] = l$var_samp == null
          ? null
          : InputauthUserAuthenticators_var_samp_order_by.fromJson(
              (l$var_samp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : InputauthUserAuthenticators_variance_order_by.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return InputauthUserAuthenticatorsAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserAuthenticators_avg_order_by? get avg =>
      (_$data['avg'] as InputauthUserAuthenticators_avg_order_by?);
  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  InputauthUserAuthenticators_max_order_by? get max =>
      (_$data['max'] as InputauthUserAuthenticators_max_order_by?);
  InputauthUserAuthenticators_min_order_by? get min =>
      (_$data['min'] as InputauthUserAuthenticators_min_order_by?);
  InputauthUserAuthenticators_stddev_order_by? get stddev =>
      (_$data['stddev'] as InputauthUserAuthenticators_stddev_order_by?);
  InputauthUserAuthenticators_stddev_pop_order_by? get stddev_pop =>
      (_$data['stddev_pop']
          as InputauthUserAuthenticators_stddev_pop_order_by?);
  InputauthUserAuthenticators_stddev_samp_order_by? get stddev_samp =>
      (_$data['stddev_samp']
          as InputauthUserAuthenticators_stddev_samp_order_by?);
  InputauthUserAuthenticators_sum_order_by? get sum =>
      (_$data['sum'] as InputauthUserAuthenticators_sum_order_by?);
  InputauthUserAuthenticators_var_pop_order_by? get var_pop =>
      (_$data['var_pop'] as InputauthUserAuthenticators_var_pop_order_by?);
  InputauthUserAuthenticators_var_samp_order_by? get var_samp =>
      (_$data['var_samp'] as InputauthUserAuthenticators_var_samp_order_by?);
  InputauthUserAuthenticators_variance_order_by? get variance =>
      (_$data['variance'] as InputauthUserAuthenticators_variance_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddev_pop')) {
      final l$stddev_pop = stddev_pop;
      result$data['stddev_pop'] = l$stddev_pop?.toJson();
    }
    if (_$data.containsKey('stddev_samp')) {
      final l$stddev_samp = stddev_samp;
      result$data['stddev_samp'] = l$stddev_samp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('var_pop')) {
      final l$var_pop = var_pop;
      result$data['var_pop'] = l$var_pop?.toJson();
    }
    if (_$data.containsKey('var_samp')) {
      final l$var_samp = var_samp;
      result$data['var_samp'] = l$var_samp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<
          InputauthUserAuthenticatorsAggregateOrderBy>
      get copyWith => CopyWith$InputauthUserAuthenticatorsAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddev_pop = stddev_pop;
    final lOther$stddev_pop = other.stddev_pop;
    if (_$data.containsKey('stddev_pop') !=
        other._$data.containsKey('stddev_pop')) {
      return false;
    }
    if (l$stddev_pop != lOther$stddev_pop) {
      return false;
    }
    final l$stddev_samp = stddev_samp;
    final lOther$stddev_samp = other.stddev_samp;
    if (_$data.containsKey('stddev_samp') !=
        other._$data.containsKey('stddev_samp')) {
      return false;
    }
    if (l$stddev_samp != lOther$stddev_samp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$var_pop = var_pop;
    final lOther$var_pop = other.var_pop;
    if (_$data.containsKey('var_pop') != other._$data.containsKey('var_pop')) {
      return false;
    }
    if (l$var_pop != lOther$var_pop) {
      return false;
    }
    final l$var_samp = var_samp;
    final lOther$var_samp = other.var_samp;
    if (_$data.containsKey('var_samp') !=
        other._$data.containsKey('var_samp')) {
      return false;
    }
    if (l$var_samp != lOther$var_samp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddev_pop = stddev_pop;
    final l$stddev_samp = stddev_samp;
    final l$sum = sum;
    final l$var_pop = var_pop;
    final l$var_samp = var_samp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddev_pop') ? l$stddev_pop : const {},
      _$data.containsKey('stddev_samp') ? l$stddev_samp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('var_pop') ? l$var_pop : const {},
      _$data.containsKey('var_samp') ? l$var_samp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsAggregateOrderBy(
    InputauthUserAuthenticatorsAggregateOrderBy instance,
    TRes Function(InputauthUserAuthenticatorsAggregateOrderBy) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsAggregateOrderBy;

  factory CopyWith$InputauthUserAuthenticatorsAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsAggregateOrderBy;

  TRes call({
    InputauthUserAuthenticators_avg_order_by? avg,
    EnumOrderBy? count,
    InputauthUserAuthenticators_max_order_by? max,
    InputauthUserAuthenticators_min_order_by? min,
    InputauthUserAuthenticators_stddev_order_by? stddev,
    InputauthUserAuthenticators_stddev_pop_order_by? stddev_pop,
    InputauthUserAuthenticators_stddev_samp_order_by? stddev_samp,
    InputauthUserAuthenticators_sum_order_by? sum,
    InputauthUserAuthenticators_var_pop_order_by? var_pop,
    InputauthUserAuthenticators_var_samp_order_by? var_samp,
    InputauthUserAuthenticators_variance_order_by? variance,
  });
  CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> get avg;
  CopyWith$InputauthUserAuthenticators_max_order_by<TRes> get max;
  CopyWith$InputauthUserAuthenticators_min_order_by<TRes> get min;
  CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> get stddev;
  CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes> get stddev_pop;
  CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes>
      get stddev_samp;
  CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> get sum;
  CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> get var_pop;
  CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> get var_samp;
  CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> get variance;
}

class _CopyWithImpl$InputauthUserAuthenticatorsAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsAggregateOrderBy _instance;

  final TRes Function(InputauthUserAuthenticatorsAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddev_pop = _undefined,
    Object? stddev_samp = _undefined,
    Object? sum = _undefined,
    Object? var_pop = _undefined,
    Object? var_samp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined)
          'avg': (avg as InputauthUserAuthenticators_avg_order_by?),
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined)
          'max': (max as InputauthUserAuthenticators_max_order_by?),
        if (min != _undefined)
          'min': (min as InputauthUserAuthenticators_min_order_by?),
        if (stddev != _undefined)
          'stddev': (stddev as InputauthUserAuthenticators_stddev_order_by?),
        if (stddev_pop != _undefined)
          'stddev_pop':
              (stddev_pop as InputauthUserAuthenticators_stddev_pop_order_by?),
        if (stddev_samp != _undefined)
          'stddev_samp': (stddev_samp
              as InputauthUserAuthenticators_stddev_samp_order_by?),
        if (sum != _undefined)
          'sum': (sum as InputauthUserAuthenticators_sum_order_by?),
        if (var_pop != _undefined)
          'var_pop': (var_pop as InputauthUserAuthenticators_var_pop_order_by?),
        if (var_samp != _undefined)
          'var_samp':
              (var_samp as InputauthUserAuthenticators_var_samp_order_by?),
        if (variance != _undefined)
          'variance':
              (variance as InputauthUserAuthenticators_variance_order_by?),
      }));
  CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$InputauthUserAuthenticators_avg_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_avg_order_by(
            local$avg, (e) => call(avg: e));
  }

  CopyWith$InputauthUserAuthenticators_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$InputauthUserAuthenticators_max_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_max_order_by(
            local$max, (e) => call(max: e));
  }

  CopyWith$InputauthUserAuthenticators_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$InputauthUserAuthenticators_min_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_min_order_by(
            local$min, (e) => call(min: e));
  }

  CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$InputauthUserAuthenticators_stddev_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_stddev_order_by(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes>
      get stddev_pop {
    final local$stddev_pop = _instance.stddev_pop;
    return local$stddev_pop == null
        ? CopyWith$InputauthUserAuthenticators_stddev_pop_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_stddev_pop_order_by(
            local$stddev_pop, (e) => call(stddev_pop: e));
  }

  CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes>
      get stddev_samp {
    final local$stddev_samp = _instance.stddev_samp;
    return local$stddev_samp == null
        ? CopyWith$InputauthUserAuthenticators_stddev_samp_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_stddev_samp_order_by(
            local$stddev_samp, (e) => call(stddev_samp: e));
  }

  CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$InputauthUserAuthenticators_sum_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_sum_order_by(
            local$sum, (e) => call(sum: e));
  }

  CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> get var_pop {
    final local$var_pop = _instance.var_pop;
    return local$var_pop == null
        ? CopyWith$InputauthUserAuthenticators_var_pop_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_var_pop_order_by(
            local$var_pop, (e) => call(var_pop: e));
  }

  CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> get var_samp {
    final local$var_samp = _instance.var_samp;
    return local$var_samp == null
        ? CopyWith$InputauthUserAuthenticators_var_samp_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_var_samp_order_by(
            local$var_samp, (e) => call(var_samp: e));
  }

  CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$InputauthUserAuthenticators_variance_order_by.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticators_variance_order_by(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsAggregateOrderBy(this._res);

  TRes _res;

  call({
    InputauthUserAuthenticators_avg_order_by? avg,
    EnumOrderBy? count,
    InputauthUserAuthenticators_max_order_by? max,
    InputauthUserAuthenticators_min_order_by? min,
    InputauthUserAuthenticators_stddev_order_by? stddev,
    InputauthUserAuthenticators_stddev_pop_order_by? stddev_pop,
    InputauthUserAuthenticators_stddev_samp_order_by? stddev_samp,
    InputauthUserAuthenticators_sum_order_by? sum,
    InputauthUserAuthenticators_var_pop_order_by? var_pop,
    InputauthUserAuthenticators_var_samp_order_by? var_samp,
    InputauthUserAuthenticators_variance_order_by? variance,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> get avg =>
      CopyWith$InputauthUserAuthenticators_avg_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_max_order_by<TRes> get max =>
      CopyWith$InputauthUserAuthenticators_max_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_min_order_by<TRes> get min =>
      CopyWith$InputauthUserAuthenticators_min_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> get stddev =>
      CopyWith$InputauthUserAuthenticators_stddev_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes>
      get stddev_pop =>
          CopyWith$InputauthUserAuthenticators_stddev_pop_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes>
      get stddev_samp =>
          CopyWith$InputauthUserAuthenticators_stddev_samp_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> get sum =>
      CopyWith$InputauthUserAuthenticators_sum_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> get var_pop =>
      CopyWith$InputauthUserAuthenticators_var_pop_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> get var_samp =>
      CopyWith$InputauthUserAuthenticators_var_samp_order_by.stub(_res);
  CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> get variance =>
      CopyWith$InputauthUserAuthenticators_variance_order_by.stub(_res);
}

class InputauthUserAuthenticatorsArrRelInsertInput {
  factory InputauthUserAuthenticatorsArrRelInsertInput({
    required List<InputauthUserAuthenticatorsInsertInput> data,
    InputauthUserAuthenticatorsOnConflict? onConflict,
  }) =>
      InputauthUserAuthenticatorsArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthUserAuthenticatorsArrRelInsertInput._(this._$data);

  factory InputauthUserAuthenticatorsArrRelInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => InputauthUserAuthenticatorsInsertInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthUserAuthenticatorsOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthUserAuthenticatorsArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserAuthenticatorsInsertInput> get data =>
      (_$data['data'] as List<InputauthUserAuthenticatorsInsertInput>);
  InputauthUserAuthenticatorsOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthUserAuthenticatorsOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<
          InputauthUserAuthenticatorsArrRelInsertInput>
      get copyWith => CopyWith$InputauthUserAuthenticatorsArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsArrRelInsertInput(
    InputauthUserAuthenticatorsArrRelInsertInput instance,
    TRes Function(InputauthUserAuthenticatorsArrRelInsertInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsArrRelInsertInput;

  factory CopyWith$InputauthUserAuthenticatorsArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsArrRelInsertInput;

  TRes call({
    List<InputauthUserAuthenticatorsInsertInput>? data,
    InputauthUserAuthenticatorsOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputauthUserAuthenticatorsInsertInput> Function(
              Iterable<
                  CopyWith$InputauthUserAuthenticatorsInsertInput<
                      InputauthUserAuthenticatorsInsertInput>>)
          _fn);
  CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthUserAuthenticatorsArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsArrRelInsertInput _instance;

  final TRes Function(InputauthUserAuthenticatorsArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputauthUserAuthenticatorsInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthUserAuthenticatorsOnConflict?),
      }));
  TRes data(
          Iterable<InputauthUserAuthenticatorsInsertInput> Function(
                  Iterable<
                      CopyWith$InputauthUserAuthenticatorsInsertInput<
                          InputauthUserAuthenticatorsInsertInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$InputauthUserAuthenticatorsInsertInput(
                    e,
                    (i) => i,
                  ))).toList());
  CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthUserAuthenticatorsOnConflict.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputauthUserAuthenticatorsInsertInput>? data,
    InputauthUserAuthenticatorsOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> get onConflict =>
      CopyWith$InputauthUserAuthenticatorsOnConflict.stub(_res);
}

class InputauthUserAuthenticatorsBoolExp {
  factory InputauthUserAuthenticatorsBoolExp({
    List<InputauthUserAuthenticatorsBoolExp>? $_and,
    InputauthUserAuthenticatorsBoolExp? $_not,
    List<InputauthUserAuthenticatorsBoolExp>? $_or,
    InputBigintComparisonExp? counter,
    InputStringComparisonExp? credentialId,
    InputByteaComparisonExp? credentialPublicKey,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? transports,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      InputauthUserAuthenticatorsBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (credentialPublicKey != null)
          r'credentialPublicKey': credentialPublicKey,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticatorsBoolExp._(this._$data);

  factory InputauthUserAuthenticatorsBoolExp.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputauthUserAuthenticatorsBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthUserAuthenticatorsBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputauthUserAuthenticatorsBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : InputBigintComparisonExp.fromJson(
              (l$counter as Map<String, dynamic>));
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = l$credentialId == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$credentialId as Map<String, dynamic>));
    }
    if (data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = data['credentialPublicKey'];
      result$data['credentialPublicKey'] = l$credentialPublicKey == null
          ? null
          : InputByteaComparisonExp.fromJson(
              (l$credentialPublicKey as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = l$transports == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$transports as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersBoolExp.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : InputUuidComparisonExp.fromJson((l$userId as Map<String, dynamic>));
    }
    return InputauthUserAuthenticatorsBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserAuthenticatorsBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthUserAuthenticatorsBoolExp>?);
  InputauthUserAuthenticatorsBoolExp? get $_not =>
      (_$data['_not'] as InputauthUserAuthenticatorsBoolExp?);
  List<InputauthUserAuthenticatorsBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthUserAuthenticatorsBoolExp>?);
  InputBigintComparisonExp? get counter =>
      (_$data['counter'] as InputBigintComparisonExp?);
  InputStringComparisonExp? get credentialId =>
      (_$data['credentialId'] as InputStringComparisonExp?);
  InputByteaComparisonExp? get credentialPublicKey =>
      (_$data['credentialPublicKey'] as InputByteaComparisonExp?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputStringComparisonExp? get transports =>
      (_$data['transports'] as InputStringComparisonExp?);
  InputusersBoolExp? get user => (_$data['user'] as InputusersBoolExp?);
  InputUuidComparisonExp? get userId =>
      (_$data['userId'] as InputUuidComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] = l$counter?.toJson();
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] = l$credentialId?.toJson();
    }
    if (_$data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = credentialPublicKey;
      result$data['credentialPublicKey'] = l$credentialPublicKey?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] = l$transports?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsBoolExp<
          InputauthUserAuthenticatorsBoolExp>
      get copyWith => CopyWith$InputauthUserAuthenticatorsBoolExp(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$credentialPublicKey = credentialPublicKey;
    final lOther$credentialPublicKey = other.credentialPublicKey;
    if (_$data.containsKey('credentialPublicKey') !=
        other._$data.containsKey('credentialPublicKey')) {
      return false;
    }
    if (l$credentialPublicKey != lOther$credentialPublicKey) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$credentialPublicKey = credentialPublicKey;
    final l$id = id;
    final l$transports = transports;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('credentialPublicKey')
          ? l$credentialPublicKey
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsBoolExp(
    InputauthUserAuthenticatorsBoolExp instance,
    TRes Function(InputauthUserAuthenticatorsBoolExp) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsBoolExp;

  factory CopyWith$InputauthUserAuthenticatorsBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsBoolExp;

  TRes call({
    List<InputauthUserAuthenticatorsBoolExp>? $_and,
    InputauthUserAuthenticatorsBoolExp? $_not,
    List<InputauthUserAuthenticatorsBoolExp>? $_or,
    InputBigintComparisonExp? counter,
    InputStringComparisonExp? credentialId,
    InputByteaComparisonExp? credentialPublicKey,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? transports,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  });
  TRes $_and(
      Iterable<InputauthUserAuthenticatorsBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserAuthenticatorsBoolExp<
                      InputauthUserAuthenticatorsBoolExp>>?)
          _fn);
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthUserAuthenticatorsBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserAuthenticatorsBoolExp<
                      InputauthUserAuthenticatorsBoolExp>>?)
          _fn);
  CopyWith$InputBigintComparisonExp<TRes> get counter;
  CopyWith$InputStringComparisonExp<TRes> get credentialId;
  CopyWith$InputByteaComparisonExp<TRes> get credentialPublicKey;
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputStringComparisonExp<TRes> get transports;
  CopyWith$InputusersBoolExp<TRes> get user;
  CopyWith$InputUuidComparisonExp<TRes> get userId;
}

class _CopyWithImpl$InputauthUserAuthenticatorsBoolExp<TRes>
    implements CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsBoolExp(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsBoolExp _instance;

  final TRes Function(InputauthUserAuthenticatorsBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? credentialPublicKey = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthUserAuthenticatorsBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as InputauthUserAuthenticatorsBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthUserAuthenticatorsBoolExp>?),
        if (counter != _undefined)
          'counter': (counter as InputBigintComparisonExp?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as InputStringComparisonExp?),
        if (credentialPublicKey != _undefined)
          'credentialPublicKey':
              (credentialPublicKey as InputByteaComparisonExp?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (transports != _undefined)
          'transports': (transports as InputStringComparisonExp?),
        if (user != _undefined) 'user': (user as InputusersBoolExp?),
        if (userId != _undefined) 'userId': (userId as InputUuidComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputauthUserAuthenticatorsBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserAuthenticatorsBoolExp<
                          InputauthUserAuthenticatorsBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and
              ?.map((e) => CopyWith$InputauthUserAuthenticatorsBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthUserAuthenticatorsBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserAuthenticatorsBoolExp<
                          InputauthUserAuthenticatorsBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or
              ?.map((e) => CopyWith$InputauthUserAuthenticatorsBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputBigintComparisonExp<TRes> get counter {
    final local$counter = _instance.counter;
    return local$counter == null
        ? CopyWith$InputBigintComparisonExp.stub(_then(_instance))
        : CopyWith$InputBigintComparisonExp(
            local$counter, (e) => call(counter: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get credentialId {
    final local$credentialId = _instance.credentialId;
    return local$credentialId == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$credentialId, (e) => call(credentialId: e));
  }

  CopyWith$InputByteaComparisonExp<TRes> get credentialPublicKey {
    final local$credentialPublicKey = _instance.credentialPublicKey;
    return local$credentialPublicKey == null
        ? CopyWith$InputByteaComparisonExp.stub(_then(_instance))
        : CopyWith$InputByteaComparisonExp(
            local$credentialPublicKey, (e) => call(credentialPublicKey: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get transports {
    final local$transports = _instance.transports;
    return local$transports == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$transports, (e) => call(transports: e));
  }

  CopyWith$InputusersBoolExp<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$user, (e) => call(user: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$userId, (e) => call(userId: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsBoolExp<TRes>
    implements CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthUserAuthenticatorsBoolExp>? $_and,
    InputauthUserAuthenticatorsBoolExp? $_not,
    List<InputauthUserAuthenticatorsBoolExp>? $_or,
    InputBigintComparisonExp? counter,
    InputStringComparisonExp? credentialId,
    InputByteaComparisonExp? credentialPublicKey,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? transports,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get $_not =>
      CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputBigintComparisonExp<TRes> get counter =>
      CopyWith$InputBigintComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get credentialId =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputByteaComparisonExp<TRes> get credentialPublicKey =>
      CopyWith$InputByteaComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get transports =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get user =>
      CopyWith$InputusersBoolExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get userId =>
      CopyWith$InputUuidComparisonExp.stub(_res);
}

class InputauthUserAuthenticatorsIncInput {
  factory InputauthUserAuthenticatorsIncInput({int? counter}) =>
      InputauthUserAuthenticatorsIncInput._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticatorsIncInput._(this._$data);

  factory InputauthUserAuthenticatorsIncInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = (l$counter as int?);
    }
    return InputauthUserAuthenticatorsIncInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get counter => (_$data['counter'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] = l$counter;
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsIncInput<
          InputauthUserAuthenticatorsIncInput>
      get copyWith => CopyWith$InputauthUserAuthenticatorsIncInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsIncInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsIncInput<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsIncInput(
    InputauthUserAuthenticatorsIncInput instance,
    TRes Function(InputauthUserAuthenticatorsIncInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsIncInput;

  factory CopyWith$InputauthUserAuthenticatorsIncInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsIncInput;

  TRes call({int? counter});
}

class _CopyWithImpl$InputauthUserAuthenticatorsIncInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsIncInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsIncInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsIncInput _instance;

  final TRes Function(InputauthUserAuthenticatorsIncInput) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticatorsIncInput._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as int?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsIncInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsIncInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsIncInput(this._res);

  TRes _res;

  call({int? counter}) => _res;
}

class InputauthUserAuthenticatorsInsertInput {
  factory InputauthUserAuthenticatorsInsertInput({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      InputauthUserAuthenticatorsInsertInput._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (credentialPublicKey != null)
          r'credentialPublicKey': credentialPublicKey,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticatorsInsertInput._(this._$data);

  factory InputauthUserAuthenticatorsInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = (l$counter as int?);
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = (l$credentialId as String?);
    }
    if (data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = data['credentialPublicKey'];
      result$data['credentialPublicKey'] = (l$credentialPublicKey as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = (l$transports as String?);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersObjRelInsertInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserAuthenticatorsInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get counter => (_$data['counter'] as int?);
  String? get credentialId => (_$data['credentialId'] as String?);
  int? get credentialPublicKey => (_$data['credentialPublicKey'] as int?);
  String? get id => (_$data['id'] as String?);
  String? get transports => (_$data['transports'] as String?);
  InputusersObjRelInsertInput? get user =>
      (_$data['user'] as InputusersObjRelInsertInput?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] = l$counter;
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] = l$credentialId;
    }
    if (_$data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = credentialPublicKey;
      result$data['credentialPublicKey'] = l$credentialPublicKey;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] = l$transports;
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsInsertInput<
          InputauthUserAuthenticatorsInsertInput>
      get copyWith => CopyWith$InputauthUserAuthenticatorsInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$credentialPublicKey = credentialPublicKey;
    final lOther$credentialPublicKey = other.credentialPublicKey;
    if (_$data.containsKey('credentialPublicKey') !=
        other._$data.containsKey('credentialPublicKey')) {
      return false;
    }
    if (l$credentialPublicKey != lOther$credentialPublicKey) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$credentialPublicKey = credentialPublicKey;
    final l$id = id;
    final l$transports = transports;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('credentialPublicKey')
          ? l$credentialPublicKey
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsInsertInput<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsInsertInput(
    InputauthUserAuthenticatorsInsertInput instance,
    TRes Function(InputauthUserAuthenticatorsInsertInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsInsertInput;

  factory CopyWith$InputauthUserAuthenticatorsInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsInsertInput;

  TRes call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    InputusersObjRelInsertInput? user,
    String? userId,
  });
  CopyWith$InputusersObjRelInsertInput<TRes> get user;
}

class _CopyWithImpl$InputauthUserAuthenticatorsInsertInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsInsertInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsInsertInput _instance;

  final TRes Function(InputauthUserAuthenticatorsInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? credentialPublicKey = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsInsertInput._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as int?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as String?),
        if (credentialPublicKey != _undefined)
          'credentialPublicKey': (credentialPublicKey as int?),
        if (id != _undefined) 'id': (id as String?),
        if (transports != _undefined) 'transports': (transports as String?),
        if (user != _undefined) 'user': (user as InputusersObjRelInsertInput?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
  CopyWith$InputusersObjRelInsertInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputusersObjRelInsertInput(
            local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsInsertInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsInsertInput(this._res);

  TRes _res;

  call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      _res;
  CopyWith$InputusersObjRelInsertInput<TRes> get user =>
      CopyWith$InputusersObjRelInsertInput.stub(_res);
}

class InputauthUserAuthenticatorsOnConflict {
  factory InputauthUserAuthenticatorsOnConflict({
    required EnumauthUserAuthenticatorsConstraint constraint,
    required List<EnumauthUserAuthenticatorsUpdateColumn> update_columns,
    InputauthUserAuthenticatorsBoolExp? where,
  }) =>
      InputauthUserAuthenticatorsOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthUserAuthenticatorsOnConflict._(this._$data);

  factory InputauthUserAuthenticatorsOnConflict.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthUserAuthenticatorsConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) =>
            fromJson$EnumauthUserAuthenticatorsUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthUserAuthenticatorsBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthUserAuthenticatorsOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthUserAuthenticatorsConstraint get constraint =>
      (_$data['constraint'] as EnumauthUserAuthenticatorsConstraint);
  List<EnumauthUserAuthenticatorsUpdateColumn> get update_columns =>
      (_$data['update_columns']
          as List<EnumauthUserAuthenticatorsUpdateColumn>);
  InputauthUserAuthenticatorsBoolExp? get where =>
      (_$data['where'] as InputauthUserAuthenticatorsBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthUserAuthenticatorsConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthUserAuthenticatorsUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsOnConflict<
          InputauthUserAuthenticatorsOnConflict>
      get copyWith => CopyWith$InputauthUserAuthenticatorsOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsOnConflict(
    InputauthUserAuthenticatorsOnConflict instance,
    TRes Function(InputauthUserAuthenticatorsOnConflict) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsOnConflict;

  factory CopyWith$InputauthUserAuthenticatorsOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsOnConflict;

  TRes call({
    EnumauthUserAuthenticatorsConstraint? constraint,
    List<EnumauthUserAuthenticatorsUpdateColumn>? update_columns,
    InputauthUserAuthenticatorsBoolExp? where,
  });
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserAuthenticatorsOnConflict<TRes>
    implements CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsOnConflict(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsOnConflict _instance;

  final TRes Function(InputauthUserAuthenticatorsOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthUserAuthenticatorsConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthUserAuthenticatorsUpdateColumn>),
        if (where != _undefined)
          'where': (where as InputauthUserAuthenticatorsBoolExp?),
      }));
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsOnConflict<TRes>
    implements CopyWith$InputauthUserAuthenticatorsOnConflict<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsOnConflict(this._res);

  TRes _res;

  call({
    EnumauthUserAuthenticatorsConstraint? constraint,
    List<EnumauthUserAuthenticatorsUpdateColumn>? update_columns,
    InputauthUserAuthenticatorsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where =>
      CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_res);
}

class InputauthUserAuthenticatorsOrderBy {
  factory InputauthUserAuthenticatorsOrderBy({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? credentialPublicKey,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      InputauthUserAuthenticatorsOrderBy._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (credentialPublicKey != null)
          r'credentialPublicKey': credentialPublicKey,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticatorsOrderBy._(this._$data);

  factory InputauthUserAuthenticatorsOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = l$credentialId == null
          ? null
          : fromJson$EnumOrderBy((l$credentialId as String));
    }
    if (data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = data['credentialPublicKey'];
      result$data['credentialPublicKey'] = l$credentialPublicKey == null
          ? null
          : fromJson$EnumOrderBy((l$credentialPublicKey as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = l$transports == null
          ? null
          : fromJson$EnumOrderBy((l$transports as String));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersOrderBy.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserAuthenticatorsOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  EnumOrderBy? get credentialId => (_$data['credentialId'] as EnumOrderBy?);
  EnumOrderBy? get credentialPublicKey =>
      (_$data['credentialPublicKey'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get transports => (_$data['transports'] as EnumOrderBy?);
  InputusersOrderBy? get user => (_$data['user'] as InputusersOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] =
          l$credentialId == null ? null : toJson$EnumOrderBy(l$credentialId);
    }
    if (_$data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = credentialPublicKey;
      result$data['credentialPublicKey'] = l$credentialPublicKey == null
          ? null
          : toJson$EnumOrderBy(l$credentialPublicKey);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] =
          l$transports == null ? null : toJson$EnumOrderBy(l$transports);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsOrderBy<
          InputauthUserAuthenticatorsOrderBy>
      get copyWith => CopyWith$InputauthUserAuthenticatorsOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$credentialPublicKey = credentialPublicKey;
    final lOther$credentialPublicKey = other.credentialPublicKey;
    if (_$data.containsKey('credentialPublicKey') !=
        other._$data.containsKey('credentialPublicKey')) {
      return false;
    }
    if (l$credentialPublicKey != lOther$credentialPublicKey) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$credentialPublicKey = credentialPublicKey;
    final l$id = id;
    final l$transports = transports;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('credentialPublicKey')
          ? l$credentialPublicKey
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsOrderBy<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsOrderBy(
    InputauthUserAuthenticatorsOrderBy instance,
    TRes Function(InputauthUserAuthenticatorsOrderBy) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsOrderBy;

  factory CopyWith$InputauthUserAuthenticatorsOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsOrderBy;

  TRes call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? credentialPublicKey,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  });
  CopyWith$InputusersOrderBy<TRes> get user;
}

class _CopyWithImpl$InputauthUserAuthenticatorsOrderBy<TRes>
    implements CopyWith$InputauthUserAuthenticatorsOrderBy<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsOrderBy _instance;

  final TRes Function(InputauthUserAuthenticatorsOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? credentialPublicKey = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsOrderBy._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as EnumOrderBy?),
        if (credentialPublicKey != _undefined)
          'credentialPublicKey': (credentialPublicKey as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (transports != _undefined)
          'transports': (transports as EnumOrderBy?),
        if (user != _undefined) 'user': (user as InputusersOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
  CopyWith$InputusersOrderBy<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersOrderBy.stub(_then(_instance))
        : CopyWith$InputusersOrderBy(local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsOrderBy<TRes>
    implements CopyWith$InputauthUserAuthenticatorsOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? credentialPublicKey,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      _res;
  CopyWith$InputusersOrderBy<TRes> get user =>
      CopyWith$InputusersOrderBy.stub(_res);
}

class InputauthUserAuthenticatorsPkColumnsInput {
  factory InputauthUserAuthenticatorsPkColumnsInput({required String id}) =>
      InputauthUserAuthenticatorsPkColumnsInput._({
        r'id': id,
      });

  InputauthUserAuthenticatorsPkColumnsInput._(this._$data);

  factory InputauthUserAuthenticatorsPkColumnsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputauthUserAuthenticatorsPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsPkColumnsInput<
          InputauthUserAuthenticatorsPkColumnsInput>
      get copyWith => CopyWith$InputauthUserAuthenticatorsPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsPkColumnsInput<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsPkColumnsInput(
    InputauthUserAuthenticatorsPkColumnsInput instance,
    TRes Function(InputauthUserAuthenticatorsPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsPkColumnsInput;

  factory CopyWith$InputauthUserAuthenticatorsPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthUserAuthenticatorsPkColumnsInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsPkColumnsInput _instance;

  final TRes Function(InputauthUserAuthenticatorsPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthUserAuthenticatorsPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsPkColumnsInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthUserAuthenticatorsSetInput {
  factory InputauthUserAuthenticatorsSetInput({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  }) =>
      InputauthUserAuthenticatorsSetInput._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (credentialPublicKey != null)
          r'credentialPublicKey': credentialPublicKey,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticatorsSetInput._(this._$data);

  factory InputauthUserAuthenticatorsSetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = (l$counter as int?);
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = (l$credentialId as String?);
    }
    if (data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = data['credentialPublicKey'];
      result$data['credentialPublicKey'] = (l$credentialPublicKey as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = (l$transports as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserAuthenticatorsSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get counter => (_$data['counter'] as int?);
  String? get credentialId => (_$data['credentialId'] as String?);
  int? get credentialPublicKey => (_$data['credentialPublicKey'] as int?);
  String? get id => (_$data['id'] as String?);
  String? get transports => (_$data['transports'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] = l$counter;
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] = l$credentialId;
    }
    if (_$data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = credentialPublicKey;
      result$data['credentialPublicKey'] = l$credentialPublicKey;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] = l$transports;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsSetInput<
          InputauthUserAuthenticatorsSetInput>
      get copyWith => CopyWith$InputauthUserAuthenticatorsSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$credentialPublicKey = credentialPublicKey;
    final lOther$credentialPublicKey = other.credentialPublicKey;
    if (_$data.containsKey('credentialPublicKey') !=
        other._$data.containsKey('credentialPublicKey')) {
      return false;
    }
    if (l$credentialPublicKey != lOther$credentialPublicKey) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$credentialPublicKey = credentialPublicKey;
    final l$id = id;
    final l$transports = transports;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('credentialPublicKey')
          ? l$credentialPublicKey
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsSetInput<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsSetInput(
    InputauthUserAuthenticatorsSetInput instance,
    TRes Function(InputauthUserAuthenticatorsSetInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsSetInput;

  factory CopyWith$InputauthUserAuthenticatorsSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsSetInput;

  TRes call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserAuthenticatorsSetInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsSetInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsSetInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsSetInput _instance;

  final TRes Function(InputauthUserAuthenticatorsSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? credentialPublicKey = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsSetInput._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as int?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as String?),
        if (credentialPublicKey != _undefined)
          'credentialPublicKey': (credentialPublicKey as int?),
        if (id != _undefined) 'id': (id as String?),
        if (transports != _undefined) 'transports': (transports as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsSetInput<TRes>
    implements CopyWith$InputauthUserAuthenticatorsSetInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsSetInput(this._res);

  TRes _res;

  call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  }) =>
      _res;
}

class InputauthUserAuthenticatorsUpdates {
  factory InputauthUserAuthenticatorsUpdates({
    InputauthUserAuthenticatorsIncInput? $_inc,
    InputauthUserAuthenticatorsSetInput? $_set,
    required InputauthUserAuthenticatorsBoolExp where,
  }) =>
      InputauthUserAuthenticatorsUpdates._({
        if ($_inc != null) r'_inc': $_inc,
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthUserAuthenticatorsUpdates._(this._$data);

  factory InputauthUserAuthenticatorsUpdates.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_inc')) {
      final l$$_inc = data['_inc'];
      result$data['_inc'] = l$$_inc == null
          ? null
          : InputauthUserAuthenticatorsIncInput.fromJson(
              (l$$_inc as Map<String, dynamic>));
    }
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthUserAuthenticatorsSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] = InputauthUserAuthenticatorsBoolExp.fromJson(
        (l$where as Map<String, dynamic>));
    return InputauthUserAuthenticatorsUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserAuthenticatorsIncInput? get $_inc =>
      (_$data['_inc'] as InputauthUserAuthenticatorsIncInput?);
  InputauthUserAuthenticatorsSetInput? get $_set =>
      (_$data['_set'] as InputauthUserAuthenticatorsSetInput?);
  InputauthUserAuthenticatorsBoolExp get where =>
      (_$data['where'] as InputauthUserAuthenticatorsBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_inc')) {
      final l$$_inc = $_inc;
      result$data['_inc'] = l$$_inc?.toJson();
    }
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthUserAuthenticatorsUpdates<
          InputauthUserAuthenticatorsUpdates>
      get copyWith => CopyWith$InputauthUserAuthenticatorsUpdates(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticatorsUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_inc = $_inc;
    final lOther$$_inc = other.$_inc;
    if (_$data.containsKey('_inc') != other._$data.containsKey('_inc')) {
      return false;
    }
    if (l$$_inc != lOther$$_inc) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_inc = $_inc;
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_inc') ? l$$_inc : const {},
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticatorsUpdates<TRes> {
  factory CopyWith$InputauthUserAuthenticatorsUpdates(
    InputauthUserAuthenticatorsUpdates instance,
    TRes Function(InputauthUserAuthenticatorsUpdates) then,
  ) = _CopyWithImpl$InputauthUserAuthenticatorsUpdates;

  factory CopyWith$InputauthUserAuthenticatorsUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticatorsUpdates;

  TRes call({
    InputauthUserAuthenticatorsIncInput? $_inc,
    InputauthUserAuthenticatorsSetInput? $_set,
    InputauthUserAuthenticatorsBoolExp? where,
  });
  CopyWith$InputauthUserAuthenticatorsIncInput<TRes> get $_inc;
  CopyWith$InputauthUserAuthenticatorsSetInput<TRes> get $_set;
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserAuthenticatorsUpdates<TRes>
    implements CopyWith$InputauthUserAuthenticatorsUpdates<TRes> {
  _CopyWithImpl$InputauthUserAuthenticatorsUpdates(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticatorsUpdates _instance;

  final TRes Function(InputauthUserAuthenticatorsUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_inc = _undefined,
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserAuthenticatorsUpdates._({
        ..._instance._$data,
        if ($_inc != _undefined)
          '_inc': ($_inc as InputauthUserAuthenticatorsIncInput?),
        if ($_set != _undefined)
          '_set': ($_set as InputauthUserAuthenticatorsSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthUserAuthenticatorsBoolExp),
      }));
  CopyWith$InputauthUserAuthenticatorsIncInput<TRes> get $_inc {
    final local$$_inc = _instance.$_inc;
    return local$$_inc == null
        ? CopyWith$InputauthUserAuthenticatorsIncInput.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsIncInput(
            local$$_inc, (e) => call($_inc: e));
  }

  CopyWith$InputauthUserAuthenticatorsSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthUserAuthenticatorsSetInput.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthUserAuthenticatorsBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticatorsUpdates<TRes>
    implements CopyWith$InputauthUserAuthenticatorsUpdates<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticatorsUpdates(this._res);

  TRes _res;

  call({
    InputauthUserAuthenticatorsIncInput? $_inc,
    InputauthUserAuthenticatorsSetInput? $_set,
    InputauthUserAuthenticatorsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticatorsIncInput<TRes> get $_inc =>
      CopyWith$InputauthUserAuthenticatorsIncInput.stub(_res);
  CopyWith$InputauthUserAuthenticatorsSetInput<TRes> get $_set =>
      CopyWith$InputauthUserAuthenticatorsSetInput.stub(_res);
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get where =>
      CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_res);
}

class InputauthUserAuthenticators_avg_order_by {
  factory InputauthUserAuthenticators_avg_order_by({EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_avg_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_avg_order_by._(this._$data);

  factory InputauthUserAuthenticators_avg_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_avg_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_avg_order_by<
          InputauthUserAuthenticators_avg_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_avg_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_avg_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_avg_order_by(
    InputauthUserAuthenticators_avg_order_by instance,
    TRes Function(InputauthUserAuthenticators_avg_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_avg_order_by;

  factory CopyWith$InputauthUserAuthenticators_avg_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_avg_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_avg_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_avg_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_avg_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_avg_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_avg_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_avg_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_avg_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_avg_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_max_order_by {
  factory InputauthUserAuthenticators_max_order_by({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  }) =>
      InputauthUserAuthenticators_max_order_by._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticators_max_order_by._(this._$data);

  factory InputauthUserAuthenticators_max_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = l$credentialId == null
          ? null
          : fromJson$EnumOrderBy((l$credentialId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = l$transports == null
          ? null
          : fromJson$EnumOrderBy((l$transports as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserAuthenticators_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  EnumOrderBy? get credentialId => (_$data['credentialId'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get transports => (_$data['transports'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] =
          l$credentialId == null ? null : toJson$EnumOrderBy(l$credentialId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] =
          l$transports == null ? null : toJson$EnumOrderBy(l$transports);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_max_order_by<
          InputauthUserAuthenticators_max_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_max_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$id = id;
    final l$transports = transports;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_max_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_max_order_by(
    InputauthUserAuthenticators_max_order_by instance,
    TRes Function(InputauthUserAuthenticators_max_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_max_order_by;

  factory CopyWith$InputauthUserAuthenticators_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_max_order_by;

  TRes call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserAuthenticators_max_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_max_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_max_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_max_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticators_max_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (transports != _undefined)
          'transports': (transports as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_max_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_max_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserAuthenticators_min_order_by {
  factory InputauthUserAuthenticators_min_order_by({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  }) =>
      InputauthUserAuthenticators_min_order_by._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticators_min_order_by._(this._$data);

  factory InputauthUserAuthenticators_min_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = l$credentialId == null
          ? null
          : fromJson$EnumOrderBy((l$credentialId as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = l$transports == null
          ? null
          : fromJson$EnumOrderBy((l$transports as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserAuthenticators_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  EnumOrderBy? get credentialId => (_$data['credentialId'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get transports => (_$data['transports'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] =
          l$credentialId == null ? null : toJson$EnumOrderBy(l$credentialId);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] =
          l$transports == null ? null : toJson$EnumOrderBy(l$transports);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_min_order_by<
          InputauthUserAuthenticators_min_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_min_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$id = id;
    final l$transports = transports;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_min_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_min_order_by(
    InputauthUserAuthenticators_min_order_by instance,
    TRes Function(InputauthUserAuthenticators_min_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_min_order_by;

  factory CopyWith$InputauthUserAuthenticators_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_min_order_by;

  TRes call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserAuthenticators_min_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_min_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_min_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_min_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticators_min_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (transports != _undefined)
          'transports': (transports as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_min_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_min_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? counter,
    EnumOrderBy? credentialId,
    EnumOrderBy? id,
    EnumOrderBy? transports,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserAuthenticators_stddev_order_by {
  factory InputauthUserAuthenticators_stddev_order_by({EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_stddev_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_stddev_order_by._(this._$data);

  factory InputauthUserAuthenticators_stddev_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_stddev_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_stddev_order_by<
          InputauthUserAuthenticators_stddev_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_stddev_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_stddev_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_stddev_order_by(
    InputauthUserAuthenticators_stddev_order_by instance,
    TRes Function(InputauthUserAuthenticators_stddev_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_stddev_order_by;

  factory CopyWith$InputauthUserAuthenticators_stddev_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_stddev_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_stddev_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_stddev_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_stddev_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_stddev_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_stddev_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_stddev_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_stddev_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_stddev_pop_order_by {
  factory InputauthUserAuthenticators_stddev_pop_order_by(
          {EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_stddev_pop_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_stddev_pop_order_by._(this._$data);

  factory InputauthUserAuthenticators_stddev_pop_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_stddev_pop_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<
          InputauthUserAuthenticators_stddev_pop_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_stddev_pop_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_stddev_pop_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_stddev_pop_order_by(
    InputauthUserAuthenticators_stddev_pop_order_by instance,
    TRes Function(InputauthUserAuthenticators_stddev_pop_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_stddev_pop_order_by;

  factory CopyWith$InputauthUserAuthenticators_stddev_pop_order_by.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_stddev_pop_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_stddev_pop_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_stddev_pop_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_stddev_pop_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_stddev_pop_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_stddev_pop_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_stddev_pop_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_pop_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_stddev_pop_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_stddev_samp_order_by {
  factory InputauthUserAuthenticators_stddev_samp_order_by(
          {EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_stddev_samp_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_stddev_samp_order_by._(this._$data);

  factory InputauthUserAuthenticators_stddev_samp_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_stddev_samp_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<
          InputauthUserAuthenticators_stddev_samp_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_stddev_samp_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_stddev_samp_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_stddev_samp_order_by(
    InputauthUserAuthenticators_stddev_samp_order_by instance,
    TRes Function(InputauthUserAuthenticators_stddev_samp_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_stddev_samp_order_by;

  factory CopyWith$InputauthUserAuthenticators_stddev_samp_order_by.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_stddev_samp_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_stddev_samp_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_stddev_samp_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_stddev_samp_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_stddev_samp_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_stddev_samp_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_stddev_samp_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_stddev_samp_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_stddev_samp_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_streamCursorInput {
  factory InputauthUserAuthenticators_streamCursorInput({
    required InputauthUserAuthenticators_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthUserAuthenticators_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthUserAuthenticators_streamCursorInput._(this._$data);

  factory InputauthUserAuthenticators_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthUserAuthenticators_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthUserAuthenticators_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserAuthenticators_streamCursorValueInput get initialValue =>
      (_$data['initialValue']
          as InputauthUserAuthenticators_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_streamCursorInput<
          InputauthUserAuthenticators_streamCursorInput>
      get copyWith => CopyWith$InputauthUserAuthenticators_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_streamCursorInput<TRes> {
  factory CopyWith$InputauthUserAuthenticators_streamCursorInput(
    InputauthUserAuthenticators_streamCursorInput instance,
    TRes Function(InputauthUserAuthenticators_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_streamCursorInput;

  factory CopyWith$InputauthUserAuthenticators_streamCursorInput.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorInput;

  TRes call({
    InputauthUserAuthenticators_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthUserAuthenticators_streamCursorValueInput<TRes>
      get initialValue;
}

class _CopyWithImpl$InputauthUserAuthenticators_streamCursorInput<TRes>
    implements CopyWith$InputauthUserAuthenticators_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_streamCursorInput _instance;

  final TRes Function(InputauthUserAuthenticators_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthUserAuthenticators_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue': (initialValue
              as InputauthUserAuthenticators_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthUserAuthenticators_streamCursorValueInput<TRes>
      get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthUserAuthenticators_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorInput<TRes>
    implements CopyWith$InputauthUserAuthenticators_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthUserAuthenticators_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticators_streamCursorValueInput<TRes>
      get initialValue =>
          CopyWith$InputauthUserAuthenticators_streamCursorValueInput.stub(
              _res);
}

class InputauthUserAuthenticators_streamCursorValueInput {
  factory InputauthUserAuthenticators_streamCursorValueInput({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  }) =>
      InputauthUserAuthenticators_streamCursorValueInput._({
        if (counter != null) r'counter': counter,
        if (credentialId != null) r'credentialId': credentialId,
        if (credentialPublicKey != null)
          r'credentialPublicKey': credentialPublicKey,
        if (id != null) r'id': id,
        if (transports != null) r'transports': transports,
        if (userId != null) r'userId': userId,
      });

  InputauthUserAuthenticators_streamCursorValueInput._(this._$data);

  factory InputauthUserAuthenticators_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = (l$counter as int?);
    }
    if (data.containsKey('credentialId')) {
      final l$credentialId = data['credentialId'];
      result$data['credentialId'] = (l$credentialId as String?);
    }
    if (data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = data['credentialPublicKey'];
      result$data['credentialPublicKey'] = (l$credentialPublicKey as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('transports')) {
      final l$transports = data['transports'];
      result$data['transports'] = (l$transports as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserAuthenticators_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get counter => (_$data['counter'] as int?);
  String? get credentialId => (_$data['credentialId'] as String?);
  int? get credentialPublicKey => (_$data['credentialPublicKey'] as int?);
  String? get id => (_$data['id'] as String?);
  String? get transports => (_$data['transports'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] = l$counter;
    }
    if (_$data.containsKey('credentialId')) {
      final l$credentialId = credentialId;
      result$data['credentialId'] = l$credentialId;
    }
    if (_$data.containsKey('credentialPublicKey')) {
      final l$credentialPublicKey = credentialPublicKey;
      result$data['credentialPublicKey'] = l$credentialPublicKey;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('transports')) {
      final l$transports = transports;
      result$data['transports'] = l$transports;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_streamCursorValueInput<
          InputauthUserAuthenticators_streamCursorValueInput>
      get copyWith =>
          CopyWith$InputauthUserAuthenticators_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    final l$credentialId = credentialId;
    final lOther$credentialId = other.credentialId;
    if (_$data.containsKey('credentialId') !=
        other._$data.containsKey('credentialId')) {
      return false;
    }
    if (l$credentialId != lOther$credentialId) {
      return false;
    }
    final l$credentialPublicKey = credentialPublicKey;
    final lOther$credentialPublicKey = other.credentialPublicKey;
    if (_$data.containsKey('credentialPublicKey') !=
        other._$data.containsKey('credentialPublicKey')) {
      return false;
    }
    if (l$credentialPublicKey != lOther$credentialPublicKey) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$transports = transports;
    final lOther$transports = other.transports;
    if (_$data.containsKey('transports') !=
        other._$data.containsKey('transports')) {
      return false;
    }
    if (l$transports != lOther$transports) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    final l$credentialId = credentialId;
    final l$credentialPublicKey = credentialPublicKey;
    final l$id = id;
    final l$transports = transports;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('counter') ? l$counter : const {},
      _$data.containsKey('credentialId') ? l$credentialId : const {},
      _$data.containsKey('credentialPublicKey')
          ? l$credentialPublicKey
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('transports') ? l$transports : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_streamCursorValueInput<
    TRes> {
  factory CopyWith$InputauthUserAuthenticators_streamCursorValueInput(
    InputauthUserAuthenticators_streamCursorValueInput instance,
    TRes Function(InputauthUserAuthenticators_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_streamCursorValueInput;

  factory CopyWith$InputauthUserAuthenticators_streamCursorValueInput.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorValueInput;

  TRes call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserAuthenticators_streamCursorValueInput<TRes>
    implements
        CopyWith$InputauthUserAuthenticators_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_streamCursorValueInput _instance;

  final TRes Function(InputauthUserAuthenticators_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? counter = _undefined,
    Object? credentialId = _undefined,
    Object? credentialPublicKey = _undefined,
    Object? id = _undefined,
    Object? transports = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserAuthenticators_streamCursorValueInput._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as int?),
        if (credentialId != _undefined)
          'credentialId': (credentialId as String?),
        if (credentialPublicKey != _undefined)
          'credentialPublicKey': (credentialPublicKey as int?),
        if (id != _undefined) 'id': (id as String?),
        if (transports != _undefined) 'transports': (transports as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorValueInput<TRes>
    implements
        CopyWith$InputauthUserAuthenticators_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_streamCursorValueInput(
      this._res);

  TRes _res;

  call({
    int? counter,
    String? credentialId,
    int? credentialPublicKey,
    String? id,
    String? transports,
    String? userId,
  }) =>
      _res;
}

class InputauthUserAuthenticators_sum_order_by {
  factory InputauthUserAuthenticators_sum_order_by({EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_sum_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_sum_order_by._(this._$data);

  factory InputauthUserAuthenticators_sum_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_sum_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_sum_order_by<
          InputauthUserAuthenticators_sum_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_sum_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_sum_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_sum_order_by(
    InputauthUserAuthenticators_sum_order_by instance,
    TRes Function(InputauthUserAuthenticators_sum_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_sum_order_by;

  factory CopyWith$InputauthUserAuthenticators_sum_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_sum_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_sum_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_sum_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_sum_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_sum_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_sum_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_sum_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_sum_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_sum_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_var_pop_order_by {
  factory InputauthUserAuthenticators_var_pop_order_by(
          {EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_var_pop_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_var_pop_order_by._(this._$data);

  factory InputauthUserAuthenticators_var_pop_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_var_pop_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_var_pop_order_by<
          InputauthUserAuthenticators_var_pop_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_var_pop_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_var_pop_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_var_pop_order_by(
    InputauthUserAuthenticators_var_pop_order_by instance,
    TRes Function(InputauthUserAuthenticators_var_pop_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_var_pop_order_by;

  factory CopyWith$InputauthUserAuthenticators_var_pop_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_var_pop_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_var_pop_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_var_pop_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_var_pop_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_var_pop_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_var_pop_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_var_pop_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_var_pop_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_var_pop_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_var_samp_order_by {
  factory InputauthUserAuthenticators_var_samp_order_by(
          {EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_var_samp_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_var_samp_order_by._(this._$data);

  factory InputauthUserAuthenticators_var_samp_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_var_samp_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_var_samp_order_by<
          InputauthUserAuthenticators_var_samp_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_var_samp_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_var_samp_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_var_samp_order_by(
    InputauthUserAuthenticators_var_samp_order_by instance,
    TRes Function(InputauthUserAuthenticators_var_samp_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_var_samp_order_by;

  factory CopyWith$InputauthUserAuthenticators_var_samp_order_by.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_var_samp_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_var_samp_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_var_samp_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_var_samp_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_var_samp_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_var_samp_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_var_samp_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_var_samp_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_var_samp_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserAuthenticators_variance_order_by {
  factory InputauthUserAuthenticators_variance_order_by(
          {EnumOrderBy? counter}) =>
      InputauthUserAuthenticators_variance_order_by._({
        if (counter != null) r'counter': counter,
      });

  InputauthUserAuthenticators_variance_order_by._(this._$data);

  factory InputauthUserAuthenticators_variance_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('counter')) {
      final l$counter = data['counter'];
      result$data['counter'] = l$counter == null
          ? null
          : fromJson$EnumOrderBy((l$counter as String));
    }
    return InputauthUserAuthenticators_variance_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get counter => (_$data['counter'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('counter')) {
      final l$counter = counter;
      result$data['counter'] =
          l$counter == null ? null : toJson$EnumOrderBy(l$counter);
    }
    return result$data;
  }

  CopyWith$InputauthUserAuthenticators_variance_order_by<
          InputauthUserAuthenticators_variance_order_by>
      get copyWith => CopyWith$InputauthUserAuthenticators_variance_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserAuthenticators_variance_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$counter = counter;
    final lOther$counter = other.counter;
    if (_$data.containsKey('counter') != other._$data.containsKey('counter')) {
      return false;
    }
    if (l$counter != lOther$counter) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$counter = counter;
    return Object.hashAll(
        [_$data.containsKey('counter') ? l$counter : const {}]);
  }
}

abstract class CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> {
  factory CopyWith$InputauthUserAuthenticators_variance_order_by(
    InputauthUserAuthenticators_variance_order_by instance,
    TRes Function(InputauthUserAuthenticators_variance_order_by) then,
  ) = _CopyWithImpl$InputauthUserAuthenticators_variance_order_by;

  factory CopyWith$InputauthUserAuthenticators_variance_order_by.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserAuthenticators_variance_order_by;

  TRes call({EnumOrderBy? counter});
}

class _CopyWithImpl$InputauthUserAuthenticators_variance_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> {
  _CopyWithImpl$InputauthUserAuthenticators_variance_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserAuthenticators_variance_order_by _instance;

  final TRes Function(InputauthUserAuthenticators_variance_order_by) _then;

  static const _undefined = {};

  TRes call({Object? counter = _undefined}) =>
      _then(InputauthUserAuthenticators_variance_order_by._({
        ..._instance._$data,
        if (counter != _undefined) 'counter': (counter as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserAuthenticators_variance_order_by<TRes>
    implements CopyWith$InputauthUserAuthenticators_variance_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserAuthenticators_variance_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? counter}) => _res;
}

class InputauthUserProvidersAggregateOrderBy {
  factory InputauthUserProvidersAggregateOrderBy({
    EnumOrderBy? count,
    InputauthUserProviders_max_order_by? max,
    InputauthUserProviders_min_order_by? min,
  }) =>
      InputauthUserProvidersAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  InputauthUserProvidersAggregateOrderBy._(this._$data);

  factory InputauthUserProvidersAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : InputauthUserProviders_max_order_by.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : InputauthUserProviders_min_order_by.fromJson(
              (l$min as Map<String, dynamic>));
    }
    return InputauthUserProvidersAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  InputauthUserProviders_max_order_by? get max =>
      (_$data['max'] as InputauthUserProviders_max_order_by?);
  InputauthUserProviders_min_order_by? get min =>
      (_$data['min'] as InputauthUserProviders_min_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersAggregateOrderBy<
          InputauthUserProvidersAggregateOrderBy>
      get copyWith => CopyWith$InputauthUserProvidersAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersAggregateOrderBy<TRes> {
  factory CopyWith$InputauthUserProvidersAggregateOrderBy(
    InputauthUserProvidersAggregateOrderBy instance,
    TRes Function(InputauthUserProvidersAggregateOrderBy) then,
  ) = _CopyWithImpl$InputauthUserProvidersAggregateOrderBy;

  factory CopyWith$InputauthUserProvidersAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersAggregateOrderBy;

  TRes call({
    EnumOrderBy? count,
    InputauthUserProviders_max_order_by? max,
    InputauthUserProviders_min_order_by? min,
  });
  CopyWith$InputauthUserProviders_max_order_by<TRes> get max;
  CopyWith$InputauthUserProviders_min_order_by<TRes> get min;
}

class _CopyWithImpl$InputauthUserProvidersAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserProvidersAggregateOrderBy<TRes> {
  _CopyWithImpl$InputauthUserProvidersAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersAggregateOrderBy _instance;

  final TRes Function(InputauthUserProvidersAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(InputauthUserProvidersAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined)
          'max': (max as InputauthUserProviders_max_order_by?),
        if (min != _undefined)
          'min': (min as InputauthUserProviders_min_order_by?),
      }));
  CopyWith$InputauthUserProviders_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$InputauthUserProviders_max_order_by.stub(_then(_instance))
        : CopyWith$InputauthUserProviders_max_order_by(
            local$max, (e) => call(max: e));
  }

  CopyWith$InputauthUserProviders_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$InputauthUserProviders_min_order_by.stub(_then(_instance))
        : CopyWith$InputauthUserProviders_min_order_by(
            local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserProvidersAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersAggregateOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? count,
    InputauthUserProviders_max_order_by? max,
    InputauthUserProviders_min_order_by? min,
  }) =>
      _res;
  CopyWith$InputauthUserProviders_max_order_by<TRes> get max =>
      CopyWith$InputauthUserProviders_max_order_by.stub(_res);
  CopyWith$InputauthUserProviders_min_order_by<TRes> get min =>
      CopyWith$InputauthUserProviders_min_order_by.stub(_res);
}

class InputauthUserProvidersArrRelInsertInput {
  factory InputauthUserProvidersArrRelInsertInput({
    required List<InputauthUserProvidersInsertInput> data,
    InputauthUserProvidersOnConflict? onConflict,
  }) =>
      InputauthUserProvidersArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthUserProvidersArrRelInsertInput._(this._$data);

  factory InputauthUserProvidersArrRelInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => InputauthUserProvidersInsertInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthUserProvidersOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthUserProvidersArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserProvidersInsertInput> get data =>
      (_$data['data'] as List<InputauthUserProvidersInsertInput>);
  InputauthUserProvidersOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthUserProvidersOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersArrRelInsertInput<
          InputauthUserProvidersArrRelInsertInput>
      get copyWith => CopyWith$InputauthUserProvidersArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> {
  factory CopyWith$InputauthUserProvidersArrRelInsertInput(
    InputauthUserProvidersArrRelInsertInput instance,
    TRes Function(InputauthUserProvidersArrRelInsertInput) then,
  ) = _CopyWithImpl$InputauthUserProvidersArrRelInsertInput;

  factory CopyWith$InputauthUserProvidersArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersArrRelInsertInput;

  TRes call({
    List<InputauthUserProvidersInsertInput>? data,
    InputauthUserProvidersOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputauthUserProvidersInsertInput> Function(
              Iterable<
                  CopyWith$InputauthUserProvidersInsertInput<
                      InputauthUserProvidersInsertInput>>)
          _fn);
  CopyWith$InputauthUserProvidersOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthUserProvidersArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> {
  _CopyWithImpl$InputauthUserProvidersArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersArrRelInsertInput _instance;

  final TRes Function(InputauthUserProvidersArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthUserProvidersArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputauthUserProvidersInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthUserProvidersOnConflict?),
      }));
  TRes data(
          Iterable<InputauthUserProvidersInsertInput> Function(
                  Iterable<
                      CopyWith$InputauthUserProvidersInsertInput<
                          InputauthUserProvidersInsertInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$InputauthUserProvidersInsertInput(
                    e,
                    (i) => i,
                  ))).toList());
  CopyWith$InputauthUserProvidersOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthUserProvidersOnConflict.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputauthUserProvidersInsertInput>? data,
    InputauthUserProvidersOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputauthUserProvidersOnConflict<TRes> get onConflict =>
      CopyWith$InputauthUserProvidersOnConflict.stub(_res);
}

class InputauthUserProvidersBoolExp {
  factory InputauthUserProvidersBoolExp({
    List<InputauthUserProvidersBoolExp>? $_and,
    InputauthUserProvidersBoolExp? $_not,
    List<InputauthUserProvidersBoolExp>? $_or,
    InputStringComparisonExp? accessToken,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputauthProvidersBoolExp? provider,
    InputStringComparisonExp? providerId,
    InputStringComparisonExp? providerUserId,
    InputStringComparisonExp? refreshToken,
    InputTimestamptzComparisonExp? updatedAt,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      InputauthUserProvidersBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (provider != null) r'provider': provider,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProvidersBoolExp._(this._$data);

  factory InputauthUserProvidersBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputauthUserProvidersBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthUserProvidersBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputauthUserProvidersBoolExp.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = l$accessToken == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$accessToken as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('provider')) {
      final l$provider = data['provider'];
      result$data['provider'] = l$provider == null
          ? null
          : InputauthProvidersBoolExp.fromJson(
              (l$provider as Map<String, dynamic>));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$providerId as Map<String, dynamic>));
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$providerUserId as Map<String, dynamic>));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$refreshToken as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersBoolExp.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : InputUuidComparisonExp.fromJson((l$userId as Map<String, dynamic>));
    }
    return InputauthUserProvidersBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserProvidersBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthUserProvidersBoolExp>?);
  InputauthUserProvidersBoolExp? get $_not =>
      (_$data['_not'] as InputauthUserProvidersBoolExp?);
  List<InputauthUserProvidersBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthUserProvidersBoolExp>?);
  InputStringComparisonExp? get accessToken =>
      (_$data['accessToken'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputauthProvidersBoolExp? get provider =>
      (_$data['provider'] as InputauthProvidersBoolExp?);
  InputStringComparisonExp? get providerId =>
      (_$data['providerId'] as InputStringComparisonExp?);
  InputStringComparisonExp? get providerUserId =>
      (_$data['providerUserId'] as InputStringComparisonExp?);
  InputStringComparisonExp? get refreshToken =>
      (_$data['refreshToken'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get updatedAt =>
      (_$data['updatedAt'] as InputTimestamptzComparisonExp?);
  InputusersBoolExp? get user => (_$data['user'] as InputusersBoolExp?);
  InputUuidComparisonExp? get userId =>
      (_$data['userId'] as InputUuidComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('provider')) {
      final l$provider = provider;
      result$data['provider'] = l$provider?.toJson();
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId?.toJson();
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId?.toJson();
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersBoolExp<InputauthUserProvidersBoolExp>
      get copyWith => CopyWith$InputauthUserProvidersBoolExp(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$provider = provider;
    final lOther$provider = other.provider;
    if (_$data.containsKey('provider') !=
        other._$data.containsKey('provider')) {
      return false;
    }
    if (l$provider != lOther$provider) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$provider = provider;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('provider') ? l$provider : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersBoolExp<TRes> {
  factory CopyWith$InputauthUserProvidersBoolExp(
    InputauthUserProvidersBoolExp instance,
    TRes Function(InputauthUserProvidersBoolExp) then,
  ) = _CopyWithImpl$InputauthUserProvidersBoolExp;

  factory CopyWith$InputauthUserProvidersBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersBoolExp;

  TRes call({
    List<InputauthUserProvidersBoolExp>? $_and,
    InputauthUserProvidersBoolExp? $_not,
    List<InputauthUserProvidersBoolExp>? $_or,
    InputStringComparisonExp? accessToken,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputauthProvidersBoolExp? provider,
    InputStringComparisonExp? providerId,
    InputStringComparisonExp? providerUserId,
    InputStringComparisonExp? refreshToken,
    InputTimestamptzComparisonExp? updatedAt,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  });
  TRes $_and(
      Iterable<InputauthUserProvidersBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserProvidersBoolExp<
                      InputauthUserProvidersBoolExp>>?)
          _fn);
  CopyWith$InputauthUserProvidersBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthUserProvidersBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserProvidersBoolExp<
                      InputauthUserProvidersBoolExp>>?)
          _fn);
  CopyWith$InputStringComparisonExp<TRes> get accessToken;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputauthProvidersBoolExp<TRes> get provider;
  CopyWith$InputStringComparisonExp<TRes> get providerId;
  CopyWith$InputStringComparisonExp<TRes> get providerUserId;
  CopyWith$InputStringComparisonExp<TRes> get refreshToken;
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt;
  CopyWith$InputusersBoolExp<TRes> get user;
  CopyWith$InputUuidComparisonExp<TRes> get userId;
}

class _CopyWithImpl$InputauthUserProvidersBoolExp<TRes>
    implements CopyWith$InputauthUserProvidersBoolExp<TRes> {
  _CopyWithImpl$InputauthUserProvidersBoolExp(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersBoolExp _instance;

  final TRes Function(InputauthUserProvidersBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? provider = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProvidersBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthUserProvidersBoolExp>?),
        if ($_not != _undefined)
          '_not': ($_not as InputauthUserProvidersBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthUserProvidersBoolExp>?),
        if (accessToken != _undefined)
          'accessToken': (accessToken as InputStringComparisonExp?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (provider != _undefined)
          'provider': (provider as InputauthProvidersBoolExp?),
        if (providerId != _undefined)
          'providerId': (providerId as InputStringComparisonExp?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as InputStringComparisonExp?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as InputStringComparisonExp?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as InputTimestamptzComparisonExp?),
        if (user != _undefined) 'user': (user as InputusersBoolExp?),
        if (userId != _undefined) 'userId': (userId as InputUuidComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputauthUserProvidersBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserProvidersBoolExp<
                          InputauthUserProvidersBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and
              ?.map((e) => CopyWith$InputauthUserProvidersBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthUserProvidersBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthUserProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthUserProvidersBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserProvidersBoolExp<
                          InputauthUserProvidersBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(
              _instance.$_or?.map((e) => CopyWith$InputauthUserProvidersBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputStringComparisonExp<TRes> get accessToken {
    final local$accessToken = _instance.accessToken;
    return local$accessToken == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$accessToken, (e) => call(accessToken: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputauthProvidersBoolExp<TRes> get provider {
    final local$provider = _instance.provider;
    return local$provider == null
        ? CopyWith$InputauthProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthProvidersBoolExp(
            local$provider, (e) => call(provider: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get providerId {
    final local$providerId = _instance.providerId;
    return local$providerId == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$providerId, (e) => call(providerId: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get providerUserId {
    final local$providerUserId = _instance.providerUserId;
    return local$providerUserId == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$providerUserId, (e) => call(providerUserId: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get refreshToken {
    final local$refreshToken = _instance.refreshToken;
    return local$refreshToken == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$refreshToken, (e) => call(refreshToken: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$InputusersBoolExp<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$user, (e) => call(user: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$userId, (e) => call(userId: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersBoolExp<TRes>
    implements CopyWith$InputauthUserProvidersBoolExp<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthUserProvidersBoolExp>? $_and,
    InputauthUserProvidersBoolExp? $_not,
    List<InputauthUserProvidersBoolExp>? $_or,
    InputStringComparisonExp? accessToken,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputauthProvidersBoolExp? provider,
    InputStringComparisonExp? providerId,
    InputStringComparisonExp? providerUserId,
    InputStringComparisonExp? refreshToken,
    InputTimestamptzComparisonExp? updatedAt,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthUserProvidersBoolExp<TRes> get $_not =>
      CopyWith$InputauthUserProvidersBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputStringComparisonExp<TRes> get accessToken =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputauthProvidersBoolExp<TRes> get provider =>
      CopyWith$InputauthProvidersBoolExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get providerId =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get providerUserId =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get refreshToken =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get user =>
      CopyWith$InputusersBoolExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get userId =>
      CopyWith$InputUuidComparisonExp.stub(_res);
}

class InputauthUserProvidersInsertInput {
  factory InputauthUserProvidersInsertInput({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    InputauthProvidersObjRelInsertInput? provider,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      InputauthUserProvidersInsertInput._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (provider != null) r'provider': provider,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProvidersInsertInput._(this._$data);

  factory InputauthUserProvidersInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('provider')) {
      final l$provider = data['provider'];
      result$data['provider'] = l$provider == null
          ? null
          : InputauthProvidersObjRelInsertInput.fromJson(
              (l$provider as Map<String, dynamic>));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = (l$providerId as String?);
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = (l$providerUserId as String?);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersObjRelInsertInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserProvidersInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get accessToken => (_$data['accessToken'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  InputauthProvidersObjRelInsertInput? get provider =>
      (_$data['provider'] as InputauthProvidersObjRelInsertInput?);
  String? get providerId => (_$data['providerId'] as String?);
  String? get providerUserId => (_$data['providerUserId'] as String?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  InputusersObjRelInsertInput? get user =>
      (_$data['user'] as InputusersObjRelInsertInput?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('provider')) {
      final l$provider = provider;
      result$data['provider'] = l$provider?.toJson();
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId;
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId;
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersInsertInput<InputauthUserProvidersInsertInput>
      get copyWith => CopyWith$InputauthUserProvidersInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$provider = provider;
    final lOther$provider = other.provider;
    if (_$data.containsKey('provider') !=
        other._$data.containsKey('provider')) {
      return false;
    }
    if (l$provider != lOther$provider) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$provider = provider;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('provider') ? l$provider : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersInsertInput<TRes> {
  factory CopyWith$InputauthUserProvidersInsertInput(
    InputauthUserProvidersInsertInput instance,
    TRes Function(InputauthUserProvidersInsertInput) then,
  ) = _CopyWithImpl$InputauthUserProvidersInsertInput;

  factory CopyWith$InputauthUserProvidersInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersInsertInput;

  TRes call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    InputauthProvidersObjRelInsertInput? provider,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    InputusersObjRelInsertInput? user,
    String? userId,
  });
  CopyWith$InputauthProvidersObjRelInsertInput<TRes> get provider;
  CopyWith$InputusersObjRelInsertInput<TRes> get user;
}

class _CopyWithImpl$InputauthUserProvidersInsertInput<TRes>
    implements CopyWith$InputauthUserProvidersInsertInput<TRes> {
  _CopyWithImpl$InputauthUserProvidersInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersInsertInput _instance;

  final TRes Function(InputauthUserProvidersInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? provider = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProvidersInsertInput._({
        ..._instance._$data,
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (provider != _undefined)
          'provider': (provider as InputauthProvidersObjRelInsertInput?),
        if (providerId != _undefined) 'providerId': (providerId as String?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as String?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (user != _undefined) 'user': (user as InputusersObjRelInsertInput?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
  CopyWith$InputauthProvidersObjRelInsertInput<TRes> get provider {
    final local$provider = _instance.provider;
    return local$provider == null
        ? CopyWith$InputauthProvidersObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputauthProvidersObjRelInsertInput(
            local$provider, (e) => call(provider: e));
  }

  CopyWith$InputusersObjRelInsertInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputusersObjRelInsertInput(
            local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersInsertInput<TRes>
    implements CopyWith$InputauthUserProvidersInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersInsertInput(this._res);

  TRes _res;

  call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    InputauthProvidersObjRelInsertInput? provider,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      _res;
  CopyWith$InputauthProvidersObjRelInsertInput<TRes> get provider =>
      CopyWith$InputauthProvidersObjRelInsertInput.stub(_res);
  CopyWith$InputusersObjRelInsertInput<TRes> get user =>
      CopyWith$InputusersObjRelInsertInput.stub(_res);
}

class InputauthUserProvidersOnConflict {
  factory InputauthUserProvidersOnConflict({
    required EnumauthUserProvidersConstraint constraint,
    required List<EnumauthUserProvidersUpdateColumn> update_columns,
    InputauthUserProvidersBoolExp? where,
  }) =>
      InputauthUserProvidersOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthUserProvidersOnConflict._(this._$data);

  factory InputauthUserProvidersOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthUserProvidersConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumauthUserProvidersUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthUserProvidersBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthUserProvidersOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthUserProvidersConstraint get constraint =>
      (_$data['constraint'] as EnumauthUserProvidersConstraint);
  List<EnumauthUserProvidersUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthUserProvidersUpdateColumn>);
  InputauthUserProvidersBoolExp? get where =>
      (_$data['where'] as InputauthUserProvidersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthUserProvidersConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthUserProvidersUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersOnConflict<InputauthUserProvidersOnConflict>
      get copyWith => CopyWith$InputauthUserProvidersOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersOnConflict<TRes> {
  factory CopyWith$InputauthUserProvidersOnConflict(
    InputauthUserProvidersOnConflict instance,
    TRes Function(InputauthUserProvidersOnConflict) then,
  ) = _CopyWithImpl$InputauthUserProvidersOnConflict;

  factory CopyWith$InputauthUserProvidersOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersOnConflict;

  TRes call({
    EnumauthUserProvidersConstraint? constraint,
    List<EnumauthUserProvidersUpdateColumn>? update_columns,
    InputauthUserProvidersBoolExp? where,
  });
  CopyWith$InputauthUserProvidersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserProvidersOnConflict<TRes>
    implements CopyWith$InputauthUserProvidersOnConflict<TRes> {
  _CopyWithImpl$InputauthUserProvidersOnConflict(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersOnConflict _instance;

  final TRes Function(InputauthUserProvidersOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserProvidersOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthUserProvidersConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthUserProvidersUpdateColumn>),
        if (where != _undefined)
          'where': (where as InputauthUserProvidersBoolExp?),
      }));
  CopyWith$InputauthUserProvidersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthUserProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersOnConflict<TRes>
    implements CopyWith$InputauthUserProvidersOnConflict<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersOnConflict(this._res);

  TRes _res;

  call({
    EnumauthUserProvidersConstraint? constraint,
    List<EnumauthUserProvidersUpdateColumn>? update_columns,
    InputauthUserProvidersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserProvidersBoolExp<TRes> get where =>
      CopyWith$InputauthUserProvidersBoolExp.stub(_res);
}

class InputauthUserProvidersOrderBy {
  factory InputauthUserProvidersOrderBy({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    InputauthProvidersOrderBy? provider,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      InputauthUserProvidersOrderBy._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (provider != null) r'provider': provider,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProvidersOrderBy._(this._$data);

  factory InputauthUserProvidersOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = l$accessToken == null
          ? null
          : fromJson$EnumOrderBy((l$accessToken as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('provider')) {
      final l$provider = data['provider'];
      result$data['provider'] = l$provider == null
          ? null
          : InputauthProvidersOrderBy.fromJson(
              (l$provider as Map<String, dynamic>));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : fromJson$EnumOrderBy((l$providerId as String));
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : fromJson$EnumOrderBy((l$providerUserId as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersOrderBy.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserProvidersOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get accessToken => (_$data['accessToken'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  InputauthProvidersOrderBy? get provider =>
      (_$data['provider'] as InputauthProvidersOrderBy?);
  EnumOrderBy? get providerId => (_$data['providerId'] as EnumOrderBy?);
  EnumOrderBy? get providerUserId => (_$data['providerUserId'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  InputusersOrderBy? get user => (_$data['user'] as InputusersOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] =
          l$accessToken == null ? null : toJson$EnumOrderBy(l$accessToken);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('provider')) {
      final l$provider = provider;
      result$data['provider'] = l$provider?.toJson();
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] =
          l$providerId == null ? null : toJson$EnumOrderBy(l$providerId);
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : toJson$EnumOrderBy(l$providerUserId);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersOrderBy<InputauthUserProvidersOrderBy>
      get copyWith => CopyWith$InputauthUserProvidersOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$provider = provider;
    final lOther$provider = other.provider;
    if (_$data.containsKey('provider') !=
        other._$data.containsKey('provider')) {
      return false;
    }
    if (l$provider != lOther$provider) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$provider = provider;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('provider') ? l$provider : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersOrderBy<TRes> {
  factory CopyWith$InputauthUserProvidersOrderBy(
    InputauthUserProvidersOrderBy instance,
    TRes Function(InputauthUserProvidersOrderBy) then,
  ) = _CopyWithImpl$InputauthUserProvidersOrderBy;

  factory CopyWith$InputauthUserProvidersOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersOrderBy;

  TRes call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    InputauthProvidersOrderBy? provider,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  });
  CopyWith$InputauthProvidersOrderBy<TRes> get provider;
  CopyWith$InputusersOrderBy<TRes> get user;
}

class _CopyWithImpl$InputauthUserProvidersOrderBy<TRes>
    implements CopyWith$InputauthUserProvidersOrderBy<TRes> {
  _CopyWithImpl$InputauthUserProvidersOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersOrderBy _instance;

  final TRes Function(InputauthUserProvidersOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? provider = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProvidersOrderBy._({
        ..._instance._$data,
        if (accessToken != _undefined)
          'accessToken': (accessToken as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (provider != _undefined)
          'provider': (provider as InputauthProvidersOrderBy?),
        if (providerId != _undefined)
          'providerId': (providerId as EnumOrderBy?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (user != _undefined) 'user': (user as InputusersOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
  CopyWith$InputauthProvidersOrderBy<TRes> get provider {
    final local$provider = _instance.provider;
    return local$provider == null
        ? CopyWith$InputauthProvidersOrderBy.stub(_then(_instance))
        : CopyWith$InputauthProvidersOrderBy(
            local$provider, (e) => call(provider: e));
  }

  CopyWith$InputusersOrderBy<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersOrderBy.stub(_then(_instance))
        : CopyWith$InputusersOrderBy(local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersOrderBy<TRes>
    implements CopyWith$InputauthUserProvidersOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    InputauthProvidersOrderBy? provider,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      _res;
  CopyWith$InputauthProvidersOrderBy<TRes> get provider =>
      CopyWith$InputauthProvidersOrderBy.stub(_res);
  CopyWith$InputusersOrderBy<TRes> get user =>
      CopyWith$InputusersOrderBy.stub(_res);
}

class InputauthUserProvidersPkColumnsInput {
  factory InputauthUserProvidersPkColumnsInput({required String id}) =>
      InputauthUserProvidersPkColumnsInput._({
        r'id': id,
      });

  InputauthUserProvidersPkColumnsInput._(this._$data);

  factory InputauthUserProvidersPkColumnsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputauthUserProvidersPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputauthUserProvidersPkColumnsInput<
          InputauthUserProvidersPkColumnsInput>
      get copyWith => CopyWith$InputauthUserProvidersPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputauthUserProvidersPkColumnsInput<TRes> {
  factory CopyWith$InputauthUserProvidersPkColumnsInput(
    InputauthUserProvidersPkColumnsInput instance,
    TRes Function(InputauthUserProvidersPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthUserProvidersPkColumnsInput;

  factory CopyWith$InputauthUserProvidersPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthUserProvidersPkColumnsInput<TRes>
    implements CopyWith$InputauthUserProvidersPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthUserProvidersPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersPkColumnsInput _instance;

  final TRes Function(InputauthUserProvidersPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthUserProvidersPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputauthUserProvidersPkColumnsInput<TRes>
    implements CopyWith$InputauthUserProvidersPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthUserProvidersSetInput {
  factory InputauthUserProvidersSetInput({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  }) =>
      InputauthUserProvidersSetInput._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProvidersSetInput._(this._$data);

  factory InputauthUserProvidersSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = (l$providerId as String?);
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = (l$providerUserId as String?);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserProvidersSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get accessToken => (_$data['accessToken'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  String? get providerId => (_$data['providerId'] as String?);
  String? get providerUserId => (_$data['providerUserId'] as String?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId;
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId;
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserProvidersSetInput<InputauthUserProvidersSetInput>
      get copyWith => CopyWith$InputauthUserProvidersSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersSetInput<TRes> {
  factory CopyWith$InputauthUserProvidersSetInput(
    InputauthUserProvidersSetInput instance,
    TRes Function(InputauthUserProvidersSetInput) then,
  ) = _CopyWithImpl$InputauthUserProvidersSetInput;

  factory CopyWith$InputauthUserProvidersSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersSetInput;

  TRes call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserProvidersSetInput<TRes>
    implements CopyWith$InputauthUserProvidersSetInput<TRes> {
  _CopyWithImpl$InputauthUserProvidersSetInput(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersSetInput _instance;

  final TRes Function(InputauthUserProvidersSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProvidersSetInput._({
        ..._instance._$data,
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (providerId != _undefined) 'providerId': (providerId as String?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as String?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserProvidersSetInput<TRes>
    implements CopyWith$InputauthUserProvidersSetInput<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersSetInput(this._res);

  TRes _res;

  call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  }) =>
      _res;
}

class InputauthUserProvidersUpdates {
  factory InputauthUserProvidersUpdates({
    InputauthUserProvidersSetInput? $_set,
    required InputauthUserProvidersBoolExp where,
  }) =>
      InputauthUserProvidersUpdates._({
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthUserProvidersUpdates._(this._$data);

  factory InputauthUserProvidersUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthUserProvidersSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] = InputauthUserProvidersBoolExp.fromJson(
        (l$where as Map<String, dynamic>));
    return InputauthUserProvidersUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserProvidersSetInput? get $_set =>
      (_$data['_set'] as InputauthUserProvidersSetInput?);
  InputauthUserProvidersBoolExp get where =>
      (_$data['where'] as InputauthUserProvidersBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthUserProvidersUpdates<InputauthUserProvidersUpdates>
      get copyWith => CopyWith$InputauthUserProvidersUpdates(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProvidersUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthUserProvidersUpdates<TRes> {
  factory CopyWith$InputauthUserProvidersUpdates(
    InputauthUserProvidersUpdates instance,
    TRes Function(InputauthUserProvidersUpdates) then,
  ) = _CopyWithImpl$InputauthUserProvidersUpdates;

  factory CopyWith$InputauthUserProvidersUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProvidersUpdates;

  TRes call({
    InputauthUserProvidersSetInput? $_set,
    InputauthUserProvidersBoolExp? where,
  });
  CopyWith$InputauthUserProvidersSetInput<TRes> get $_set;
  CopyWith$InputauthUserProvidersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserProvidersUpdates<TRes>
    implements CopyWith$InputauthUserProvidersUpdates<TRes> {
  _CopyWithImpl$InputauthUserProvidersUpdates(
    this._instance,
    this._then,
  );

  final InputauthUserProvidersUpdates _instance;

  final TRes Function(InputauthUserProvidersUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserProvidersUpdates._({
        ..._instance._$data,
        if ($_set != _undefined)
          '_set': ($_set as InputauthUserProvidersSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthUserProvidersBoolExp),
      }));
  CopyWith$InputauthUserProvidersSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthUserProvidersSetInput.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthUserProvidersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthUserProvidersBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserProvidersUpdates<TRes>
    implements CopyWith$InputauthUserProvidersUpdates<TRes> {
  _CopyWithStubImpl$InputauthUserProvidersUpdates(this._res);

  TRes _res;

  call({
    InputauthUserProvidersSetInput? $_set,
    InputauthUserProvidersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserProvidersSetInput<TRes> get $_set =>
      CopyWith$InputauthUserProvidersSetInput.stub(_res);
  CopyWith$InputauthUserProvidersBoolExp<TRes> get where =>
      CopyWith$InputauthUserProvidersBoolExp.stub(_res);
}

class InputauthUserProviders_max_order_by {
  factory InputauthUserProviders_max_order_by({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  }) =>
      InputauthUserProviders_max_order_by._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProviders_max_order_by._(this._$data);

  factory InputauthUserProviders_max_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = l$accessToken == null
          ? null
          : fromJson$EnumOrderBy((l$accessToken as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : fromJson$EnumOrderBy((l$providerId as String));
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : fromJson$EnumOrderBy((l$providerUserId as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserProviders_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get accessToken => (_$data['accessToken'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get providerId => (_$data['providerId'] as EnumOrderBy?);
  EnumOrderBy? get providerUserId => (_$data['providerUserId'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] =
          l$accessToken == null ? null : toJson$EnumOrderBy(l$accessToken);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] =
          l$providerId == null ? null : toJson$EnumOrderBy(l$providerId);
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : toJson$EnumOrderBy(l$providerUserId);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserProviders_max_order_by<
          InputauthUserProviders_max_order_by>
      get copyWith => CopyWith$InputauthUserProviders_max_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProviders_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProviders_max_order_by<TRes> {
  factory CopyWith$InputauthUserProviders_max_order_by(
    InputauthUserProviders_max_order_by instance,
    TRes Function(InputauthUserProviders_max_order_by) then,
  ) = _CopyWithImpl$InputauthUserProviders_max_order_by;

  factory CopyWith$InputauthUserProviders_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProviders_max_order_by;

  TRes call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserProviders_max_order_by<TRes>
    implements CopyWith$InputauthUserProviders_max_order_by<TRes> {
  _CopyWithImpl$InputauthUserProviders_max_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserProviders_max_order_by _instance;

  final TRes Function(InputauthUserProviders_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProviders_max_order_by._({
        ..._instance._$data,
        if (accessToken != _undefined)
          'accessToken': (accessToken as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (providerId != _undefined)
          'providerId': (providerId as EnumOrderBy?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserProviders_max_order_by<TRes>
    implements CopyWith$InputauthUserProviders_max_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserProviders_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserProviders_min_order_by {
  factory InputauthUserProviders_min_order_by({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  }) =>
      InputauthUserProviders_min_order_by._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProviders_min_order_by._(this._$data);

  factory InputauthUserProviders_min_order_by.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = l$accessToken == null
          ? null
          : fromJson$EnumOrderBy((l$accessToken as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = l$providerId == null
          ? null
          : fromJson$EnumOrderBy((l$providerId as String));
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : fromJson$EnumOrderBy((l$providerUserId as String));
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = l$refreshToken == null
          ? null
          : fromJson$EnumOrderBy((l$refreshToken as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserProviders_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get accessToken => (_$data['accessToken'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get providerId => (_$data['providerId'] as EnumOrderBy?);
  EnumOrderBy? get providerUserId => (_$data['providerUserId'] as EnumOrderBy?);
  EnumOrderBy? get refreshToken => (_$data['refreshToken'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] =
          l$accessToken == null ? null : toJson$EnumOrderBy(l$accessToken);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] =
          l$providerId == null ? null : toJson$EnumOrderBy(l$providerId);
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId == null
          ? null
          : toJson$EnumOrderBy(l$providerUserId);
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] =
          l$refreshToken == null ? null : toJson$EnumOrderBy(l$refreshToken);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserProviders_min_order_by<
          InputauthUserProviders_min_order_by>
      get copyWith => CopyWith$InputauthUserProviders_min_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProviders_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProviders_min_order_by<TRes> {
  factory CopyWith$InputauthUserProviders_min_order_by(
    InputauthUserProviders_min_order_by instance,
    TRes Function(InputauthUserProviders_min_order_by) then,
  ) = _CopyWithImpl$InputauthUserProviders_min_order_by;

  factory CopyWith$InputauthUserProviders_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProviders_min_order_by;

  TRes call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserProviders_min_order_by<TRes>
    implements CopyWith$InputauthUserProviders_min_order_by<TRes> {
  _CopyWithImpl$InputauthUserProviders_min_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserProviders_min_order_by _instance;

  final TRes Function(InputauthUserProviders_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProviders_min_order_by._({
        ..._instance._$data,
        if (accessToken != _undefined)
          'accessToken': (accessToken as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (providerId != _undefined)
          'providerId': (providerId as EnumOrderBy?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as EnumOrderBy?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserProviders_min_order_by<TRes>
    implements CopyWith$InputauthUserProviders_min_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserProviders_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? accessToken,
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? providerId,
    EnumOrderBy? providerUserId,
    EnumOrderBy? refreshToken,
    EnumOrderBy? updatedAt,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserProviders_streamCursorInput {
  factory InputauthUserProviders_streamCursorInput({
    required InputauthUserProviders_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthUserProviders_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthUserProviders_streamCursorInput._(this._$data);

  factory InputauthUserProviders_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthUserProviders_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthUserProviders_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserProviders_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as InputauthUserProviders_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthUserProviders_streamCursorInput<
          InputauthUserProviders_streamCursorInput>
      get copyWith => CopyWith$InputauthUserProviders_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProviders_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProviders_streamCursorInput<TRes> {
  factory CopyWith$InputauthUserProviders_streamCursorInput(
    InputauthUserProviders_streamCursorInput instance,
    TRes Function(InputauthUserProviders_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthUserProviders_streamCursorInput;

  factory CopyWith$InputauthUserProviders_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserProviders_streamCursorInput;

  TRes call({
    InputauthUserProviders_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthUserProviders_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$InputauthUserProviders_streamCursorInput<TRes>
    implements CopyWith$InputauthUserProviders_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthUserProviders_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthUserProviders_streamCursorInput _instance;

  final TRes Function(InputauthUserProviders_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthUserProviders_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue':
              (initialValue as InputauthUserProviders_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthUserProviders_streamCursorValueInput<TRes>
      get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthUserProviders_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthUserProviders_streamCursorInput<TRes>
    implements CopyWith$InputauthUserProviders_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthUserProviders_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthUserProviders_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthUserProviders_streamCursorValueInput<TRes>
      get initialValue =>
          CopyWith$InputauthUserProviders_streamCursorValueInput.stub(_res);
}

class InputauthUserProviders_streamCursorValueInput {
  factory InputauthUserProviders_streamCursorValueInput({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  }) =>
      InputauthUserProviders_streamCursorValueInput._({
        if (accessToken != null) r'accessToken': accessToken,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (providerId != null) r'providerId': providerId,
        if (providerUserId != null) r'providerUserId': providerUserId,
        if (refreshToken != null) r'refreshToken': refreshToken,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userId != null) r'userId': userId,
      });

  InputauthUserProviders_streamCursorValueInput._(this._$data);

  factory InputauthUserProviders_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('providerId')) {
      final l$providerId = data['providerId'];
      result$data['providerId'] = (l$providerId as String?);
    }
    if (data.containsKey('providerUserId')) {
      final l$providerUserId = data['providerUserId'];
      result$data['providerUserId'] = (l$providerUserId as String?);
    }
    if (data.containsKey('refreshToken')) {
      final l$refreshToken = data['refreshToken'];
      result$data['refreshToken'] = (l$refreshToken as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserProviders_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get accessToken => (_$data['accessToken'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  String? get providerId => (_$data['providerId'] as String?);
  String? get providerUserId => (_$data['providerUserId'] as String?);
  String? get refreshToken => (_$data['refreshToken'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('providerId')) {
      final l$providerId = providerId;
      result$data['providerId'] = l$providerId;
    }
    if (_$data.containsKey('providerUserId')) {
      final l$providerUserId = providerUserId;
      result$data['providerUserId'] = l$providerUserId;
    }
    if (_$data.containsKey('refreshToken')) {
      final l$refreshToken = refreshToken;
      result$data['refreshToken'] = l$refreshToken;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserProviders_streamCursorValueInput<
          InputauthUserProviders_streamCursorValueInput>
      get copyWith => CopyWith$InputauthUserProviders_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserProviders_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$providerId = providerId;
    final lOther$providerId = other.providerId;
    if (_$data.containsKey('providerId') !=
        other._$data.containsKey('providerId')) {
      return false;
    }
    if (l$providerId != lOther$providerId) {
      return false;
    }
    final l$providerUserId = providerUserId;
    final lOther$providerUserId = other.providerUserId;
    if (_$data.containsKey('providerUserId') !=
        other._$data.containsKey('providerUserId')) {
      return false;
    }
    if (l$providerUserId != lOther$providerUserId) {
      return false;
    }
    final l$refreshToken = refreshToken;
    final lOther$refreshToken = other.refreshToken;
    if (_$data.containsKey('refreshToken') !=
        other._$data.containsKey('refreshToken')) {
      return false;
    }
    if (l$refreshToken != lOther$refreshToken) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$providerId = providerId;
    final l$providerUserId = providerUserId;
    final l$refreshToken = refreshToken;
    final l$updatedAt = updatedAt;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('providerId') ? l$providerId : const {},
      _$data.containsKey('providerUserId') ? l$providerUserId : const {},
      _$data.containsKey('refreshToken') ? l$refreshToken : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserProviders_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthUserProviders_streamCursorValueInput(
    InputauthUserProviders_streamCursorValueInput instance,
    TRes Function(InputauthUserProviders_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthUserProviders_streamCursorValueInput;

  factory CopyWith$InputauthUserProviders_streamCursorValueInput.stub(
          TRes res) =
      _CopyWithStubImpl$InputauthUserProviders_streamCursorValueInput;

  TRes call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserProviders_streamCursorValueInput<TRes>
    implements CopyWith$InputauthUserProviders_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthUserProviders_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthUserProviders_streamCursorValueInput _instance;

  final TRes Function(InputauthUserProviders_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? accessToken = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? providerId = _undefined,
    Object? providerUserId = _undefined,
    Object? refreshToken = _undefined,
    Object? updatedAt = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserProviders_streamCursorValueInput._({
        ..._instance._$data,
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (providerId != _undefined) 'providerId': (providerId as String?),
        if (providerUserId != _undefined)
          'providerUserId': (providerUserId as String?),
        if (refreshToken != _undefined)
          'refreshToken': (refreshToken as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserProviders_streamCursorValueInput<TRes>
    implements CopyWith$InputauthUserProviders_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthUserProviders_streamCursorValueInput(this._res);

  TRes _res;

  call({
    String? accessToken,
    DateTime? createdAt,
    String? id,
    String? providerId,
    String? providerUserId,
    String? refreshToken,
    DateTime? updatedAt,
    String? userId,
  }) =>
      _res;
}

class InputauthUserRolesAggregateOrderBy {
  factory InputauthUserRolesAggregateOrderBy({
    EnumOrderBy? count,
    InputauthUserRoles_max_order_by? max,
    InputauthUserRoles_min_order_by? min,
  }) =>
      InputauthUserRolesAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  InputauthUserRolesAggregateOrderBy._(this._$data);

  factory InputauthUserRolesAggregateOrderBy.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : InputauthUserRoles_max_order_by.fromJson(
              (l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : InputauthUserRoles_min_order_by.fromJson(
              (l$min as Map<String, dynamic>));
    }
    return InputauthUserRolesAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  InputauthUserRoles_max_order_by? get max =>
      (_$data['max'] as InputauthUserRoles_max_order_by?);
  InputauthUserRoles_min_order_by? get min =>
      (_$data['min'] as InputauthUserRoles_min_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesAggregateOrderBy<
          InputauthUserRolesAggregateOrderBy>
      get copyWith => CopyWith$InputauthUserRolesAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesAggregateOrderBy<TRes> {
  factory CopyWith$InputauthUserRolesAggregateOrderBy(
    InputauthUserRolesAggregateOrderBy instance,
    TRes Function(InputauthUserRolesAggregateOrderBy) then,
  ) = _CopyWithImpl$InputauthUserRolesAggregateOrderBy;

  factory CopyWith$InputauthUserRolesAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesAggregateOrderBy;

  TRes call({
    EnumOrderBy? count,
    InputauthUserRoles_max_order_by? max,
    InputauthUserRoles_min_order_by? min,
  });
  CopyWith$InputauthUserRoles_max_order_by<TRes> get max;
  CopyWith$InputauthUserRoles_min_order_by<TRes> get min;
}

class _CopyWithImpl$InputauthUserRolesAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserRolesAggregateOrderBy<TRes> {
  _CopyWithImpl$InputauthUserRolesAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserRolesAggregateOrderBy _instance;

  final TRes Function(InputauthUserRolesAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(InputauthUserRolesAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined) 'max': (max as InputauthUserRoles_max_order_by?),
        if (min != _undefined) 'min': (min as InputauthUserRoles_min_order_by?),
      }));
  CopyWith$InputauthUserRoles_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$InputauthUserRoles_max_order_by.stub(_then(_instance))
        : CopyWith$InputauthUserRoles_max_order_by(
            local$max, (e) => call(max: e));
  }

  CopyWith$InputauthUserRoles_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$InputauthUserRoles_min_order_by.stub(_then(_instance))
        : CopyWith$InputauthUserRoles_min_order_by(
            local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesAggregateOrderBy<TRes>
    implements CopyWith$InputauthUserRolesAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserRolesAggregateOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? count,
    InputauthUserRoles_max_order_by? max,
    InputauthUserRoles_min_order_by? min,
  }) =>
      _res;
  CopyWith$InputauthUserRoles_max_order_by<TRes> get max =>
      CopyWith$InputauthUserRoles_max_order_by.stub(_res);
  CopyWith$InputauthUserRoles_min_order_by<TRes> get min =>
      CopyWith$InputauthUserRoles_min_order_by.stub(_res);
}

class InputauthUserRolesArrRelInsertInput {
  factory InputauthUserRolesArrRelInsertInput({
    required List<InputauthUserRolesInsertInput> data,
    InputauthUserRolesOnConflict? onConflict,
  }) =>
      InputauthUserRolesArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputauthUserRolesArrRelInsertInput._(this._$data);

  factory InputauthUserRolesArrRelInsertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) =>
            InputauthUserRolesInsertInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputauthUserRolesOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputauthUserRolesArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserRolesInsertInput> get data =>
      (_$data['data'] as List<InputauthUserRolesInsertInput>);
  InputauthUserRolesOnConflict? get onConflict =>
      (_$data['onConflict'] as InputauthUserRolesOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesArrRelInsertInput<
          InputauthUserRolesArrRelInsertInput>
      get copyWith => CopyWith$InputauthUserRolesArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesArrRelInsertInput<TRes> {
  factory CopyWith$InputauthUserRolesArrRelInsertInput(
    InputauthUserRolesArrRelInsertInput instance,
    TRes Function(InputauthUserRolesArrRelInsertInput) then,
  ) = _CopyWithImpl$InputauthUserRolesArrRelInsertInput;

  factory CopyWith$InputauthUserRolesArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesArrRelInsertInput;

  TRes call({
    List<InputauthUserRolesInsertInput>? data,
    InputauthUserRolesOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputauthUserRolesInsertInput> Function(
              Iterable<
                  CopyWith$InputauthUserRolesInsertInput<
                      InputauthUserRolesInsertInput>>)
          _fn);
  CopyWith$InputauthUserRolesOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputauthUserRolesArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserRolesArrRelInsertInput<TRes> {
  _CopyWithImpl$InputauthUserRolesArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserRolesArrRelInsertInput _instance;

  final TRes Function(InputauthUserRolesArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputauthUserRolesArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputauthUserRolesInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputauthUserRolesOnConflict?),
      }));
  TRes data(
          Iterable<InputauthUserRolesInsertInput> Function(
                  Iterable<
                      CopyWith$InputauthUserRolesInsertInput<
                          InputauthUserRolesInsertInput>>)
              _fn) =>
      call(
          data: _fn(
              _instance.data.map((e) => CopyWith$InputauthUserRolesInsertInput(
                    e,
                    (i) => i,
                  ))).toList());
  CopyWith$InputauthUserRolesOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputauthUserRolesOnConflict.stub(_then(_instance))
        : CopyWith$InputauthUserRolesOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesArrRelInsertInput<TRes>
    implements CopyWith$InputauthUserRolesArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserRolesArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputauthUserRolesInsertInput>? data,
    InputauthUserRolesOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputauthUserRolesOnConflict<TRes> get onConflict =>
      CopyWith$InputauthUserRolesOnConflict.stub(_res);
}

class InputauthUserRolesBoolExp {
  factory InputauthUserRolesBoolExp({
    List<InputauthUserRolesBoolExp>? $_and,
    InputauthUserRolesBoolExp? $_not,
    List<InputauthUserRolesBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? role,
    InputauthRolesBoolExp? roleByRole,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      InputauthUserRolesBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (roleByRole != null) r'roleByRole': roleByRole,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRolesBoolExp._(this._$data);

  factory InputauthUserRolesBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) =>
              InputauthUserRolesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputauthUserRolesBoolExp.fromJson(
              (l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) =>
              InputauthUserRolesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : InputStringComparisonExp.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('roleByRole')) {
      final l$roleByRole = data['roleByRole'];
      result$data['roleByRole'] = l$roleByRole == null
          ? null
          : InputauthRolesBoolExp.fromJson(
              (l$roleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersBoolExp.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : InputUuidComparisonExp.fromJson((l$userId as Map<String, dynamic>));
    }
    return InputauthUserRolesBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputauthUserRolesBoolExp>? get $_and =>
      (_$data['_and'] as List<InputauthUserRolesBoolExp>?);
  InputauthUserRolesBoolExp? get $_not =>
      (_$data['_not'] as InputauthUserRolesBoolExp?);
  List<InputauthUserRolesBoolExp>? get $_or =>
      (_$data['_or'] as List<InputauthUserRolesBoolExp>?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputStringComparisonExp? get role =>
      (_$data['role'] as InputStringComparisonExp?);
  InputauthRolesBoolExp? get roleByRole =>
      (_$data['roleByRole'] as InputauthRolesBoolExp?);
  InputusersBoolExp? get user => (_$data['user'] as InputusersBoolExp?);
  InputUuidComparisonExp? get userId =>
      (_$data['userId'] as InputUuidComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('roleByRole')) {
      final l$roleByRole = roleByRole;
      result$data['roleByRole'] = l$roleByRole?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesBoolExp<InputauthUserRolesBoolExp> get copyWith =>
      CopyWith$InputauthUserRolesBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesBoolExp) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleByRole = roleByRole;
    final lOther$roleByRole = other.roleByRole;
    if (_$data.containsKey('roleByRole') !=
        other._$data.containsKey('roleByRole')) {
      return false;
    }
    if (l$roleByRole != lOther$roleByRole) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$roleByRole = roleByRole;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleByRole') ? l$roleByRole : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesBoolExp<TRes> {
  factory CopyWith$InputauthUserRolesBoolExp(
    InputauthUserRolesBoolExp instance,
    TRes Function(InputauthUserRolesBoolExp) then,
  ) = _CopyWithImpl$InputauthUserRolesBoolExp;

  factory CopyWith$InputauthUserRolesBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesBoolExp;

  TRes call({
    List<InputauthUserRolesBoolExp>? $_and,
    InputauthUserRolesBoolExp? $_not,
    List<InputauthUserRolesBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? role,
    InputauthRolesBoolExp? roleByRole,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  });
  TRes $_and(
      Iterable<InputauthUserRolesBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserRolesBoolExp<
                      InputauthUserRolesBoolExp>>?)
          _fn);
  CopyWith$InputauthUserRolesBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputauthUserRolesBoolExp>? Function(
              Iterable<
                  CopyWith$InputauthUserRolesBoolExp<
                      InputauthUserRolesBoolExp>>?)
          _fn);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputStringComparisonExp<TRes> get role;
  CopyWith$InputauthRolesBoolExp<TRes> get roleByRole;
  CopyWith$InputusersBoolExp<TRes> get user;
  CopyWith$InputUuidComparisonExp<TRes> get userId;
}

class _CopyWithImpl$InputauthUserRolesBoolExp<TRes>
    implements CopyWith$InputauthUserRolesBoolExp<TRes> {
  _CopyWithImpl$InputauthUserRolesBoolExp(
    this._instance,
    this._then,
  );

  final InputauthUserRolesBoolExp _instance;

  final TRes Function(InputauthUserRolesBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? roleByRole = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRolesBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined)
          '_and': ($_and as List<InputauthUserRolesBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputauthUserRolesBoolExp?),
        if ($_or != _undefined)
          '_or': ($_or as List<InputauthUserRolesBoolExp>?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (role != _undefined) 'role': (role as InputStringComparisonExp?),
        if (roleByRole != _undefined)
          'roleByRole': (roleByRole as InputauthRolesBoolExp?),
        if (user != _undefined) 'user': (user as InputusersBoolExp?),
        if (userId != _undefined) 'userId': (userId as InputUuidComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputauthUserRolesBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserRolesBoolExp<
                          InputauthUserRolesBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(
              _instance.$_and?.map((e) => CopyWith$InputauthUserRolesBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputauthUserRolesBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputauthUserRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserRolesBoolExp(
            local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputauthUserRolesBoolExp>? Function(
                  Iterable<
                      CopyWith$InputauthUserRolesBoolExp<
                          InputauthUserRolesBoolExp>>?)
              _fn) =>
      call(
          $_or:
              _fn(_instance.$_or?.map((e) => CopyWith$InputauthUserRolesBoolExp(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$role, (e) => call(role: e));
  }

  CopyWith$InputauthRolesBoolExp<TRes> get roleByRole {
    final local$roleByRole = _instance.roleByRole;
    return local$roleByRole == null
        ? CopyWith$InputauthRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRolesBoolExp(
            local$roleByRole, (e) => call(roleByRole: e));
  }

  CopyWith$InputusersBoolExp<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$user, (e) => call(user: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$userId, (e) => call(userId: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesBoolExp<TRes>
    implements CopyWith$InputauthUserRolesBoolExp<TRes> {
  _CopyWithStubImpl$InputauthUserRolesBoolExp(this._res);

  TRes _res;

  call({
    List<InputauthUserRolesBoolExp>? $_and,
    InputauthUserRolesBoolExp? $_not,
    List<InputauthUserRolesBoolExp>? $_or,
    InputTimestamptzComparisonExp? createdAt,
    InputUuidComparisonExp? id,
    InputStringComparisonExp? role,
    InputauthRolesBoolExp? roleByRole,
    InputusersBoolExp? user,
    InputUuidComparisonExp? userId,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputauthUserRolesBoolExp<TRes> get $_not =>
      CopyWith$InputauthUserRolesBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get role =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputauthRolesBoolExp<TRes> get roleByRole =>
      CopyWith$InputauthRolesBoolExp.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get user =>
      CopyWith$InputusersBoolExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get userId =>
      CopyWith$InputUuidComparisonExp.stub(_res);
}

class InputauthUserRolesInsertInput {
  factory InputauthUserRolesInsertInput({
    DateTime? createdAt,
    String? id,
    String? role,
    InputauthRolesObjRelInsertInput? roleByRole,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      InputauthUserRolesInsertInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (roleByRole != null) r'roleByRole': roleByRole,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRolesInsertInput._(this._$data);

  factory InputauthUserRolesInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('roleByRole')) {
      final l$roleByRole = data['roleByRole'];
      result$data['roleByRole'] = l$roleByRole == null
          ? null
          : InputauthRolesObjRelInsertInput.fromJson(
              (l$roleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersObjRelInsertInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserRolesInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  String? get role => (_$data['role'] as String?);
  InputauthRolesObjRelInsertInput? get roleByRole =>
      (_$data['roleByRole'] as InputauthRolesObjRelInsertInput?);
  InputusersObjRelInsertInput? get user =>
      (_$data['user'] as InputusersObjRelInsertInput?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('roleByRole')) {
      final l$roleByRole = roleByRole;
      result$data['roleByRole'] = l$roleByRole?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesInsertInput<InputauthUserRolesInsertInput>
      get copyWith => CopyWith$InputauthUserRolesInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleByRole = roleByRole;
    final lOther$roleByRole = other.roleByRole;
    if (_$data.containsKey('roleByRole') !=
        other._$data.containsKey('roleByRole')) {
      return false;
    }
    if (l$roleByRole != lOther$roleByRole) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$roleByRole = roleByRole;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleByRole') ? l$roleByRole : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesInsertInput<TRes> {
  factory CopyWith$InputauthUserRolesInsertInput(
    InputauthUserRolesInsertInput instance,
    TRes Function(InputauthUserRolesInsertInput) then,
  ) = _CopyWithImpl$InputauthUserRolesInsertInput;

  factory CopyWith$InputauthUserRolesInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesInsertInput;

  TRes call({
    DateTime? createdAt,
    String? id,
    String? role,
    InputauthRolesObjRelInsertInput? roleByRole,
    InputusersObjRelInsertInput? user,
    String? userId,
  });
  CopyWith$InputauthRolesObjRelInsertInput<TRes> get roleByRole;
  CopyWith$InputusersObjRelInsertInput<TRes> get user;
}

class _CopyWithImpl$InputauthUserRolesInsertInput<TRes>
    implements CopyWith$InputauthUserRolesInsertInput<TRes> {
  _CopyWithImpl$InputauthUserRolesInsertInput(
    this._instance,
    this._then,
  );

  final InputauthUserRolesInsertInput _instance;

  final TRes Function(InputauthUserRolesInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? roleByRole = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRolesInsertInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (role != _undefined) 'role': (role as String?),
        if (roleByRole != _undefined)
          'roleByRole': (roleByRole as InputauthRolesObjRelInsertInput?),
        if (user != _undefined) 'user': (user as InputusersObjRelInsertInput?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
  CopyWith$InputauthRolesObjRelInsertInput<TRes> get roleByRole {
    final local$roleByRole = _instance.roleByRole;
    return local$roleByRole == null
        ? CopyWith$InputauthRolesObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputauthRolesObjRelInsertInput(
            local$roleByRole, (e) => call(roleByRole: e));
  }

  CopyWith$InputusersObjRelInsertInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputusersObjRelInsertInput(
            local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesInsertInput<TRes>
    implements CopyWith$InputauthUserRolesInsertInput<TRes> {
  _CopyWithStubImpl$InputauthUserRolesInsertInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    String? id,
    String? role,
    InputauthRolesObjRelInsertInput? roleByRole,
    InputusersObjRelInsertInput? user,
    String? userId,
  }) =>
      _res;
  CopyWith$InputauthRolesObjRelInsertInput<TRes> get roleByRole =>
      CopyWith$InputauthRolesObjRelInsertInput.stub(_res);
  CopyWith$InputusersObjRelInsertInput<TRes> get user =>
      CopyWith$InputusersObjRelInsertInput.stub(_res);
}

class InputauthUserRolesOnConflict {
  factory InputauthUserRolesOnConflict({
    required EnumauthUserRolesConstraint constraint,
    required List<EnumauthUserRolesUpdateColumn> update_columns,
    InputauthUserRolesBoolExp? where,
  }) =>
      InputauthUserRolesOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputauthUserRolesOnConflict._(this._$data);

  factory InputauthUserRolesOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumauthUserRolesConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumauthUserRolesUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputauthUserRolesBoolExp.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return InputauthUserRolesOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumauthUserRolesConstraint get constraint =>
      (_$data['constraint'] as EnumauthUserRolesConstraint);
  List<EnumauthUserRolesUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumauthUserRolesUpdateColumn>);
  InputauthUserRolesBoolExp? get where =>
      (_$data['where'] as InputauthUserRolesBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] =
        toJson$EnumauthUserRolesConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] = l$update_columns
        .map((e) => toJson$EnumauthUserRolesUpdateColumn(e))
        .toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesOnConflict<InputauthUserRolesOnConflict>
      get copyWith => CopyWith$InputauthUserRolesOnConflict(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesOnConflict<TRes> {
  factory CopyWith$InputauthUserRolesOnConflict(
    InputauthUserRolesOnConflict instance,
    TRes Function(InputauthUserRolesOnConflict) then,
  ) = _CopyWithImpl$InputauthUserRolesOnConflict;

  factory CopyWith$InputauthUserRolesOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesOnConflict;

  TRes call({
    EnumauthUserRolesConstraint? constraint,
    List<EnumauthUserRolesUpdateColumn>? update_columns,
    InputauthUserRolesBoolExp? where,
  });
  CopyWith$InputauthUserRolesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserRolesOnConflict<TRes>
    implements CopyWith$InputauthUserRolesOnConflict<TRes> {
  _CopyWithImpl$InputauthUserRolesOnConflict(
    this._instance,
    this._then,
  );

  final InputauthUserRolesOnConflict _instance;

  final TRes Function(InputauthUserRolesOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserRolesOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumauthUserRolesConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns':
              (update_columns as List<EnumauthUserRolesUpdateColumn>),
        if (where != _undefined) 'where': (where as InputauthUserRolesBoolExp?),
      }));
  CopyWith$InputauthUserRolesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputauthUserRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserRolesBoolExp(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesOnConflict<TRes>
    implements CopyWith$InputauthUserRolesOnConflict<TRes> {
  _CopyWithStubImpl$InputauthUserRolesOnConflict(this._res);

  TRes _res;

  call({
    EnumauthUserRolesConstraint? constraint,
    List<EnumauthUserRolesUpdateColumn>? update_columns,
    InputauthUserRolesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserRolesBoolExp<TRes> get where =>
      CopyWith$InputauthUserRolesBoolExp.stub(_res);
}

class InputauthUserRolesOrderBy {
  factory InputauthUserRolesOrderBy({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    InputauthRolesOrderBy? roleByRole,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      InputauthUserRolesOrderBy._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (roleByRole != null) r'roleByRole': roleByRole,
        if (user != null) r'user': user,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRolesOrderBy._(this._$data);

  factory InputauthUserRolesOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$EnumOrderBy((l$role as String));
    }
    if (data.containsKey('roleByRole')) {
      final l$roleByRole = data['roleByRole'];
      result$data['roleByRole'] = l$roleByRole == null
          ? null
          : InputauthRolesOrderBy.fromJson(
              (l$roleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : InputusersOrderBy.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserRolesOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get role => (_$data['role'] as EnumOrderBy?);
  InputauthRolesOrderBy? get roleByRole =>
      (_$data['roleByRole'] as InputauthRolesOrderBy?);
  InputusersOrderBy? get user => (_$data['user'] as InputusersOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null ? null : toJson$EnumOrderBy(l$role);
    }
    if (_$data.containsKey('roleByRole')) {
      final l$roleByRole = roleByRole;
      result$data['roleByRole'] = l$roleByRole?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesOrderBy<InputauthUserRolesOrderBy> get copyWith =>
      CopyWith$InputauthUserRolesOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$roleByRole = roleByRole;
    final lOther$roleByRole = other.roleByRole;
    if (_$data.containsKey('roleByRole') !=
        other._$data.containsKey('roleByRole')) {
      return false;
    }
    if (l$roleByRole != lOther$roleByRole) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$roleByRole = roleByRole;
    final l$user = user;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('roleByRole') ? l$roleByRole : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesOrderBy<TRes> {
  factory CopyWith$InputauthUserRolesOrderBy(
    InputauthUserRolesOrderBy instance,
    TRes Function(InputauthUserRolesOrderBy) then,
  ) = _CopyWithImpl$InputauthUserRolesOrderBy;

  factory CopyWith$InputauthUserRolesOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesOrderBy;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    InputauthRolesOrderBy? roleByRole,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  });
  CopyWith$InputauthRolesOrderBy<TRes> get roleByRole;
  CopyWith$InputusersOrderBy<TRes> get user;
}

class _CopyWithImpl$InputauthUserRolesOrderBy<TRes>
    implements CopyWith$InputauthUserRolesOrderBy<TRes> {
  _CopyWithImpl$InputauthUserRolesOrderBy(
    this._instance,
    this._then,
  );

  final InputauthUserRolesOrderBy _instance;

  final TRes Function(InputauthUserRolesOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? roleByRole = _undefined,
    Object? user = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRolesOrderBy._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (role != _undefined) 'role': (role as EnumOrderBy?),
        if (roleByRole != _undefined)
          'roleByRole': (roleByRole as InputauthRolesOrderBy?),
        if (user != _undefined) 'user': (user as InputusersOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
  CopyWith$InputauthRolesOrderBy<TRes> get roleByRole {
    final local$roleByRole = _instance.roleByRole;
    return local$roleByRole == null
        ? CopyWith$InputauthRolesOrderBy.stub(_then(_instance))
        : CopyWith$InputauthRolesOrderBy(
            local$roleByRole, (e) => call(roleByRole: e));
  }

  CopyWith$InputusersOrderBy<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$InputusersOrderBy.stub(_then(_instance))
        : CopyWith$InputusersOrderBy(local$user, (e) => call(user: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesOrderBy<TRes>
    implements CopyWith$InputauthUserRolesOrderBy<TRes> {
  _CopyWithStubImpl$InputauthUserRolesOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    InputauthRolesOrderBy? roleByRole,
    InputusersOrderBy? user,
    EnumOrderBy? userId,
  }) =>
      _res;
  CopyWith$InputauthRolesOrderBy<TRes> get roleByRole =>
      CopyWith$InputauthRolesOrderBy.stub(_res);
  CopyWith$InputusersOrderBy<TRes> get user =>
      CopyWith$InputusersOrderBy.stub(_res);
}

class InputauthUserRolesPkColumnsInput {
  factory InputauthUserRolesPkColumnsInput({required String id}) =>
      InputauthUserRolesPkColumnsInput._({
        r'id': id,
      });

  InputauthUserRolesPkColumnsInput._(this._$data);

  factory InputauthUserRolesPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputauthUserRolesPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputauthUserRolesPkColumnsInput<InputauthUserRolesPkColumnsInput>
      get copyWith => CopyWith$InputauthUserRolesPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputauthUserRolesPkColumnsInput<TRes> {
  factory CopyWith$InputauthUserRolesPkColumnsInput(
    InputauthUserRolesPkColumnsInput instance,
    TRes Function(InputauthUserRolesPkColumnsInput) then,
  ) = _CopyWithImpl$InputauthUserRolesPkColumnsInput;

  factory CopyWith$InputauthUserRolesPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputauthUserRolesPkColumnsInput<TRes>
    implements CopyWith$InputauthUserRolesPkColumnsInput<TRes> {
  _CopyWithImpl$InputauthUserRolesPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputauthUserRolesPkColumnsInput _instance;

  final TRes Function(InputauthUserRolesPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) =>
      _then(InputauthUserRolesPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputauthUserRolesPkColumnsInput<TRes>
    implements CopyWith$InputauthUserRolesPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputauthUserRolesPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputauthUserRolesSetInput {
  factory InputauthUserRolesSetInput({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  }) =>
      InputauthUserRolesSetInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRolesSetInput._(this._$data);

  factory InputauthUserRolesSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserRolesSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  String? get role => (_$data['role'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserRolesSetInput<InputauthUserRolesSetInput>
      get copyWith => CopyWith$InputauthUserRolesSetInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesSetInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesSetInput<TRes> {
  factory CopyWith$InputauthUserRolesSetInput(
    InputauthUserRolesSetInput instance,
    TRes Function(InputauthUserRolesSetInput) then,
  ) = _CopyWithImpl$InputauthUserRolesSetInput;

  factory CopyWith$InputauthUserRolesSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesSetInput;

  TRes call({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserRolesSetInput<TRes>
    implements CopyWith$InputauthUserRolesSetInput<TRes> {
  _CopyWithImpl$InputauthUserRolesSetInput(
    this._instance,
    this._then,
  );

  final InputauthUserRolesSetInput _instance;

  final TRes Function(InputauthUserRolesSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRolesSetInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (role != _undefined) 'role': (role as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserRolesSetInput<TRes>
    implements CopyWith$InputauthUserRolesSetInput<TRes> {
  _CopyWithStubImpl$InputauthUserRolesSetInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  }) =>
      _res;
}

class InputauthUserRolesUpdates {
  factory InputauthUserRolesUpdates({
    InputauthUserRolesSetInput? $_set,
    required InputauthUserRolesBoolExp where,
  }) =>
      InputauthUserRolesUpdates._({
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputauthUserRolesUpdates._(this._$data);

  factory InputauthUserRolesUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputauthUserRolesSetInput.fromJson(
              (l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputauthUserRolesBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputauthUserRolesUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserRolesSetInput? get $_set =>
      (_$data['_set'] as InputauthUserRolesSetInput?);
  InputauthUserRolesBoolExp get where =>
      (_$data['where'] as InputauthUserRolesBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputauthUserRolesUpdates<InputauthUserRolesUpdates> get copyWith =>
      CopyWith$InputauthUserRolesUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRolesUpdates) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputauthUserRolesUpdates<TRes> {
  factory CopyWith$InputauthUserRolesUpdates(
    InputauthUserRolesUpdates instance,
    TRes Function(InputauthUserRolesUpdates) then,
  ) = _CopyWithImpl$InputauthUserRolesUpdates;

  factory CopyWith$InputauthUserRolesUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRolesUpdates;

  TRes call({
    InputauthUserRolesSetInput? $_set,
    InputauthUserRolesBoolExp? where,
  });
  CopyWith$InputauthUserRolesSetInput<TRes> get $_set;
  CopyWith$InputauthUserRolesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputauthUserRolesUpdates<TRes>
    implements CopyWith$InputauthUserRolesUpdates<TRes> {
  _CopyWithImpl$InputauthUserRolesUpdates(
    this._instance,
    this._then,
  );

  final InputauthUserRolesUpdates _instance;

  final TRes Function(InputauthUserRolesUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputauthUserRolesUpdates._({
        ..._instance._$data,
        if ($_set != _undefined) '_set': ($_set as InputauthUserRolesSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputauthUserRolesBoolExp),
      }));
  CopyWith$InputauthUserRolesSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputauthUserRolesSetInput.stub(_then(_instance))
        : CopyWith$InputauthUserRolesSetInput(
            local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputauthUserRolesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputauthUserRolesBoolExp(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputauthUserRolesUpdates<TRes>
    implements CopyWith$InputauthUserRolesUpdates<TRes> {
  _CopyWithStubImpl$InputauthUserRolesUpdates(this._res);

  TRes _res;

  call({
    InputauthUserRolesSetInput? $_set,
    InputauthUserRolesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputauthUserRolesSetInput<TRes> get $_set =>
      CopyWith$InputauthUserRolesSetInput.stub(_res);
  CopyWith$InputauthUserRolesBoolExp<TRes> get where =>
      CopyWith$InputauthUserRolesBoolExp.stub(_res);
}

class InputauthUserRoles_max_order_by {
  factory InputauthUserRoles_max_order_by({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  }) =>
      InputauthUserRoles_max_order_by._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRoles_max_order_by._(this._$data);

  factory InputauthUserRoles_max_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$EnumOrderBy((l$role as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserRoles_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get role => (_$data['role'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null ? null : toJson$EnumOrderBy(l$role);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserRoles_max_order_by<InputauthUserRoles_max_order_by>
      get copyWith => CopyWith$InputauthUserRoles_max_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRoles_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRoles_max_order_by<TRes> {
  factory CopyWith$InputauthUserRoles_max_order_by(
    InputauthUserRoles_max_order_by instance,
    TRes Function(InputauthUserRoles_max_order_by) then,
  ) = _CopyWithImpl$InputauthUserRoles_max_order_by;

  factory CopyWith$InputauthUserRoles_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRoles_max_order_by;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserRoles_max_order_by<TRes>
    implements CopyWith$InputauthUserRoles_max_order_by<TRes> {
  _CopyWithImpl$InputauthUserRoles_max_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserRoles_max_order_by _instance;

  final TRes Function(InputauthUserRoles_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRoles_max_order_by._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (role != _undefined) 'role': (role as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserRoles_max_order_by<TRes>
    implements CopyWith$InputauthUserRoles_max_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserRoles_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserRoles_min_order_by {
  factory InputauthUserRoles_min_order_by({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  }) =>
      InputauthUserRoles_min_order_by._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRoles_min_order_by._(this._$data);

  factory InputauthUserRoles_min_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$EnumOrderBy((l$role as String));
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] =
          l$userId == null ? null : fromJson$EnumOrderBy((l$userId as String));
    }
    return InputauthUserRoles_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get role => (_$data['role'] as EnumOrderBy?);
  EnumOrderBy? get userId => (_$data['userId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null ? null : toJson$EnumOrderBy(l$role);
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$EnumOrderBy(l$userId);
    }
    return result$data;
  }

  CopyWith$InputauthUserRoles_min_order_by<InputauthUserRoles_min_order_by>
      get copyWith => CopyWith$InputauthUserRoles_min_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRoles_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRoles_min_order_by<TRes> {
  factory CopyWith$InputauthUserRoles_min_order_by(
    InputauthUserRoles_min_order_by instance,
    TRes Function(InputauthUserRoles_min_order_by) then,
  ) = _CopyWithImpl$InputauthUserRoles_min_order_by;

  factory CopyWith$InputauthUserRoles_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRoles_min_order_by;

  TRes call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  });
}

class _CopyWithImpl$InputauthUserRoles_min_order_by<TRes>
    implements CopyWith$InputauthUserRoles_min_order_by<TRes> {
  _CopyWithImpl$InputauthUserRoles_min_order_by(
    this._instance,
    this._then,
  );

  final InputauthUserRoles_min_order_by _instance;

  final TRes Function(InputauthUserRoles_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRoles_min_order_by._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (role != _undefined) 'role': (role as EnumOrderBy?),
        if (userId != _undefined) 'userId': (userId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$InputauthUserRoles_min_order_by<TRes>
    implements CopyWith$InputauthUserRoles_min_order_by<TRes> {
  _CopyWithStubImpl$InputauthUserRoles_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? createdAt,
    EnumOrderBy? id,
    EnumOrderBy? role,
    EnumOrderBy? userId,
  }) =>
      _res;
}

class InputauthUserRoles_streamCursorInput {
  factory InputauthUserRoles_streamCursorInput({
    required InputauthUserRoles_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      InputauthUserRoles_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  InputauthUserRoles_streamCursorInput._(this._$data);

  factory InputauthUserRoles_streamCursorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] =
        InputauthUserRoles_streamCursorValueInput.fromJson(
            (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return InputauthUserRoles_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputauthUserRoles_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as InputauthUserRoles_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$InputauthUserRoles_streamCursorInput<
          InputauthUserRoles_streamCursorInput>
      get copyWith => CopyWith$InputauthUserRoles_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRoles_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRoles_streamCursorInput<TRes> {
  factory CopyWith$InputauthUserRoles_streamCursorInput(
    InputauthUserRoles_streamCursorInput instance,
    TRes Function(InputauthUserRoles_streamCursorInput) then,
  ) = _CopyWithImpl$InputauthUserRoles_streamCursorInput;

  factory CopyWith$InputauthUserRoles_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRoles_streamCursorInput;

  TRes call({
    InputauthUserRoles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$InputauthUserRoles_streamCursorInput<TRes>
    implements CopyWith$InputauthUserRoles_streamCursorInput<TRes> {
  _CopyWithImpl$InputauthUserRoles_streamCursorInput(
    this._instance,
    this._then,
  );

  final InputauthUserRoles_streamCursorInput _instance;

  final TRes Function(InputauthUserRoles_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(InputauthUserRoles_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue':
              (initialValue as InputauthUserRoles_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$InputauthUserRoles_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$InputauthUserRoles_streamCursorInput<TRes>
    implements CopyWith$InputauthUserRoles_streamCursorInput<TRes> {
  _CopyWithStubImpl$InputauthUserRoles_streamCursorInput(this._res);

  TRes _res;

  call({
    InputauthUserRoles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$InputauthUserRoles_streamCursorValueInput.stub(_res);
}

class InputauthUserRoles_streamCursorValueInput {
  factory InputauthUserRoles_streamCursorValueInput({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  }) =>
      InputauthUserRoles_streamCursorValueInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (id != null) r'id': id,
        if (role != null) r'role': role,
        if (userId != null) r'userId': userId,
      });

  InputauthUserRoles_streamCursorValueInput._(this._$data);

  factory InputauthUserRoles_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as String?);
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    return InputauthUserRoles_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get id => (_$data['id'] as String?);
  String? get role => (_$data['role'] as String?);
  String? get userId => (_$data['userId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    return result$data;
  }

  CopyWith$InputauthUserRoles_streamCursorValueInput<
          InputauthUserRoles_streamCursorValueInput>
      get copyWith => CopyWith$InputauthUserRoles_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputauthUserRoles_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$id = id;
    final l$role = role;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('userId') ? l$userId : const {},
    ]);
  }
}

abstract class CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> {
  factory CopyWith$InputauthUserRoles_streamCursorValueInput(
    InputauthUserRoles_streamCursorValueInput instance,
    TRes Function(InputauthUserRoles_streamCursorValueInput) then,
  ) = _CopyWithImpl$InputauthUserRoles_streamCursorValueInput;

  factory CopyWith$InputauthUserRoles_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$InputauthUserRoles_streamCursorValueInput;

  TRes call({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  });
}

class _CopyWithImpl$InputauthUserRoles_streamCursorValueInput<TRes>
    implements CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> {
  _CopyWithImpl$InputauthUserRoles_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final InputauthUserRoles_streamCursorValueInput _instance;

  final TRes Function(InputauthUserRoles_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? createdAt = _undefined,
    Object? id = _undefined,
    Object? role = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(InputauthUserRoles_streamCursorValueInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (id != _undefined) 'id': (id as String?),
        if (role != _undefined) 'role': (role as String?),
        if (userId != _undefined) 'userId': (userId as String?),
      }));
}

class _CopyWithStubImpl$InputauthUserRoles_streamCursorValueInput<TRes>
    implements CopyWith$InputauthUserRoles_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$InputauthUserRoles_streamCursorValueInput(this._res);

  TRes _res;

  call({
    DateTime? createdAt,
    String? id,
    String? role,
    String? userId,
  }) =>
      _res;
}

class InputbucketsBoolExp {
  factory InputbucketsBoolExp({
    List<InputbucketsBoolExp>? $_and,
    InputbucketsBoolExp? $_not,
    List<InputbucketsBoolExp>? $_or,
    InputStringComparisonExp? cacheControl,
    InputTimestamptzComparisonExp? createdAt,
    InputIntComparisonExp? downloadExpiration,
    InputfilesBoolExp? files,
    InputStringComparisonExp? id,
    InputIntComparisonExp? maxUploadFileSize,
    InputIntComparisonExp? minUploadFileSize,
    InputBooleanComparisonExp? presignedUrlsEnabled,
    InputTimestamptzComparisonExp? updatedAt,
  }) =>
      InputbucketsBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (cacheControl != null) r'cacheControl': cacheControl,
        if (createdAt != null) r'createdAt': createdAt,
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (files != null) r'files': files,
        if (id != null) r'id': id,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
        if (presignedUrlsEnabled != null)
          r'presignedUrlsEnabled': presignedUrlsEnabled,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  InputbucketsBoolExp._(this._$data);

  factory InputbucketsBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map(
              (e) => InputbucketsBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputbucketsBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map(
              (e) => InputbucketsBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('cacheControl')) {
      final l$cacheControl = data['cacheControl'];
      result$data['cacheControl'] = l$cacheControl == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$cacheControl as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = l$downloadExpiration == null
          ? null
          : InputIntComparisonExp.fromJson(
              (l$downloadExpiration as Map<String, dynamic>));
    }
    if (data.containsKey('files')) {
      final l$files = data['files'];
      result$data['files'] = l$files == null
          ? null
          : InputfilesBoolExp.fromJson((l$files as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputStringComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = l$maxUploadFileSize == null
          ? null
          : InputIntComparisonExp.fromJson(
              (l$maxUploadFileSize as Map<String, dynamic>));
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = l$minUploadFileSize == null
          ? null
          : InputIntComparisonExp.fromJson(
              (l$minUploadFileSize as Map<String, dynamic>));
    }
    if (data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = data['presignedUrlsEnabled'];
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$presignedUrlsEnabled as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    return InputbucketsBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputbucketsBoolExp>? get $_and =>
      (_$data['_and'] as List<InputbucketsBoolExp>?);
  InputbucketsBoolExp? get $_not => (_$data['_not'] as InputbucketsBoolExp?);
  List<InputbucketsBoolExp>? get $_or =>
      (_$data['_or'] as List<InputbucketsBoolExp>?);
  InputStringComparisonExp? get cacheControl =>
      (_$data['cacheControl'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputIntComparisonExp? get downloadExpiration =>
      (_$data['downloadExpiration'] as InputIntComparisonExp?);
  InputfilesBoolExp? get files => (_$data['files'] as InputfilesBoolExp?);
  InputStringComparisonExp? get id =>
      (_$data['id'] as InputStringComparisonExp?);
  InputIntComparisonExp? get maxUploadFileSize =>
      (_$data['maxUploadFileSize'] as InputIntComparisonExp?);
  InputIntComparisonExp? get minUploadFileSize =>
      (_$data['minUploadFileSize'] as InputIntComparisonExp?);
  InputBooleanComparisonExp? get presignedUrlsEnabled =>
      (_$data['presignedUrlsEnabled'] as InputBooleanComparisonExp?);
  InputTimestamptzComparisonExp? get updatedAt =>
      (_$data['updatedAt'] as InputTimestamptzComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('cacheControl')) {
      final l$cacheControl = cacheControl;
      result$data['cacheControl'] = l$cacheControl?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration?.toJson();
    }
    if (_$data.containsKey('files')) {
      final l$files = files;
      result$data['files'] = l$files?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize?.toJson();
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize?.toJson();
    }
    if (_$data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = presignedUrlsEnabled;
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    return result$data;
  }

  CopyWith$InputbucketsBoolExp<InputbucketsBoolExp> get copyWith =>
      CopyWith$InputbucketsBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$cacheControl = cacheControl;
    final lOther$cacheControl = other.cacheControl;
    if (_$data.containsKey('cacheControl') !=
        other._$data.containsKey('cacheControl')) {
      return false;
    }
    if (l$cacheControl != lOther$cacheControl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$files = files;
    final lOther$files = other.files;
    if (_$data.containsKey('files') != other._$data.containsKey('files')) {
      return false;
    }
    if (l$files != lOther$files) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final lOther$presignedUrlsEnabled = other.presignedUrlsEnabled;
    if (_$data.containsKey('presignedUrlsEnabled') !=
        other._$data.containsKey('presignedUrlsEnabled')) {
      return false;
    }
    if (l$presignedUrlsEnabled != lOther$presignedUrlsEnabled) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$cacheControl = cacheControl;
    final l$createdAt = createdAt;
    final l$downloadExpiration = downloadExpiration;
    final l$files = files;
    final l$id = id;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('cacheControl') ? l$cacheControl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('files') ? l$files : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
      _$data.containsKey('presignedUrlsEnabled')
          ? l$presignedUrlsEnabled
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsBoolExp<TRes> {
  factory CopyWith$InputbucketsBoolExp(
    InputbucketsBoolExp instance,
    TRes Function(InputbucketsBoolExp) then,
  ) = _CopyWithImpl$InputbucketsBoolExp;

  factory CopyWith$InputbucketsBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsBoolExp;

  TRes call({
    List<InputbucketsBoolExp>? $_and,
    InputbucketsBoolExp? $_not,
    List<InputbucketsBoolExp>? $_or,
    InputStringComparisonExp? cacheControl,
    InputTimestamptzComparisonExp? createdAt,
    InputIntComparisonExp? downloadExpiration,
    InputfilesBoolExp? files,
    InputStringComparisonExp? id,
    InputIntComparisonExp? maxUploadFileSize,
    InputIntComparisonExp? minUploadFileSize,
    InputBooleanComparisonExp? presignedUrlsEnabled,
    InputTimestamptzComparisonExp? updatedAt,
  });
  TRes $_and(
      Iterable<InputbucketsBoolExp>? Function(
              Iterable<CopyWith$InputbucketsBoolExp<InputbucketsBoolExp>>?)
          _fn);
  CopyWith$InputbucketsBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputbucketsBoolExp>? Function(
              Iterable<CopyWith$InputbucketsBoolExp<InputbucketsBoolExp>>?)
          _fn);
  CopyWith$InputStringComparisonExp<TRes> get cacheControl;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputIntComparisonExp<TRes> get downloadExpiration;
  CopyWith$InputfilesBoolExp<TRes> get files;
  CopyWith$InputStringComparisonExp<TRes> get id;
  CopyWith$InputIntComparisonExp<TRes> get maxUploadFileSize;
  CopyWith$InputIntComparisonExp<TRes> get minUploadFileSize;
  CopyWith$InputBooleanComparisonExp<TRes> get presignedUrlsEnabled;
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt;
}

class _CopyWithImpl$InputbucketsBoolExp<TRes>
    implements CopyWith$InputbucketsBoolExp<TRes> {
  _CopyWithImpl$InputbucketsBoolExp(
    this._instance,
    this._then,
  );

  final InputbucketsBoolExp _instance;

  final TRes Function(InputbucketsBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? cacheControl = _undefined,
    Object? createdAt = _undefined,
    Object? downloadExpiration = _undefined,
    Object? files = _undefined,
    Object? id = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
    Object? presignedUrlsEnabled = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(InputbucketsBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<InputbucketsBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputbucketsBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<InputbucketsBoolExp>?),
        if (cacheControl != _undefined)
          'cacheControl': (cacheControl as InputStringComparisonExp?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as InputIntComparisonExp?),
        if (files != _undefined) 'files': (files as InputfilesBoolExp?),
        if (id != _undefined) 'id': (id as InputStringComparisonExp?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as InputIntComparisonExp?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as InputIntComparisonExp?),
        if (presignedUrlsEnabled != _undefined)
          'presignedUrlsEnabled':
              (presignedUrlsEnabled as InputBooleanComparisonExp?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as InputTimestamptzComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputbucketsBoolExp>? Function(
                  Iterable<CopyWith$InputbucketsBoolExp<InputbucketsBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$InputbucketsBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputbucketsBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputbucketsBoolExp.stub(_then(_instance))
        : CopyWith$InputbucketsBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputbucketsBoolExp>? Function(
                  Iterable<CopyWith$InputbucketsBoolExp<InputbucketsBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$InputbucketsBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputStringComparisonExp<TRes> get cacheControl {
    final local$cacheControl = _instance.cacheControl;
    return local$cacheControl == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$cacheControl, (e) => call(cacheControl: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputIntComparisonExp<TRes> get downloadExpiration {
    final local$downloadExpiration = _instance.downloadExpiration;
    return local$downloadExpiration == null
        ? CopyWith$InputIntComparisonExp.stub(_then(_instance))
        : CopyWith$InputIntComparisonExp(
            local$downloadExpiration, (e) => call(downloadExpiration: e));
  }

  CopyWith$InputfilesBoolExp<TRes> get files {
    final local$files = _instance.files;
    return local$files == null
        ? CopyWith$InputfilesBoolExp.stub(_then(_instance))
        : CopyWith$InputfilesBoolExp(local$files, (e) => call(files: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputIntComparisonExp<TRes> get maxUploadFileSize {
    final local$maxUploadFileSize = _instance.maxUploadFileSize;
    return local$maxUploadFileSize == null
        ? CopyWith$InputIntComparisonExp.stub(_then(_instance))
        : CopyWith$InputIntComparisonExp(
            local$maxUploadFileSize, (e) => call(maxUploadFileSize: e));
  }

  CopyWith$InputIntComparisonExp<TRes> get minUploadFileSize {
    final local$minUploadFileSize = _instance.minUploadFileSize;
    return local$minUploadFileSize == null
        ? CopyWith$InputIntComparisonExp.stub(_then(_instance))
        : CopyWith$InputIntComparisonExp(
            local$minUploadFileSize, (e) => call(minUploadFileSize: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get presignedUrlsEnabled {
    final local$presignedUrlsEnabled = _instance.presignedUrlsEnabled;
    return local$presignedUrlsEnabled == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$presignedUrlsEnabled, (e) => call(presignedUrlsEnabled: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$InputbucketsBoolExp<TRes>
    implements CopyWith$InputbucketsBoolExp<TRes> {
  _CopyWithStubImpl$InputbucketsBoolExp(this._res);

  TRes _res;

  call({
    List<InputbucketsBoolExp>? $_and,
    InputbucketsBoolExp? $_not,
    List<InputbucketsBoolExp>? $_or,
    InputStringComparisonExp? cacheControl,
    InputTimestamptzComparisonExp? createdAt,
    InputIntComparisonExp? downloadExpiration,
    InputfilesBoolExp? files,
    InputStringComparisonExp? id,
    InputIntComparisonExp? maxUploadFileSize,
    InputIntComparisonExp? minUploadFileSize,
    InputBooleanComparisonExp? presignedUrlsEnabled,
    InputTimestamptzComparisonExp? updatedAt,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputbucketsBoolExp<TRes> get $_not =>
      CopyWith$InputbucketsBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputStringComparisonExp<TRes> get cacheControl =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputIntComparisonExp<TRes> get downloadExpiration =>
      CopyWith$InputIntComparisonExp.stub(_res);
  CopyWith$InputfilesBoolExp<TRes> get files =>
      CopyWith$InputfilesBoolExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get id =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputIntComparisonExp<TRes> get maxUploadFileSize =>
      CopyWith$InputIntComparisonExp.stub(_res);
  CopyWith$InputIntComparisonExp<TRes> get minUploadFileSize =>
      CopyWith$InputIntComparisonExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get presignedUrlsEnabled =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
}

class InputbucketsIncInput {
  factory InputbucketsIncInput({
    int? downloadExpiration,
    int? maxUploadFileSize,
    int? minUploadFileSize,
  }) =>
      InputbucketsIncInput._({
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
      });

  InputbucketsIncInput._(this._$data);

  factory InputbucketsIncInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = (l$downloadExpiration as int?);
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = (l$maxUploadFileSize as int?);
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = (l$minUploadFileSize as int?);
    }
    return InputbucketsIncInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get downloadExpiration => (_$data['downloadExpiration'] as int?);
  int? get maxUploadFileSize => (_$data['maxUploadFileSize'] as int?);
  int? get minUploadFileSize => (_$data['minUploadFileSize'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration;
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize;
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize;
    }
    return result$data;
  }

  CopyWith$InputbucketsIncInput<InputbucketsIncInput> get copyWith =>
      CopyWith$InputbucketsIncInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsIncInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$downloadExpiration = downloadExpiration;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    return Object.hashAll([
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsIncInput<TRes> {
  factory CopyWith$InputbucketsIncInput(
    InputbucketsIncInput instance,
    TRes Function(InputbucketsIncInput) then,
  ) = _CopyWithImpl$InputbucketsIncInput;

  factory CopyWith$InputbucketsIncInput.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsIncInput;

  TRes call({
    int? downloadExpiration,
    int? maxUploadFileSize,
    int? minUploadFileSize,
  });
}

class _CopyWithImpl$InputbucketsIncInput<TRes>
    implements CopyWith$InputbucketsIncInput<TRes> {
  _CopyWithImpl$InputbucketsIncInput(
    this._instance,
    this._then,
  );

  final InputbucketsIncInput _instance;

  final TRes Function(InputbucketsIncInput) _then;

  static const _undefined = {};

  TRes call({
    Object? downloadExpiration = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
  }) =>
      _then(InputbucketsIncInput._({
        ..._instance._$data,
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as int?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as int?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as int?),
      }));
}

class _CopyWithStubImpl$InputbucketsIncInput<TRes>
    implements CopyWith$InputbucketsIncInput<TRes> {
  _CopyWithStubImpl$InputbucketsIncInput(this._res);

  TRes _res;

  call({
    int? downloadExpiration,
    int? maxUploadFileSize,
    int? minUploadFileSize,
  }) =>
      _res;
}

class InputbucketsInsertInput {
  factory InputbucketsInsertInput({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    InputfilesArrRelInsertInput? files,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      InputbucketsInsertInput._({
        if (cacheControl != null) r'cacheControl': cacheControl,
        if (createdAt != null) r'createdAt': createdAt,
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (files != null) r'files': files,
        if (id != null) r'id': id,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
        if (presignedUrlsEnabled != null)
          r'presignedUrlsEnabled': presignedUrlsEnabled,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  InputbucketsInsertInput._(this._$data);

  factory InputbucketsInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cacheControl')) {
      final l$cacheControl = data['cacheControl'];
      result$data['cacheControl'] = (l$cacheControl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = (l$downloadExpiration as int?);
    }
    if (data.containsKey('files')) {
      final l$files = data['files'];
      result$data['files'] = l$files == null
          ? null
          : InputfilesArrRelInsertInput.fromJson(
              (l$files as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = (l$maxUploadFileSize as int?);
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = (l$minUploadFileSize as int?);
    }
    if (data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = data['presignedUrlsEnabled'];
      result$data['presignedUrlsEnabled'] = (l$presignedUrlsEnabled as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    return InputbucketsInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get cacheControl => (_$data['cacheControl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  int? get downloadExpiration => (_$data['downloadExpiration'] as int?);
  InputfilesArrRelInsertInput? get files =>
      (_$data['files'] as InputfilesArrRelInsertInput?);
  String? get id => (_$data['id'] as String?);
  int? get maxUploadFileSize => (_$data['maxUploadFileSize'] as int?);
  int? get minUploadFileSize => (_$data['minUploadFileSize'] as int?);
  bool? get presignedUrlsEnabled => (_$data['presignedUrlsEnabled'] as bool?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cacheControl')) {
      final l$cacheControl = cacheControl;
      result$data['cacheControl'] = l$cacheControl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration;
    }
    if (_$data.containsKey('files')) {
      final l$files = files;
      result$data['files'] = l$files?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize;
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize;
    }
    if (_$data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = presignedUrlsEnabled;
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$InputbucketsInsertInput<InputbucketsInsertInput> get copyWith =>
      CopyWith$InputbucketsInsertInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cacheControl = cacheControl;
    final lOther$cacheControl = other.cacheControl;
    if (_$data.containsKey('cacheControl') !=
        other._$data.containsKey('cacheControl')) {
      return false;
    }
    if (l$cacheControl != lOther$cacheControl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$files = files;
    final lOther$files = other.files;
    if (_$data.containsKey('files') != other._$data.containsKey('files')) {
      return false;
    }
    if (l$files != lOther$files) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final lOther$presignedUrlsEnabled = other.presignedUrlsEnabled;
    if (_$data.containsKey('presignedUrlsEnabled') !=
        other._$data.containsKey('presignedUrlsEnabled')) {
      return false;
    }
    if (l$presignedUrlsEnabled != lOther$presignedUrlsEnabled) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cacheControl = cacheControl;
    final l$createdAt = createdAt;
    final l$downloadExpiration = downloadExpiration;
    final l$files = files;
    final l$id = id;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('cacheControl') ? l$cacheControl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('files') ? l$files : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
      _$data.containsKey('presignedUrlsEnabled')
          ? l$presignedUrlsEnabled
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsInsertInput<TRes> {
  factory CopyWith$InputbucketsInsertInput(
    InputbucketsInsertInput instance,
    TRes Function(InputbucketsInsertInput) then,
  ) = _CopyWithImpl$InputbucketsInsertInput;

  factory CopyWith$InputbucketsInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsInsertInput;

  TRes call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    InputfilesArrRelInsertInput? files,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  });
  CopyWith$InputfilesArrRelInsertInput<TRes> get files;
}

class _CopyWithImpl$InputbucketsInsertInput<TRes>
    implements CopyWith$InputbucketsInsertInput<TRes> {
  _CopyWithImpl$InputbucketsInsertInput(
    this._instance,
    this._then,
  );

  final InputbucketsInsertInput _instance;

  final TRes Function(InputbucketsInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cacheControl = _undefined,
    Object? createdAt = _undefined,
    Object? downloadExpiration = _undefined,
    Object? files = _undefined,
    Object? id = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
    Object? presignedUrlsEnabled = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(InputbucketsInsertInput._({
        ..._instance._$data,
        if (cacheControl != _undefined)
          'cacheControl': (cacheControl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as int?),
        if (files != _undefined)
          'files': (files as InputfilesArrRelInsertInput?),
        if (id != _undefined) 'id': (id as String?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as int?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as int?),
        if (presignedUrlsEnabled != _undefined)
          'presignedUrlsEnabled': (presignedUrlsEnabled as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
  CopyWith$InputfilesArrRelInsertInput<TRes> get files {
    final local$files = _instance.files;
    return local$files == null
        ? CopyWith$InputfilesArrRelInsertInput.stub(_then(_instance))
        : CopyWith$InputfilesArrRelInsertInput(
            local$files, (e) => call(files: e));
  }
}

class _CopyWithStubImpl$InputbucketsInsertInput<TRes>
    implements CopyWith$InputbucketsInsertInput<TRes> {
  _CopyWithStubImpl$InputbucketsInsertInput(this._res);

  TRes _res;

  call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    InputfilesArrRelInsertInput? files,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      _res;
  CopyWith$InputfilesArrRelInsertInput<TRes> get files =>
      CopyWith$InputfilesArrRelInsertInput.stub(_res);
}

class InputbucketsObjRelInsertInput {
  factory InputbucketsObjRelInsertInput({
    required InputbucketsInsertInput data,
    InputbucketsOnConflict? onConflict,
  }) =>
      InputbucketsObjRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputbucketsObjRelInsertInput._(this._$data);

  factory InputbucketsObjRelInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] =
        InputbucketsInsertInput.fromJson((l$data as Map<String, dynamic>));
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputbucketsOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputbucketsObjRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputbucketsInsertInput get data =>
      (_$data['data'] as InputbucketsInsertInput);
  InputbucketsOnConflict? get onConflict =>
      (_$data['onConflict'] as InputbucketsOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputbucketsObjRelInsertInput<InputbucketsObjRelInsertInput>
      get copyWith => CopyWith$InputbucketsObjRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsObjRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      l$data,
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsObjRelInsertInput<TRes> {
  factory CopyWith$InputbucketsObjRelInsertInput(
    InputbucketsObjRelInsertInput instance,
    TRes Function(InputbucketsObjRelInsertInput) then,
  ) = _CopyWithImpl$InputbucketsObjRelInsertInput;

  factory CopyWith$InputbucketsObjRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsObjRelInsertInput;

  TRes call({
    InputbucketsInsertInput? data,
    InputbucketsOnConflict? onConflict,
  });
  CopyWith$InputbucketsInsertInput<TRes> get data;
  CopyWith$InputbucketsOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputbucketsObjRelInsertInput<TRes>
    implements CopyWith$InputbucketsObjRelInsertInput<TRes> {
  _CopyWithImpl$InputbucketsObjRelInsertInput(
    this._instance,
    this._then,
  );

  final InputbucketsObjRelInsertInput _instance;

  final TRes Function(InputbucketsObjRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputbucketsObjRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as InputbucketsInsertInput),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputbucketsOnConflict?),
      }));
  CopyWith$InputbucketsInsertInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$InputbucketsInsertInput(local$data, (e) => call(data: e));
  }

  CopyWith$InputbucketsOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputbucketsOnConflict.stub(_then(_instance))
        : CopyWith$InputbucketsOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputbucketsObjRelInsertInput<TRes>
    implements CopyWith$InputbucketsObjRelInsertInput<TRes> {
  _CopyWithStubImpl$InputbucketsObjRelInsertInput(this._res);

  TRes _res;

  call({
    InputbucketsInsertInput? data,
    InputbucketsOnConflict? onConflict,
  }) =>
      _res;
  CopyWith$InputbucketsInsertInput<TRes> get data =>
      CopyWith$InputbucketsInsertInput.stub(_res);
  CopyWith$InputbucketsOnConflict<TRes> get onConflict =>
      CopyWith$InputbucketsOnConflict.stub(_res);
}

class InputbucketsOnConflict {
  factory InputbucketsOnConflict({
    required EnumbucketsConstraint constraint,
    required List<EnumbucketsUpdateColumn> update_columns,
    InputbucketsBoolExp? where,
  }) =>
      InputbucketsOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputbucketsOnConflict._(this._$data);

  factory InputbucketsOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumbucketsConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumbucketsUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputbucketsBoolExp.fromJson((l$where as Map<String, dynamic>));
    }
    return InputbucketsOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumbucketsConstraint get constraint =>
      (_$data['constraint'] as EnumbucketsConstraint);
  List<EnumbucketsUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumbucketsUpdateColumn>);
  InputbucketsBoolExp? get where => (_$data['where'] as InputbucketsBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] = toJson$EnumbucketsConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] =
        l$update_columns.map((e) => toJson$EnumbucketsUpdateColumn(e)).toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputbucketsOnConflict<InputbucketsOnConflict> get copyWith =>
      CopyWith$InputbucketsOnConflict(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsOnConflict) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsOnConflict<TRes> {
  factory CopyWith$InputbucketsOnConflict(
    InputbucketsOnConflict instance,
    TRes Function(InputbucketsOnConflict) then,
  ) = _CopyWithImpl$InputbucketsOnConflict;

  factory CopyWith$InputbucketsOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsOnConflict;

  TRes call({
    EnumbucketsConstraint? constraint,
    List<EnumbucketsUpdateColumn>? update_columns,
    InputbucketsBoolExp? where,
  });
  CopyWith$InputbucketsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputbucketsOnConflict<TRes>
    implements CopyWith$InputbucketsOnConflict<TRes> {
  _CopyWithImpl$InputbucketsOnConflict(
    this._instance,
    this._then,
  );

  final InputbucketsOnConflict _instance;

  final TRes Function(InputbucketsOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputbucketsOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumbucketsConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns': (update_columns as List<EnumbucketsUpdateColumn>),
        if (where != _undefined) 'where': (where as InputbucketsBoolExp?),
      }));
  CopyWith$InputbucketsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputbucketsBoolExp.stub(_then(_instance))
        : CopyWith$InputbucketsBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputbucketsOnConflict<TRes>
    implements CopyWith$InputbucketsOnConflict<TRes> {
  _CopyWithStubImpl$InputbucketsOnConflict(this._res);

  TRes _res;

  call({
    EnumbucketsConstraint? constraint,
    List<EnumbucketsUpdateColumn>? update_columns,
    InputbucketsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputbucketsBoolExp<TRes> get where =>
      CopyWith$InputbucketsBoolExp.stub(_res);
}

class InputbucketsOrderBy {
  factory InputbucketsOrderBy({
    EnumOrderBy? cacheControl,
    EnumOrderBy? createdAt,
    EnumOrderBy? downloadExpiration,
    InputfilesAggregateOrderBy? filesAggregate,
    EnumOrderBy? id,
    EnumOrderBy? maxUploadFileSize,
    EnumOrderBy? minUploadFileSize,
    EnumOrderBy? presignedUrlsEnabled,
    EnumOrderBy? updatedAt,
  }) =>
      InputbucketsOrderBy._({
        if (cacheControl != null) r'cacheControl': cacheControl,
        if (createdAt != null) r'createdAt': createdAt,
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (filesAggregate != null) r'filesAggregate': filesAggregate,
        if (id != null) r'id': id,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
        if (presignedUrlsEnabled != null)
          r'presignedUrlsEnabled': presignedUrlsEnabled,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  InputbucketsOrderBy._(this._$data);

  factory InputbucketsOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cacheControl')) {
      final l$cacheControl = data['cacheControl'];
      result$data['cacheControl'] = l$cacheControl == null
          ? null
          : fromJson$EnumOrderBy((l$cacheControl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = l$downloadExpiration == null
          ? null
          : fromJson$EnumOrderBy((l$downloadExpiration as String));
    }
    if (data.containsKey('filesAggregate')) {
      final l$filesAggregate = data['filesAggregate'];
      result$data['filesAggregate'] = l$filesAggregate == null
          ? null
          : InputfilesAggregateOrderBy.fromJson(
              (l$filesAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = l$maxUploadFileSize == null
          ? null
          : fromJson$EnumOrderBy((l$maxUploadFileSize as String));
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = l$minUploadFileSize == null
          ? null
          : fromJson$EnumOrderBy((l$minUploadFileSize as String));
    }
    if (data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = data['presignedUrlsEnabled'];
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled == null
          ? null
          : fromJson$EnumOrderBy((l$presignedUrlsEnabled as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    return InputbucketsOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get cacheControl => (_$data['cacheControl'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get downloadExpiration =>
      (_$data['downloadExpiration'] as EnumOrderBy?);
  InputfilesAggregateOrderBy? get filesAggregate =>
      (_$data['filesAggregate'] as InputfilesAggregateOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get maxUploadFileSize =>
      (_$data['maxUploadFileSize'] as EnumOrderBy?);
  EnumOrderBy? get minUploadFileSize =>
      (_$data['minUploadFileSize'] as EnumOrderBy?);
  EnumOrderBy? get presignedUrlsEnabled =>
      (_$data['presignedUrlsEnabled'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cacheControl')) {
      final l$cacheControl = cacheControl;
      result$data['cacheControl'] =
          l$cacheControl == null ? null : toJson$EnumOrderBy(l$cacheControl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration == null
          ? null
          : toJson$EnumOrderBy(l$downloadExpiration);
    }
    if (_$data.containsKey('filesAggregate')) {
      final l$filesAggregate = filesAggregate;
      result$data['filesAggregate'] = l$filesAggregate?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize == null
          ? null
          : toJson$EnumOrderBy(l$maxUploadFileSize);
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize == null
          ? null
          : toJson$EnumOrderBy(l$minUploadFileSize);
    }
    if (_$data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = presignedUrlsEnabled;
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled == null
          ? null
          : toJson$EnumOrderBy(l$presignedUrlsEnabled);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$InputbucketsOrderBy<InputbucketsOrderBy> get copyWith =>
      CopyWith$InputbucketsOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$cacheControl = cacheControl;
    final lOther$cacheControl = other.cacheControl;
    if (_$data.containsKey('cacheControl') !=
        other._$data.containsKey('cacheControl')) {
      return false;
    }
    if (l$cacheControl != lOther$cacheControl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$filesAggregate = filesAggregate;
    final lOther$filesAggregate = other.filesAggregate;
    if (_$data.containsKey('filesAggregate') !=
        other._$data.containsKey('filesAggregate')) {
      return false;
    }
    if (l$filesAggregate != lOther$filesAggregate) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final lOther$presignedUrlsEnabled = other.presignedUrlsEnabled;
    if (_$data.containsKey('presignedUrlsEnabled') !=
        other._$data.containsKey('presignedUrlsEnabled')) {
      return false;
    }
    if (l$presignedUrlsEnabled != lOther$presignedUrlsEnabled) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cacheControl = cacheControl;
    final l$createdAt = createdAt;
    final l$downloadExpiration = downloadExpiration;
    final l$filesAggregate = filesAggregate;
    final l$id = id;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('cacheControl') ? l$cacheControl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('filesAggregate') ? l$filesAggregate : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
      _$data.containsKey('presignedUrlsEnabled')
          ? l$presignedUrlsEnabled
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsOrderBy<TRes> {
  factory CopyWith$InputbucketsOrderBy(
    InputbucketsOrderBy instance,
    TRes Function(InputbucketsOrderBy) then,
  ) = _CopyWithImpl$InputbucketsOrderBy;

  factory CopyWith$InputbucketsOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsOrderBy;

  TRes call({
    EnumOrderBy? cacheControl,
    EnumOrderBy? createdAt,
    EnumOrderBy? downloadExpiration,
    InputfilesAggregateOrderBy? filesAggregate,
    EnumOrderBy? id,
    EnumOrderBy? maxUploadFileSize,
    EnumOrderBy? minUploadFileSize,
    EnumOrderBy? presignedUrlsEnabled,
    EnumOrderBy? updatedAt,
  });
  CopyWith$InputfilesAggregateOrderBy<TRes> get filesAggregate;
}

class _CopyWithImpl$InputbucketsOrderBy<TRes>
    implements CopyWith$InputbucketsOrderBy<TRes> {
  _CopyWithImpl$InputbucketsOrderBy(
    this._instance,
    this._then,
  );

  final InputbucketsOrderBy _instance;

  final TRes Function(InputbucketsOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? cacheControl = _undefined,
    Object? createdAt = _undefined,
    Object? downloadExpiration = _undefined,
    Object? filesAggregate = _undefined,
    Object? id = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
    Object? presignedUrlsEnabled = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(InputbucketsOrderBy._({
        ..._instance._$data,
        if (cacheControl != _undefined)
          'cacheControl': (cacheControl as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as EnumOrderBy?),
        if (filesAggregate != _undefined)
          'filesAggregate': (filesAggregate as InputfilesAggregateOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as EnumOrderBy?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as EnumOrderBy?),
        if (presignedUrlsEnabled != _undefined)
          'presignedUrlsEnabled': (presignedUrlsEnabled as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
      }));
  CopyWith$InputfilesAggregateOrderBy<TRes> get filesAggregate {
    final local$filesAggregate = _instance.filesAggregate;
    return local$filesAggregate == null
        ? CopyWith$InputfilesAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputfilesAggregateOrderBy(
            local$filesAggregate, (e) => call(filesAggregate: e));
  }
}

class _CopyWithStubImpl$InputbucketsOrderBy<TRes>
    implements CopyWith$InputbucketsOrderBy<TRes> {
  _CopyWithStubImpl$InputbucketsOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? cacheControl,
    EnumOrderBy? createdAt,
    EnumOrderBy? downloadExpiration,
    InputfilesAggregateOrderBy? filesAggregate,
    EnumOrderBy? id,
    EnumOrderBy? maxUploadFileSize,
    EnumOrderBy? minUploadFileSize,
    EnumOrderBy? presignedUrlsEnabled,
    EnumOrderBy? updatedAt,
  }) =>
      _res;
  CopyWith$InputfilesAggregateOrderBy<TRes> get filesAggregate =>
      CopyWith$InputfilesAggregateOrderBy.stub(_res);
}

class InputbucketsPkColumnsInput {
  factory InputbucketsPkColumnsInput({required String id}) =>
      InputbucketsPkColumnsInput._({
        r'id': id,
      });

  InputbucketsPkColumnsInput._(this._$data);

  factory InputbucketsPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputbucketsPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputbucketsPkColumnsInput<InputbucketsPkColumnsInput>
      get copyWith => CopyWith$InputbucketsPkColumnsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputbucketsPkColumnsInput<TRes> {
  factory CopyWith$InputbucketsPkColumnsInput(
    InputbucketsPkColumnsInput instance,
    TRes Function(InputbucketsPkColumnsInput) then,
  ) = _CopyWithImpl$InputbucketsPkColumnsInput;

  factory CopyWith$InputbucketsPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputbucketsPkColumnsInput<TRes>
    implements CopyWith$InputbucketsPkColumnsInput<TRes> {
  _CopyWithImpl$InputbucketsPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputbucketsPkColumnsInput _instance;

  final TRes Function(InputbucketsPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) => _then(InputbucketsPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputbucketsPkColumnsInput<TRes>
    implements CopyWith$InputbucketsPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputbucketsPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputbucketsSetInput {
  factory InputbucketsSetInput({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      InputbucketsSetInput._({
        if (cacheControl != null) r'cacheControl': cacheControl,
        if (createdAt != null) r'createdAt': createdAt,
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (id != null) r'id': id,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
        if (presignedUrlsEnabled != null)
          r'presignedUrlsEnabled': presignedUrlsEnabled,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  InputbucketsSetInput._(this._$data);

  factory InputbucketsSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cacheControl')) {
      final l$cacheControl = data['cacheControl'];
      result$data['cacheControl'] = (l$cacheControl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = (l$downloadExpiration as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = (l$maxUploadFileSize as int?);
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = (l$minUploadFileSize as int?);
    }
    if (data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = data['presignedUrlsEnabled'];
      result$data['presignedUrlsEnabled'] = (l$presignedUrlsEnabled as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    return InputbucketsSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get cacheControl => (_$data['cacheControl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  int? get downloadExpiration => (_$data['downloadExpiration'] as int?);
  String? get id => (_$data['id'] as String?);
  int? get maxUploadFileSize => (_$data['maxUploadFileSize'] as int?);
  int? get minUploadFileSize => (_$data['minUploadFileSize'] as int?);
  bool? get presignedUrlsEnabled => (_$data['presignedUrlsEnabled'] as bool?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cacheControl')) {
      final l$cacheControl = cacheControl;
      result$data['cacheControl'] = l$cacheControl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize;
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize;
    }
    if (_$data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = presignedUrlsEnabled;
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$InputbucketsSetInput<InputbucketsSetInput> get copyWith =>
      CopyWith$InputbucketsSetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsSetInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$cacheControl = cacheControl;
    final lOther$cacheControl = other.cacheControl;
    if (_$data.containsKey('cacheControl') !=
        other._$data.containsKey('cacheControl')) {
      return false;
    }
    if (l$cacheControl != lOther$cacheControl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final lOther$presignedUrlsEnabled = other.presignedUrlsEnabled;
    if (_$data.containsKey('presignedUrlsEnabled') !=
        other._$data.containsKey('presignedUrlsEnabled')) {
      return false;
    }
    if (l$presignedUrlsEnabled != lOther$presignedUrlsEnabled) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cacheControl = cacheControl;
    final l$createdAt = createdAt;
    final l$downloadExpiration = downloadExpiration;
    final l$id = id;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('cacheControl') ? l$cacheControl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
      _$data.containsKey('presignedUrlsEnabled')
          ? l$presignedUrlsEnabled
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$InputbucketsSetInput<TRes> {
  factory CopyWith$InputbucketsSetInput(
    InputbucketsSetInput instance,
    TRes Function(InputbucketsSetInput) then,
  ) = _CopyWithImpl$InputbucketsSetInput;

  factory CopyWith$InputbucketsSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsSetInput;

  TRes call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$InputbucketsSetInput<TRes>
    implements CopyWith$InputbucketsSetInput<TRes> {
  _CopyWithImpl$InputbucketsSetInput(
    this._instance,
    this._then,
  );

  final InputbucketsSetInput _instance;

  final TRes Function(InputbucketsSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cacheControl = _undefined,
    Object? createdAt = _undefined,
    Object? downloadExpiration = _undefined,
    Object? id = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
    Object? presignedUrlsEnabled = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(InputbucketsSetInput._({
        ..._instance._$data,
        if (cacheControl != _undefined)
          'cacheControl': (cacheControl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as int?),
        if (id != _undefined) 'id': (id as String?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as int?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as int?),
        if (presignedUrlsEnabled != _undefined)
          'presignedUrlsEnabled': (presignedUrlsEnabled as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$InputbucketsSetInput<TRes>
    implements CopyWith$InputbucketsSetInput<TRes> {
  _CopyWithStubImpl$InputbucketsSetInput(this._res);

  TRes _res;

  call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      _res;
}

class InputbucketsUpdates {
  factory InputbucketsUpdates({
    InputbucketsIncInput? $_inc,
    InputbucketsSetInput? $_set,
    required InputbucketsBoolExp where,
  }) =>
      InputbucketsUpdates._({
        if ($_inc != null) r'_inc': $_inc,
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputbucketsUpdates._(this._$data);

  factory InputbucketsUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_inc')) {
      final l$$_inc = data['_inc'];
      result$data['_inc'] = l$$_inc == null
          ? null
          : InputbucketsIncInput.fromJson((l$$_inc as Map<String, dynamic>));
    }
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputbucketsSetInput.fromJson((l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputbucketsBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputbucketsUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputbucketsIncInput? get $_inc => (_$data['_inc'] as InputbucketsIncInput?);
  InputbucketsSetInput? get $_set => (_$data['_set'] as InputbucketsSetInput?);
  InputbucketsBoolExp get where => (_$data['where'] as InputbucketsBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_inc')) {
      final l$$_inc = $_inc;
      result$data['_inc'] = l$$_inc?.toJson();
    }
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputbucketsUpdates<InputbucketsUpdates> get copyWith =>
      CopyWith$InputbucketsUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputbucketsUpdates) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_inc = $_inc;
    final lOther$$_inc = other.$_inc;
    if (_$data.containsKey('_inc') != other._$data.containsKey('_inc')) {
      return false;
    }
    if (l$$_inc != lOther$$_inc) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_inc = $_inc;
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_inc') ? l$$_inc : const {},
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputbucketsUpdates<TRes> {
  factory CopyWith$InputbucketsUpdates(
    InputbucketsUpdates instance,
    TRes Function(InputbucketsUpdates) then,
  ) = _CopyWithImpl$InputbucketsUpdates;

  factory CopyWith$InputbucketsUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputbucketsUpdates;

  TRes call({
    InputbucketsIncInput? $_inc,
    InputbucketsSetInput? $_set,
    InputbucketsBoolExp? where,
  });
  CopyWith$InputbucketsIncInput<TRes> get $_inc;
  CopyWith$InputbucketsSetInput<TRes> get $_set;
  CopyWith$InputbucketsBoolExp<TRes> get where;
}

class _CopyWithImpl$InputbucketsUpdates<TRes>
    implements CopyWith$InputbucketsUpdates<TRes> {
  _CopyWithImpl$InputbucketsUpdates(
    this._instance,
    this._then,
  );

  final InputbucketsUpdates _instance;

  final TRes Function(InputbucketsUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_inc = _undefined,
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputbucketsUpdates._({
        ..._instance._$data,
        if ($_inc != _undefined) '_inc': ($_inc as InputbucketsIncInput?),
        if ($_set != _undefined) '_set': ($_set as InputbucketsSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputbucketsBoolExp),
      }));
  CopyWith$InputbucketsIncInput<TRes> get $_inc {
    final local$$_inc = _instance.$_inc;
    return local$$_inc == null
        ? CopyWith$InputbucketsIncInput.stub(_then(_instance))
        : CopyWith$InputbucketsIncInput(local$$_inc, (e) => call($_inc: e));
  }

  CopyWith$InputbucketsSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputbucketsSetInput.stub(_then(_instance))
        : CopyWith$InputbucketsSetInput(local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputbucketsBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputbucketsBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputbucketsUpdates<TRes>
    implements CopyWith$InputbucketsUpdates<TRes> {
  _CopyWithStubImpl$InputbucketsUpdates(this._res);

  TRes _res;

  call({
    InputbucketsIncInput? $_inc,
    InputbucketsSetInput? $_set,
    InputbucketsBoolExp? where,
  }) =>
      _res;
  CopyWith$InputbucketsIncInput<TRes> get $_inc =>
      CopyWith$InputbucketsIncInput.stub(_res);
  CopyWith$InputbucketsSetInput<TRes> get $_set =>
      CopyWith$InputbucketsSetInput.stub(_res);
  CopyWith$InputbucketsBoolExp<TRes> get where =>
      CopyWith$InputbucketsBoolExp.stub(_res);
}

class Inputbuckets_streamCursorInput {
  factory Inputbuckets_streamCursorInput({
    required Inputbuckets_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      Inputbuckets_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  Inputbuckets_streamCursorInput._(this._$data);

  factory Inputbuckets_streamCursorInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] = Inputbuckets_streamCursorValueInput.fromJson(
        (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return Inputbuckets_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Inputbuckets_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as Inputbuckets_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$Inputbuckets_streamCursorInput<Inputbuckets_streamCursorInput>
      get copyWith => CopyWith$Inputbuckets_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputbuckets_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$Inputbuckets_streamCursorInput<TRes> {
  factory CopyWith$Inputbuckets_streamCursorInput(
    Inputbuckets_streamCursorInput instance,
    TRes Function(Inputbuckets_streamCursorInput) then,
  ) = _CopyWithImpl$Inputbuckets_streamCursorInput;

  factory CopyWith$Inputbuckets_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$Inputbuckets_streamCursorInput;

  TRes call({
    Inputbuckets_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$Inputbuckets_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$Inputbuckets_streamCursorInput<TRes>
    implements CopyWith$Inputbuckets_streamCursorInput<TRes> {
  _CopyWithImpl$Inputbuckets_streamCursorInput(
    this._instance,
    this._then,
  );

  final Inputbuckets_streamCursorInput _instance;

  final TRes Function(Inputbuckets_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(Inputbuckets_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue': (initialValue as Inputbuckets_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$Inputbuckets_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$Inputbuckets_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$Inputbuckets_streamCursorInput<TRes>
    implements CopyWith$Inputbuckets_streamCursorInput<TRes> {
  _CopyWithStubImpl$Inputbuckets_streamCursorInput(this._res);

  TRes _res;

  call({
    Inputbuckets_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$Inputbuckets_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$Inputbuckets_streamCursorValueInput.stub(_res);
}

class Inputbuckets_streamCursorValueInput {
  factory Inputbuckets_streamCursorValueInput({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      Inputbuckets_streamCursorValueInput._({
        if (cacheControl != null) r'cacheControl': cacheControl,
        if (createdAt != null) r'createdAt': createdAt,
        if (downloadExpiration != null)
          r'downloadExpiration': downloadExpiration,
        if (id != null) r'id': id,
        if (maxUploadFileSize != null) r'maxUploadFileSize': maxUploadFileSize,
        if (minUploadFileSize != null) r'minUploadFileSize': minUploadFileSize,
        if (presignedUrlsEnabled != null)
          r'presignedUrlsEnabled': presignedUrlsEnabled,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Inputbuckets_streamCursorValueInput._(this._$data);

  factory Inputbuckets_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('cacheControl')) {
      final l$cacheControl = data['cacheControl'];
      result$data['cacheControl'] = (l$cacheControl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = data['downloadExpiration'];
      result$data['downloadExpiration'] = (l$downloadExpiration as int?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = data['maxUploadFileSize'];
      result$data['maxUploadFileSize'] = (l$maxUploadFileSize as int?);
    }
    if (data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = data['minUploadFileSize'];
      result$data['minUploadFileSize'] = (l$minUploadFileSize as int?);
    }
    if (data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = data['presignedUrlsEnabled'];
      result$data['presignedUrlsEnabled'] = (l$presignedUrlsEnabled as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    return Inputbuckets_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get cacheControl => (_$data['cacheControl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  int? get downloadExpiration => (_$data['downloadExpiration'] as int?);
  String? get id => (_$data['id'] as String?);
  int? get maxUploadFileSize => (_$data['maxUploadFileSize'] as int?);
  int? get minUploadFileSize => (_$data['minUploadFileSize'] as int?);
  bool? get presignedUrlsEnabled => (_$data['presignedUrlsEnabled'] as bool?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('cacheControl')) {
      final l$cacheControl = cacheControl;
      result$data['cacheControl'] = l$cacheControl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('downloadExpiration')) {
      final l$downloadExpiration = downloadExpiration;
      result$data['downloadExpiration'] = l$downloadExpiration;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('maxUploadFileSize')) {
      final l$maxUploadFileSize = maxUploadFileSize;
      result$data['maxUploadFileSize'] = l$maxUploadFileSize;
    }
    if (_$data.containsKey('minUploadFileSize')) {
      final l$minUploadFileSize = minUploadFileSize;
      result$data['minUploadFileSize'] = l$minUploadFileSize;
    }
    if (_$data.containsKey('presignedUrlsEnabled')) {
      final l$presignedUrlsEnabled = presignedUrlsEnabled;
      result$data['presignedUrlsEnabled'] = l$presignedUrlsEnabled;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Inputbuckets_streamCursorValueInput<
          Inputbuckets_streamCursorValueInput>
      get copyWith => CopyWith$Inputbuckets_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputbuckets_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cacheControl = cacheControl;
    final lOther$cacheControl = other.cacheControl;
    if (_$data.containsKey('cacheControl') !=
        other._$data.containsKey('cacheControl')) {
      return false;
    }
    if (l$cacheControl != lOther$cacheControl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$downloadExpiration = downloadExpiration;
    final lOther$downloadExpiration = other.downloadExpiration;
    if (_$data.containsKey('downloadExpiration') !=
        other._$data.containsKey('downloadExpiration')) {
      return false;
    }
    if (l$downloadExpiration != lOther$downloadExpiration) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$maxUploadFileSize = maxUploadFileSize;
    final lOther$maxUploadFileSize = other.maxUploadFileSize;
    if (_$data.containsKey('maxUploadFileSize') !=
        other._$data.containsKey('maxUploadFileSize')) {
      return false;
    }
    if (l$maxUploadFileSize != lOther$maxUploadFileSize) {
      return false;
    }
    final l$minUploadFileSize = minUploadFileSize;
    final lOther$minUploadFileSize = other.minUploadFileSize;
    if (_$data.containsKey('minUploadFileSize') !=
        other._$data.containsKey('minUploadFileSize')) {
      return false;
    }
    if (l$minUploadFileSize != lOther$minUploadFileSize) {
      return false;
    }
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final lOther$presignedUrlsEnabled = other.presignedUrlsEnabled;
    if (_$data.containsKey('presignedUrlsEnabled') !=
        other._$data.containsKey('presignedUrlsEnabled')) {
      return false;
    }
    if (l$presignedUrlsEnabled != lOther$presignedUrlsEnabled) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cacheControl = cacheControl;
    final l$createdAt = createdAt;
    final l$downloadExpiration = downloadExpiration;
    final l$id = id;
    final l$maxUploadFileSize = maxUploadFileSize;
    final l$minUploadFileSize = minUploadFileSize;
    final l$presignedUrlsEnabled = presignedUrlsEnabled;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('cacheControl') ? l$cacheControl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('downloadExpiration')
          ? l$downloadExpiration
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('maxUploadFileSize') ? l$maxUploadFileSize : const {},
      _$data.containsKey('minUploadFileSize') ? l$minUploadFileSize : const {},
      _$data.containsKey('presignedUrlsEnabled')
          ? l$presignedUrlsEnabled
          : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Inputbuckets_streamCursorValueInput<TRes> {
  factory CopyWith$Inputbuckets_streamCursorValueInput(
    Inputbuckets_streamCursorValueInput instance,
    TRes Function(Inputbuckets_streamCursorValueInput) then,
  ) = _CopyWithImpl$Inputbuckets_streamCursorValueInput;

  factory CopyWith$Inputbuckets_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$Inputbuckets_streamCursorValueInput;

  TRes call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Inputbuckets_streamCursorValueInput<TRes>
    implements CopyWith$Inputbuckets_streamCursorValueInput<TRes> {
  _CopyWithImpl$Inputbuckets_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final Inputbuckets_streamCursorValueInput _instance;

  final TRes Function(Inputbuckets_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? cacheControl = _undefined,
    Object? createdAt = _undefined,
    Object? downloadExpiration = _undefined,
    Object? id = _undefined,
    Object? maxUploadFileSize = _undefined,
    Object? minUploadFileSize = _undefined,
    Object? presignedUrlsEnabled = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Inputbuckets_streamCursorValueInput._({
        ..._instance._$data,
        if (cacheControl != _undefined)
          'cacheControl': (cacheControl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (downloadExpiration != _undefined)
          'downloadExpiration': (downloadExpiration as int?),
        if (id != _undefined) 'id': (id as String?),
        if (maxUploadFileSize != _undefined)
          'maxUploadFileSize': (maxUploadFileSize as int?),
        if (minUploadFileSize != _undefined)
          'minUploadFileSize': (minUploadFileSize as int?),
        if (presignedUrlsEnabled != _undefined)
          'presignedUrlsEnabled': (presignedUrlsEnabled as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Inputbuckets_streamCursorValueInput<TRes>
    implements CopyWith$Inputbuckets_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$Inputbuckets_streamCursorValueInput(this._res);

  TRes _res;

  call({
    String? cacheControl,
    DateTime? createdAt,
    int? downloadExpiration,
    String? id,
    int? maxUploadFileSize,
    int? minUploadFileSize,
    bool? presignedUrlsEnabled,
    DateTime? updatedAt,
  }) =>
      _res;
}

class InputfilesAggregateOrderBy {
  factory InputfilesAggregateOrderBy({
    Inputfiles_avg_order_by? avg,
    EnumOrderBy? count,
    Inputfiles_max_order_by? max,
    Inputfiles_min_order_by? min,
    Inputfiles_stddev_order_by? stddev,
    Inputfiles_stddev_pop_order_by? stddev_pop,
    Inputfiles_stddev_samp_order_by? stddev_samp,
    Inputfiles_sum_order_by? sum,
    Inputfiles_var_pop_order_by? var_pop,
    Inputfiles_var_samp_order_by? var_samp,
    Inputfiles_variance_order_by? variance,
  }) =>
      InputfilesAggregateOrderBy._({
        if (avg != null) r'avg': avg,
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
        if (stddev != null) r'stddev': stddev,
        if (stddev_pop != null) r'stddev_pop': stddev_pop,
        if (stddev_samp != null) r'stddev_samp': stddev_samp,
        if (sum != null) r'sum': sum,
        if (var_pop != null) r'var_pop': var_pop,
        if (var_samp != null) r'var_samp': var_samp,
        if (variance != null) r'variance': variance,
      });

  InputfilesAggregateOrderBy._(this._$data);

  factory InputfilesAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('avg')) {
      final l$avg = data['avg'];
      result$data['avg'] = l$avg == null
          ? null
          : Inputfiles_avg_order_by.fromJson((l$avg as Map<String, dynamic>));
    }
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Inputfiles_max_order_by.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Inputfiles_min_order_by.fromJson((l$min as Map<String, dynamic>));
    }
    if (data.containsKey('stddev')) {
      final l$stddev = data['stddev'];
      result$data['stddev'] = l$stddev == null
          ? null
          : Inputfiles_stddev_order_by.fromJson(
              (l$stddev as Map<String, dynamic>));
    }
    if (data.containsKey('stddev_pop')) {
      final l$stddev_pop = data['stddev_pop'];
      result$data['stddev_pop'] = l$stddev_pop == null
          ? null
          : Inputfiles_stddev_pop_order_by.fromJson(
              (l$stddev_pop as Map<String, dynamic>));
    }
    if (data.containsKey('stddev_samp')) {
      final l$stddev_samp = data['stddev_samp'];
      result$data['stddev_samp'] = l$stddev_samp == null
          ? null
          : Inputfiles_stddev_samp_order_by.fromJson(
              (l$stddev_samp as Map<String, dynamic>));
    }
    if (data.containsKey('sum')) {
      final l$sum = data['sum'];
      result$data['sum'] = l$sum == null
          ? null
          : Inputfiles_sum_order_by.fromJson((l$sum as Map<String, dynamic>));
    }
    if (data.containsKey('var_pop')) {
      final l$var_pop = data['var_pop'];
      result$data['var_pop'] = l$var_pop == null
          ? null
          : Inputfiles_var_pop_order_by.fromJson(
              (l$var_pop as Map<String, dynamic>));
    }
    if (data.containsKey('var_samp')) {
      final l$var_samp = data['var_samp'];
      result$data['var_samp'] = l$var_samp == null
          ? null
          : Inputfiles_var_samp_order_by.fromJson(
              (l$var_samp as Map<String, dynamic>));
    }
    if (data.containsKey('variance')) {
      final l$variance = data['variance'];
      result$data['variance'] = l$variance == null
          ? null
          : Inputfiles_variance_order_by.fromJson(
              (l$variance as Map<String, dynamic>));
    }
    return InputfilesAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  Inputfiles_avg_order_by? get avg =>
      (_$data['avg'] as Inputfiles_avg_order_by?);
  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  Inputfiles_max_order_by? get max =>
      (_$data['max'] as Inputfiles_max_order_by?);
  Inputfiles_min_order_by? get min =>
      (_$data['min'] as Inputfiles_min_order_by?);
  Inputfiles_stddev_order_by? get stddev =>
      (_$data['stddev'] as Inputfiles_stddev_order_by?);
  Inputfiles_stddev_pop_order_by? get stddev_pop =>
      (_$data['stddev_pop'] as Inputfiles_stddev_pop_order_by?);
  Inputfiles_stddev_samp_order_by? get stddev_samp =>
      (_$data['stddev_samp'] as Inputfiles_stddev_samp_order_by?);
  Inputfiles_sum_order_by? get sum =>
      (_$data['sum'] as Inputfiles_sum_order_by?);
  Inputfiles_var_pop_order_by? get var_pop =>
      (_$data['var_pop'] as Inputfiles_var_pop_order_by?);
  Inputfiles_var_samp_order_by? get var_samp =>
      (_$data['var_samp'] as Inputfiles_var_samp_order_by?);
  Inputfiles_variance_order_by? get variance =>
      (_$data['variance'] as Inputfiles_variance_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('avg')) {
      final l$avg = avg;
      result$data['avg'] = l$avg?.toJson();
    }
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    if (_$data.containsKey('stddev')) {
      final l$stddev = stddev;
      result$data['stddev'] = l$stddev?.toJson();
    }
    if (_$data.containsKey('stddev_pop')) {
      final l$stddev_pop = stddev_pop;
      result$data['stddev_pop'] = l$stddev_pop?.toJson();
    }
    if (_$data.containsKey('stddev_samp')) {
      final l$stddev_samp = stddev_samp;
      result$data['stddev_samp'] = l$stddev_samp?.toJson();
    }
    if (_$data.containsKey('sum')) {
      final l$sum = sum;
      result$data['sum'] = l$sum?.toJson();
    }
    if (_$data.containsKey('var_pop')) {
      final l$var_pop = var_pop;
      result$data['var_pop'] = l$var_pop?.toJson();
    }
    if (_$data.containsKey('var_samp')) {
      final l$var_samp = var_samp;
      result$data['var_samp'] = l$var_samp?.toJson();
    }
    if (_$data.containsKey('variance')) {
      final l$variance = variance;
      result$data['variance'] = l$variance?.toJson();
    }
    return result$data;
  }

  CopyWith$InputfilesAggregateOrderBy<InputfilesAggregateOrderBy>
      get copyWith => CopyWith$InputfilesAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$avg = avg;
    final lOther$avg = other.avg;
    if (_$data.containsKey('avg') != other._$data.containsKey('avg')) {
      return false;
    }
    if (l$avg != lOther$avg) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    final l$stddev = stddev;
    final lOther$stddev = other.stddev;
    if (_$data.containsKey('stddev') != other._$data.containsKey('stddev')) {
      return false;
    }
    if (l$stddev != lOther$stddev) {
      return false;
    }
    final l$stddev_pop = stddev_pop;
    final lOther$stddev_pop = other.stddev_pop;
    if (_$data.containsKey('stddev_pop') !=
        other._$data.containsKey('stddev_pop')) {
      return false;
    }
    if (l$stddev_pop != lOther$stddev_pop) {
      return false;
    }
    final l$stddev_samp = stddev_samp;
    final lOther$stddev_samp = other.stddev_samp;
    if (_$data.containsKey('stddev_samp') !=
        other._$data.containsKey('stddev_samp')) {
      return false;
    }
    if (l$stddev_samp != lOther$stddev_samp) {
      return false;
    }
    final l$sum = sum;
    final lOther$sum = other.sum;
    if (_$data.containsKey('sum') != other._$data.containsKey('sum')) {
      return false;
    }
    if (l$sum != lOther$sum) {
      return false;
    }
    final l$var_pop = var_pop;
    final lOther$var_pop = other.var_pop;
    if (_$data.containsKey('var_pop') != other._$data.containsKey('var_pop')) {
      return false;
    }
    if (l$var_pop != lOther$var_pop) {
      return false;
    }
    final l$var_samp = var_samp;
    final lOther$var_samp = other.var_samp;
    if (_$data.containsKey('var_samp') !=
        other._$data.containsKey('var_samp')) {
      return false;
    }
    if (l$var_samp != lOther$var_samp) {
      return false;
    }
    final l$variance = variance;
    final lOther$variance = other.variance;
    if (_$data.containsKey('variance') !=
        other._$data.containsKey('variance')) {
      return false;
    }
    if (l$variance != lOther$variance) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$avg = avg;
    final l$count = count;
    final l$max = max;
    final l$min = min;
    final l$stddev = stddev;
    final l$stddev_pop = stddev_pop;
    final l$stddev_samp = stddev_samp;
    final l$sum = sum;
    final l$var_pop = var_pop;
    final l$var_samp = var_samp;
    final l$variance = variance;
    return Object.hashAll([
      _$data.containsKey('avg') ? l$avg : const {},
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
      _$data.containsKey('stddev') ? l$stddev : const {},
      _$data.containsKey('stddev_pop') ? l$stddev_pop : const {},
      _$data.containsKey('stddev_samp') ? l$stddev_samp : const {},
      _$data.containsKey('sum') ? l$sum : const {},
      _$data.containsKey('var_pop') ? l$var_pop : const {},
      _$data.containsKey('var_samp') ? l$var_samp : const {},
      _$data.containsKey('variance') ? l$variance : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesAggregateOrderBy<TRes> {
  factory CopyWith$InputfilesAggregateOrderBy(
    InputfilesAggregateOrderBy instance,
    TRes Function(InputfilesAggregateOrderBy) then,
  ) = _CopyWithImpl$InputfilesAggregateOrderBy;

  factory CopyWith$InputfilesAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputfilesAggregateOrderBy;

  TRes call({
    Inputfiles_avg_order_by? avg,
    EnumOrderBy? count,
    Inputfiles_max_order_by? max,
    Inputfiles_min_order_by? min,
    Inputfiles_stddev_order_by? stddev,
    Inputfiles_stddev_pop_order_by? stddev_pop,
    Inputfiles_stddev_samp_order_by? stddev_samp,
    Inputfiles_sum_order_by? sum,
    Inputfiles_var_pop_order_by? var_pop,
    Inputfiles_var_samp_order_by? var_samp,
    Inputfiles_variance_order_by? variance,
  });
  CopyWith$Inputfiles_avg_order_by<TRes> get avg;
  CopyWith$Inputfiles_max_order_by<TRes> get max;
  CopyWith$Inputfiles_min_order_by<TRes> get min;
  CopyWith$Inputfiles_stddev_order_by<TRes> get stddev;
  CopyWith$Inputfiles_stddev_pop_order_by<TRes> get stddev_pop;
  CopyWith$Inputfiles_stddev_samp_order_by<TRes> get stddev_samp;
  CopyWith$Inputfiles_sum_order_by<TRes> get sum;
  CopyWith$Inputfiles_var_pop_order_by<TRes> get var_pop;
  CopyWith$Inputfiles_var_samp_order_by<TRes> get var_samp;
  CopyWith$Inputfiles_variance_order_by<TRes> get variance;
}

class _CopyWithImpl$InputfilesAggregateOrderBy<TRes>
    implements CopyWith$InputfilesAggregateOrderBy<TRes> {
  _CopyWithImpl$InputfilesAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputfilesAggregateOrderBy _instance;

  final TRes Function(InputfilesAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? avg = _undefined,
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
    Object? stddev = _undefined,
    Object? stddev_pop = _undefined,
    Object? stddev_samp = _undefined,
    Object? sum = _undefined,
    Object? var_pop = _undefined,
    Object? var_samp = _undefined,
    Object? variance = _undefined,
  }) =>
      _then(InputfilesAggregateOrderBy._({
        ..._instance._$data,
        if (avg != _undefined) 'avg': (avg as Inputfiles_avg_order_by?),
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined) 'max': (max as Inputfiles_max_order_by?),
        if (min != _undefined) 'min': (min as Inputfiles_min_order_by?),
        if (stddev != _undefined)
          'stddev': (stddev as Inputfiles_stddev_order_by?),
        if (stddev_pop != _undefined)
          'stddev_pop': (stddev_pop as Inputfiles_stddev_pop_order_by?),
        if (stddev_samp != _undefined)
          'stddev_samp': (stddev_samp as Inputfiles_stddev_samp_order_by?),
        if (sum != _undefined) 'sum': (sum as Inputfiles_sum_order_by?),
        if (var_pop != _undefined)
          'var_pop': (var_pop as Inputfiles_var_pop_order_by?),
        if (var_samp != _undefined)
          'var_samp': (var_samp as Inputfiles_var_samp_order_by?),
        if (variance != _undefined)
          'variance': (variance as Inputfiles_variance_order_by?),
      }));
  CopyWith$Inputfiles_avg_order_by<TRes> get avg {
    final local$avg = _instance.avg;
    return local$avg == null
        ? CopyWith$Inputfiles_avg_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_avg_order_by(local$avg, (e) => call(avg: e));
  }

  CopyWith$Inputfiles_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Inputfiles_max_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_max_order_by(local$max, (e) => call(max: e));
  }

  CopyWith$Inputfiles_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Inputfiles_min_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_min_order_by(local$min, (e) => call(min: e));
  }

  CopyWith$Inputfiles_stddev_order_by<TRes> get stddev {
    final local$stddev = _instance.stddev;
    return local$stddev == null
        ? CopyWith$Inputfiles_stddev_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_stddev_order_by(
            local$stddev, (e) => call(stddev: e));
  }

  CopyWith$Inputfiles_stddev_pop_order_by<TRes> get stddev_pop {
    final local$stddev_pop = _instance.stddev_pop;
    return local$stddev_pop == null
        ? CopyWith$Inputfiles_stddev_pop_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_stddev_pop_order_by(
            local$stddev_pop, (e) => call(stddev_pop: e));
  }

  CopyWith$Inputfiles_stddev_samp_order_by<TRes> get stddev_samp {
    final local$stddev_samp = _instance.stddev_samp;
    return local$stddev_samp == null
        ? CopyWith$Inputfiles_stddev_samp_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_stddev_samp_order_by(
            local$stddev_samp, (e) => call(stddev_samp: e));
  }

  CopyWith$Inputfiles_sum_order_by<TRes> get sum {
    final local$sum = _instance.sum;
    return local$sum == null
        ? CopyWith$Inputfiles_sum_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_sum_order_by(local$sum, (e) => call(sum: e));
  }

  CopyWith$Inputfiles_var_pop_order_by<TRes> get var_pop {
    final local$var_pop = _instance.var_pop;
    return local$var_pop == null
        ? CopyWith$Inputfiles_var_pop_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_var_pop_order_by(
            local$var_pop, (e) => call(var_pop: e));
  }

  CopyWith$Inputfiles_var_samp_order_by<TRes> get var_samp {
    final local$var_samp = _instance.var_samp;
    return local$var_samp == null
        ? CopyWith$Inputfiles_var_samp_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_var_samp_order_by(
            local$var_samp, (e) => call(var_samp: e));
  }

  CopyWith$Inputfiles_variance_order_by<TRes> get variance {
    final local$variance = _instance.variance;
    return local$variance == null
        ? CopyWith$Inputfiles_variance_order_by.stub(_then(_instance))
        : CopyWith$Inputfiles_variance_order_by(
            local$variance, (e) => call(variance: e));
  }
}

class _CopyWithStubImpl$InputfilesAggregateOrderBy<TRes>
    implements CopyWith$InputfilesAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputfilesAggregateOrderBy(this._res);

  TRes _res;

  call({
    Inputfiles_avg_order_by? avg,
    EnumOrderBy? count,
    Inputfiles_max_order_by? max,
    Inputfiles_min_order_by? min,
    Inputfiles_stddev_order_by? stddev,
    Inputfiles_stddev_pop_order_by? stddev_pop,
    Inputfiles_stddev_samp_order_by? stddev_samp,
    Inputfiles_sum_order_by? sum,
    Inputfiles_var_pop_order_by? var_pop,
    Inputfiles_var_samp_order_by? var_samp,
    Inputfiles_variance_order_by? variance,
  }) =>
      _res;
  CopyWith$Inputfiles_avg_order_by<TRes> get avg =>
      CopyWith$Inputfiles_avg_order_by.stub(_res);
  CopyWith$Inputfiles_max_order_by<TRes> get max =>
      CopyWith$Inputfiles_max_order_by.stub(_res);
  CopyWith$Inputfiles_min_order_by<TRes> get min =>
      CopyWith$Inputfiles_min_order_by.stub(_res);
  CopyWith$Inputfiles_stddev_order_by<TRes> get stddev =>
      CopyWith$Inputfiles_stddev_order_by.stub(_res);
  CopyWith$Inputfiles_stddev_pop_order_by<TRes> get stddev_pop =>
      CopyWith$Inputfiles_stddev_pop_order_by.stub(_res);
  CopyWith$Inputfiles_stddev_samp_order_by<TRes> get stddev_samp =>
      CopyWith$Inputfiles_stddev_samp_order_by.stub(_res);
  CopyWith$Inputfiles_sum_order_by<TRes> get sum =>
      CopyWith$Inputfiles_sum_order_by.stub(_res);
  CopyWith$Inputfiles_var_pop_order_by<TRes> get var_pop =>
      CopyWith$Inputfiles_var_pop_order_by.stub(_res);
  CopyWith$Inputfiles_var_samp_order_by<TRes> get var_samp =>
      CopyWith$Inputfiles_var_samp_order_by.stub(_res);
  CopyWith$Inputfiles_variance_order_by<TRes> get variance =>
      CopyWith$Inputfiles_variance_order_by.stub(_res);
}

class InputfilesArrRelInsertInput {
  factory InputfilesArrRelInsertInput({
    required List<InputfilesInsertInput> data,
    InputfilesOnConflict? onConflict,
  }) =>
      InputfilesArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputfilesArrRelInsertInput._(this._$data);

  factory InputfilesArrRelInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => InputfilesInsertInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputfilesOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputfilesArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputfilesInsertInput> get data =>
      (_$data['data'] as List<InputfilesInsertInput>);
  InputfilesOnConflict? get onConflict =>
      (_$data['onConflict'] as InputfilesOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputfilesArrRelInsertInput<InputfilesArrRelInsertInput>
      get copyWith => CopyWith$InputfilesArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesArrRelInsertInput<TRes> {
  factory CopyWith$InputfilesArrRelInsertInput(
    InputfilesArrRelInsertInput instance,
    TRes Function(InputfilesArrRelInsertInput) then,
  ) = _CopyWithImpl$InputfilesArrRelInsertInput;

  factory CopyWith$InputfilesArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputfilesArrRelInsertInput;

  TRes call({
    List<InputfilesInsertInput>? data,
    InputfilesOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputfilesInsertInput> Function(
              Iterable<CopyWith$InputfilesInsertInput<InputfilesInsertInput>>)
          _fn);
  CopyWith$InputfilesOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputfilesArrRelInsertInput<TRes>
    implements CopyWith$InputfilesArrRelInsertInput<TRes> {
  _CopyWithImpl$InputfilesArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputfilesArrRelInsertInput _instance;

  final TRes Function(InputfilesArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputfilesArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputfilesInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputfilesOnConflict?),
      }));
  TRes data(
          Iterable<InputfilesInsertInput> Function(
                  Iterable<
                      CopyWith$InputfilesInsertInput<InputfilesInsertInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data.map((e) => CopyWith$InputfilesInsertInput(
                e,
                (i) => i,
              ))).toList());
  CopyWith$InputfilesOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputfilesOnConflict.stub(_then(_instance))
        : CopyWith$InputfilesOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputfilesArrRelInsertInput<TRes>
    implements CopyWith$InputfilesArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputfilesArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputfilesInsertInput>? data,
    InputfilesOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputfilesOnConflict<TRes> get onConflict =>
      CopyWith$InputfilesOnConflict.stub(_res);
}

class InputfilesBoolExp {
  factory InputfilesBoolExp({
    List<InputfilesBoolExp>? $_and,
    InputfilesBoolExp? $_not,
    List<InputfilesBoolExp>? $_or,
    InputbucketsBoolExp? bucket,
    InputStringComparisonExp? bucketId,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? etag,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isUploaded,
    InputStringComparisonExp? mimeType,
    InputStringComparisonExp? name,
    InputIntComparisonExp? size,
    InputTimestamptzComparisonExp? updatedAt,
    InputUuidComparisonExp? uploadedByUserId,
  }) =>
      InputfilesBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (bucket != null) r'bucket': bucket,
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (isUploaded != null) r'isUploaded': isUploaded,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  InputfilesBoolExp._(this._$data);

  factory InputfilesBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputfilesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputfilesBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputfilesBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bucket')) {
      final l$bucket = data['bucket'];
      result$data['bucket'] = l$bucket == null
          ? null
          : InputbucketsBoolExp.fromJson((l$bucket as Map<String, dynamic>));
    }
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = l$bucketId == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$bucketId as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] = l$etag == null
          ? null
          : InputStringComparisonExp.fromJson((l$etag as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('isUploaded')) {
      final l$isUploaded = data['isUploaded'];
      result$data['isUploaded'] = l$isUploaded == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$isUploaded as Map<String, dynamic>));
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = l$mimeType == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$mimeType as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : InputStringComparisonExp.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : InputIntComparisonExp.fromJson((l$size as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : InputUuidComparisonExp.fromJson(
              (l$uploadedByUserId as Map<String, dynamic>));
    }
    return InputfilesBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputfilesBoolExp>? get $_and =>
      (_$data['_and'] as List<InputfilesBoolExp>?);
  InputfilesBoolExp? get $_not => (_$data['_not'] as InputfilesBoolExp?);
  List<InputfilesBoolExp>? get $_or =>
      (_$data['_or'] as List<InputfilesBoolExp>?);
  InputbucketsBoolExp? get bucket => (_$data['bucket'] as InputbucketsBoolExp?);
  InputStringComparisonExp? get bucketId =>
      (_$data['bucketId'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputStringComparisonExp? get etag =>
      (_$data['etag'] as InputStringComparisonExp?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputBooleanComparisonExp? get isUploaded =>
      (_$data['isUploaded'] as InputBooleanComparisonExp?);
  InputStringComparisonExp? get mimeType =>
      (_$data['mimeType'] as InputStringComparisonExp?);
  InputStringComparisonExp? get name =>
      (_$data['name'] as InputStringComparisonExp?);
  InputIntComparisonExp? get size => (_$data['size'] as InputIntComparisonExp?);
  InputTimestamptzComparisonExp? get updatedAt =>
      (_$data['updatedAt'] as InputTimestamptzComparisonExp?);
  InputUuidComparisonExp? get uploadedByUserId =>
      (_$data['uploadedByUserId'] as InputUuidComparisonExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bucket')) {
      final l$bucket = bucket;
      result$data['bucket'] = l$bucket?.toJson();
    }
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] = l$bucketId?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('isUploaded')) {
      final l$isUploaded = isUploaded;
      result$data['isUploaded'] = l$isUploaded?.toJson();
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] = l$mimeType?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId?.toJson();
    }
    return result$data;
  }

  CopyWith$InputfilesBoolExp<InputfilesBoolExp> get copyWith =>
      CopyWith$InputfilesBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$bucket = bucket;
    final lOther$bucket = other.bucket;
    if (_$data.containsKey('bucket') != other._$data.containsKey('bucket')) {
      return false;
    }
    if (l$bucket != lOther$bucket) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isUploaded = isUploaded;
    final lOther$isUploaded = other.isUploaded;
    if (_$data.containsKey('isUploaded') !=
        other._$data.containsKey('isUploaded')) {
      return false;
    }
    if (l$isUploaded != lOther$isUploaded) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$bucket = bucket;
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$isUploaded = isUploaded;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('bucket') ? l$bucket : const {},
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isUploaded') ? l$isUploaded : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesBoolExp<TRes> {
  factory CopyWith$InputfilesBoolExp(
    InputfilesBoolExp instance,
    TRes Function(InputfilesBoolExp) then,
  ) = _CopyWithImpl$InputfilesBoolExp;

  factory CopyWith$InputfilesBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputfilesBoolExp;

  TRes call({
    List<InputfilesBoolExp>? $_and,
    InputfilesBoolExp? $_not,
    List<InputfilesBoolExp>? $_or,
    InputbucketsBoolExp? bucket,
    InputStringComparisonExp? bucketId,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? etag,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isUploaded,
    InputStringComparisonExp? mimeType,
    InputStringComparisonExp? name,
    InputIntComparisonExp? size,
    InputTimestamptzComparisonExp? updatedAt,
    InputUuidComparisonExp? uploadedByUserId,
  });
  TRes $_and(
      Iterable<InputfilesBoolExp>? Function(
              Iterable<CopyWith$InputfilesBoolExp<InputfilesBoolExp>>?)
          _fn);
  CopyWith$InputfilesBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputfilesBoolExp>? Function(
              Iterable<CopyWith$InputfilesBoolExp<InputfilesBoolExp>>?)
          _fn);
  CopyWith$InputbucketsBoolExp<TRes> get bucket;
  CopyWith$InputStringComparisonExp<TRes> get bucketId;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputStringComparisonExp<TRes> get etag;
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputBooleanComparisonExp<TRes> get isUploaded;
  CopyWith$InputStringComparisonExp<TRes> get mimeType;
  CopyWith$InputStringComparisonExp<TRes> get name;
  CopyWith$InputIntComparisonExp<TRes> get size;
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt;
  CopyWith$InputUuidComparisonExp<TRes> get uploadedByUserId;
}

class _CopyWithImpl$InputfilesBoolExp<TRes>
    implements CopyWith$InputfilesBoolExp<TRes> {
  _CopyWithImpl$InputfilesBoolExp(
    this._instance,
    this._then,
  );

  final InputfilesBoolExp _instance;

  final TRes Function(InputfilesBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? bucket = _undefined,
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? isUploaded = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(InputfilesBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<InputfilesBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputfilesBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<InputfilesBoolExp>?),
        if (bucket != _undefined) 'bucket': (bucket as InputbucketsBoolExp?),
        if (bucketId != _undefined)
          'bucketId': (bucketId as InputStringComparisonExp?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (etag != _undefined) 'etag': (etag as InputStringComparisonExp?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (isUploaded != _undefined)
          'isUploaded': (isUploaded as InputBooleanComparisonExp?),
        if (mimeType != _undefined)
          'mimeType': (mimeType as InputStringComparisonExp?),
        if (name != _undefined) 'name': (name as InputStringComparisonExp?),
        if (size != _undefined) 'size': (size as InputIntComparisonExp?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as InputTimestamptzComparisonExp?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as InputUuidComparisonExp?),
      }));
  TRes $_and(
          Iterable<InputfilesBoolExp>? Function(
                  Iterable<CopyWith$InputfilesBoolExp<InputfilesBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$InputfilesBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputfilesBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputfilesBoolExp.stub(_then(_instance))
        : CopyWith$InputfilesBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputfilesBoolExp>? Function(
                  Iterable<CopyWith$InputfilesBoolExp<InputfilesBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$InputfilesBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputbucketsBoolExp<TRes> get bucket {
    final local$bucket = _instance.bucket;
    return local$bucket == null
        ? CopyWith$InputbucketsBoolExp.stub(_then(_instance))
        : CopyWith$InputbucketsBoolExp(local$bucket, (e) => call(bucket: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get bucketId {
    final local$bucketId = _instance.bucketId;
    return local$bucketId == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$bucketId, (e) => call(bucketId: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get etag {
    final local$etag = _instance.etag;
    return local$etag == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$etag, (e) => call(etag: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get isUploaded {
    final local$isUploaded = _instance.isUploaded;
    return local$isUploaded == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$isUploaded, (e) => call(isUploaded: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get mimeType {
    final local$mimeType = _instance.mimeType;
    return local$mimeType == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$mimeType, (e) => call(mimeType: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(local$name, (e) => call(name: e));
  }

  CopyWith$InputIntComparisonExp<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$InputIntComparisonExp.stub(_then(_instance))
        : CopyWith$InputIntComparisonExp(local$size, (e) => call(size: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get uploadedByUserId {
    final local$uploadedByUserId = _instance.uploadedByUserId;
    return local$uploadedByUserId == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(
            local$uploadedByUserId, (e) => call(uploadedByUserId: e));
  }
}

class _CopyWithStubImpl$InputfilesBoolExp<TRes>
    implements CopyWith$InputfilesBoolExp<TRes> {
  _CopyWithStubImpl$InputfilesBoolExp(this._res);

  TRes _res;

  call({
    List<InputfilesBoolExp>? $_and,
    InputfilesBoolExp? $_not,
    List<InputfilesBoolExp>? $_or,
    InputbucketsBoolExp? bucket,
    InputStringComparisonExp? bucketId,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? etag,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isUploaded,
    InputStringComparisonExp? mimeType,
    InputStringComparisonExp? name,
    InputIntComparisonExp? size,
    InputTimestamptzComparisonExp? updatedAt,
    InputUuidComparisonExp? uploadedByUserId,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputfilesBoolExp<TRes> get $_not =>
      CopyWith$InputfilesBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputbucketsBoolExp<TRes> get bucket =>
      CopyWith$InputbucketsBoolExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get bucketId =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get etag =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get isUploaded =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get mimeType =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get name =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputIntComparisonExp<TRes> get size =>
      CopyWith$InputIntComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get uploadedByUserId =>
      CopyWith$InputUuidComparisonExp.stub(_res);
}

class InputfilesIncInput {
  factory InputfilesIncInput({int? size}) => InputfilesIncInput._({
        if (size != null) r'size': size,
      });

  InputfilesIncInput._(this._$data);

  factory InputfilesIncInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = (l$size as int?);
    }
    return InputfilesIncInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get size => (_$data['size'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size;
    }
    return result$data;
  }

  CopyWith$InputfilesIncInput<InputfilesIncInput> get copyWith =>
      CopyWith$InputfilesIncInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesIncInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$InputfilesIncInput<TRes> {
  factory CopyWith$InputfilesIncInput(
    InputfilesIncInput instance,
    TRes Function(InputfilesIncInput) then,
  ) = _CopyWithImpl$InputfilesIncInput;

  factory CopyWith$InputfilesIncInput.stub(TRes res) =
      _CopyWithStubImpl$InputfilesIncInput;

  TRes call({int? size});
}

class _CopyWithImpl$InputfilesIncInput<TRes>
    implements CopyWith$InputfilesIncInput<TRes> {
  _CopyWithImpl$InputfilesIncInput(
    this._instance,
    this._then,
  );

  final InputfilesIncInput _instance;

  final TRes Function(InputfilesIncInput) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) => _then(InputfilesIncInput._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as int?),
      }));
}

class _CopyWithStubImpl$InputfilesIncInput<TRes>
    implements CopyWith$InputfilesIncInput<TRes> {
  _CopyWithStubImpl$InputfilesIncInput(this._res);

  TRes _res;

  call({int? size}) => _res;
}

class InputfilesInsertInput {
  factory InputfilesInsertInput({
    InputbucketsObjRelInsertInput? bucket,
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      InputfilesInsertInput._({
        if (bucket != null) r'bucket': bucket,
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (isUploaded != null) r'isUploaded': isUploaded,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  InputfilesInsertInput._(this._$data);

  factory InputfilesInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucket')) {
      final l$bucket = data['bucket'];
      result$data['bucket'] = l$bucket == null
          ? null
          : InputbucketsObjRelInsertInput.fromJson(
              (l$bucket as Map<String, dynamic>));
    }
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = (l$bucketId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] = (l$etag as String?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isUploaded')) {
      final l$isUploaded = data['isUploaded'];
      result$data['isUploaded'] = (l$isUploaded as bool?);
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = (l$mimeType as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = (l$size as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = (l$uploadedByUserId as String?);
    }
    return InputfilesInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputbucketsObjRelInsertInput? get bucket =>
      (_$data['bucket'] as InputbucketsObjRelInsertInput?);
  String? get bucketId => (_$data['bucketId'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get etag => (_$data['etag'] as String?);
  String? get id => (_$data['id'] as String?);
  bool? get isUploaded => (_$data['isUploaded'] as bool?);
  String? get mimeType => (_$data['mimeType'] as String?);
  String? get name => (_$data['name'] as String?);
  int? get size => (_$data['size'] as int?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  String? get uploadedByUserId => (_$data['uploadedByUserId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucket')) {
      final l$bucket = bucket;
      result$data['bucket'] = l$bucket?.toJson();
    }
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] = l$bucketId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isUploaded')) {
      final l$isUploaded = isUploaded;
      result$data['isUploaded'] = l$isUploaded;
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] = l$mimeType;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId;
    }
    return result$data;
  }

  CopyWith$InputfilesInsertInput<InputfilesInsertInput> get copyWith =>
      CopyWith$InputfilesInsertInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucket = bucket;
    final lOther$bucket = other.bucket;
    if (_$data.containsKey('bucket') != other._$data.containsKey('bucket')) {
      return false;
    }
    if (l$bucket != lOther$bucket) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isUploaded = isUploaded;
    final lOther$isUploaded = other.isUploaded;
    if (_$data.containsKey('isUploaded') !=
        other._$data.containsKey('isUploaded')) {
      return false;
    }
    if (l$isUploaded != lOther$isUploaded) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucket = bucket;
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$isUploaded = isUploaded;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucket') ? l$bucket : const {},
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isUploaded') ? l$isUploaded : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesInsertInput<TRes> {
  factory CopyWith$InputfilesInsertInput(
    InputfilesInsertInput instance,
    TRes Function(InputfilesInsertInput) then,
  ) = _CopyWithImpl$InputfilesInsertInput;

  factory CopyWith$InputfilesInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputfilesInsertInput;

  TRes call({
    InputbucketsObjRelInsertInput? bucket,
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  });
  CopyWith$InputbucketsObjRelInsertInput<TRes> get bucket;
}

class _CopyWithImpl$InputfilesInsertInput<TRes>
    implements CopyWith$InputfilesInsertInput<TRes> {
  _CopyWithImpl$InputfilesInsertInput(
    this._instance,
    this._then,
  );

  final InputfilesInsertInput _instance;

  final TRes Function(InputfilesInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? bucket = _undefined,
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? isUploaded = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(InputfilesInsertInput._({
        ..._instance._$data,
        if (bucket != _undefined)
          'bucket': (bucket as InputbucketsObjRelInsertInput?),
        if (bucketId != _undefined) 'bucketId': (bucketId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (etag != _undefined) 'etag': (etag as String?),
        if (id != _undefined) 'id': (id as String?),
        if (isUploaded != _undefined) 'isUploaded': (isUploaded as bool?),
        if (mimeType != _undefined) 'mimeType': (mimeType as String?),
        if (name != _undefined) 'name': (name as String?),
        if (size != _undefined) 'size': (size as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as String?),
      }));
  CopyWith$InputbucketsObjRelInsertInput<TRes> get bucket {
    final local$bucket = _instance.bucket;
    return local$bucket == null
        ? CopyWith$InputbucketsObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputbucketsObjRelInsertInput(
            local$bucket, (e) => call(bucket: e));
  }
}

class _CopyWithStubImpl$InputfilesInsertInput<TRes>
    implements CopyWith$InputfilesInsertInput<TRes> {
  _CopyWithStubImpl$InputfilesInsertInput(this._res);

  TRes _res;

  call({
    InputbucketsObjRelInsertInput? bucket,
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      _res;
  CopyWith$InputbucketsObjRelInsertInput<TRes> get bucket =>
      CopyWith$InputbucketsObjRelInsertInput.stub(_res);
}

class InputfilesOnConflict {
  factory InputfilesOnConflict({
    required EnumfilesConstraint constraint,
    required List<EnumfilesUpdateColumn> update_columns,
    InputfilesBoolExp? where,
  }) =>
      InputfilesOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputfilesOnConflict._(this._$data);

  factory InputfilesOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumfilesConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumfilesUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputfilesBoolExp.fromJson((l$where as Map<String, dynamic>));
    }
    return InputfilesOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumfilesConstraint get constraint =>
      (_$data['constraint'] as EnumfilesConstraint);
  List<EnumfilesUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumfilesUpdateColumn>);
  InputfilesBoolExp? get where => (_$data['where'] as InputfilesBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] = toJson$EnumfilesConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] =
        l$update_columns.map((e) => toJson$EnumfilesUpdateColumn(e)).toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputfilesOnConflict<InputfilesOnConflict> get copyWith =>
      CopyWith$InputfilesOnConflict(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesOnConflict) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesOnConflict<TRes> {
  factory CopyWith$InputfilesOnConflict(
    InputfilesOnConflict instance,
    TRes Function(InputfilesOnConflict) then,
  ) = _CopyWithImpl$InputfilesOnConflict;

  factory CopyWith$InputfilesOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputfilesOnConflict;

  TRes call({
    EnumfilesConstraint? constraint,
    List<EnumfilesUpdateColumn>? update_columns,
    InputfilesBoolExp? where,
  });
  CopyWith$InputfilesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputfilesOnConflict<TRes>
    implements CopyWith$InputfilesOnConflict<TRes> {
  _CopyWithImpl$InputfilesOnConflict(
    this._instance,
    this._then,
  );

  final InputfilesOnConflict _instance;

  final TRes Function(InputfilesOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputfilesOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumfilesConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns': (update_columns as List<EnumfilesUpdateColumn>),
        if (where != _undefined) 'where': (where as InputfilesBoolExp?),
      }));
  CopyWith$InputfilesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputfilesBoolExp.stub(_then(_instance))
        : CopyWith$InputfilesBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputfilesOnConflict<TRes>
    implements CopyWith$InputfilesOnConflict<TRes> {
  _CopyWithStubImpl$InputfilesOnConflict(this._res);

  TRes _res;

  call({
    EnumfilesConstraint? constraint,
    List<EnumfilesUpdateColumn>? update_columns,
    InputfilesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputfilesBoolExp<TRes> get where =>
      CopyWith$InputfilesBoolExp.stub(_res);
}

class InputfilesOrderBy {
  factory InputfilesOrderBy({
    InputbucketsOrderBy? bucket,
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? isUploaded,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      InputfilesOrderBy._({
        if (bucket != null) r'bucket': bucket,
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (isUploaded != null) r'isUploaded': isUploaded,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  InputfilesOrderBy._(this._$data);

  factory InputfilesOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucket')) {
      final l$bucket = data['bucket'];
      result$data['bucket'] = l$bucket == null
          ? null
          : InputbucketsOrderBy.fromJson((l$bucket as Map<String, dynamic>));
    }
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = l$bucketId == null
          ? null
          : fromJson$EnumOrderBy((l$bucketId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] =
          l$etag == null ? null : fromJson$EnumOrderBy((l$etag as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('isUploaded')) {
      final l$isUploaded = data['isUploaded'];
      result$data['isUploaded'] = l$isUploaded == null
          ? null
          : fromJson$EnumOrderBy((l$isUploaded as String));
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = l$mimeType == null
          ? null
          : fromJson$EnumOrderBy((l$mimeType as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$EnumOrderBy((l$name as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : fromJson$EnumOrderBy((l$uploadedByUserId as String));
    }
    return InputfilesOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  InputbucketsOrderBy? get bucket => (_$data['bucket'] as InputbucketsOrderBy?);
  EnumOrderBy? get bucketId => (_$data['bucketId'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get etag => (_$data['etag'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get isUploaded => (_$data['isUploaded'] as EnumOrderBy?);
  EnumOrderBy? get mimeType => (_$data['mimeType'] as EnumOrderBy?);
  EnumOrderBy? get name => (_$data['name'] as EnumOrderBy?);
  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  EnumOrderBy? get uploadedByUserId =>
      (_$data['uploadedByUserId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucket')) {
      final l$bucket = bucket;
      result$data['bucket'] = l$bucket?.toJson();
    }
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] =
          l$bucketId == null ? null : toJson$EnumOrderBy(l$bucketId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag == null ? null : toJson$EnumOrderBy(l$etag);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('isUploaded')) {
      final l$isUploaded = isUploaded;
      result$data['isUploaded'] =
          l$isUploaded == null ? null : toJson$EnumOrderBy(l$isUploaded);
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] =
          l$mimeType == null ? null : toJson$EnumOrderBy(l$mimeType);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$EnumOrderBy(l$name);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : toJson$EnumOrderBy(l$uploadedByUserId);
    }
    return result$data;
  }

  CopyWith$InputfilesOrderBy<InputfilesOrderBy> get copyWith =>
      CopyWith$InputfilesOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucket = bucket;
    final lOther$bucket = other.bucket;
    if (_$data.containsKey('bucket') != other._$data.containsKey('bucket')) {
      return false;
    }
    if (l$bucket != lOther$bucket) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isUploaded = isUploaded;
    final lOther$isUploaded = other.isUploaded;
    if (_$data.containsKey('isUploaded') !=
        other._$data.containsKey('isUploaded')) {
      return false;
    }
    if (l$isUploaded != lOther$isUploaded) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucket = bucket;
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$isUploaded = isUploaded;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucket') ? l$bucket : const {},
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isUploaded') ? l$isUploaded : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesOrderBy<TRes> {
  factory CopyWith$InputfilesOrderBy(
    InputfilesOrderBy instance,
    TRes Function(InputfilesOrderBy) then,
  ) = _CopyWithImpl$InputfilesOrderBy;

  factory CopyWith$InputfilesOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputfilesOrderBy;

  TRes call({
    InputbucketsOrderBy? bucket,
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? isUploaded,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  });
  CopyWith$InputbucketsOrderBy<TRes> get bucket;
}

class _CopyWithImpl$InputfilesOrderBy<TRes>
    implements CopyWith$InputfilesOrderBy<TRes> {
  _CopyWithImpl$InputfilesOrderBy(
    this._instance,
    this._then,
  );

  final InputfilesOrderBy _instance;

  final TRes Function(InputfilesOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? bucket = _undefined,
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? isUploaded = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(InputfilesOrderBy._({
        ..._instance._$data,
        if (bucket != _undefined) 'bucket': (bucket as InputbucketsOrderBy?),
        if (bucketId != _undefined) 'bucketId': (bucketId as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (etag != _undefined) 'etag': (etag as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (isUploaded != _undefined)
          'isUploaded': (isUploaded as EnumOrderBy?),
        if (mimeType != _undefined) 'mimeType': (mimeType as EnumOrderBy?),
        if (name != _undefined) 'name': (name as EnumOrderBy?),
        if (size != _undefined) 'size': (size as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as EnumOrderBy?),
      }));
  CopyWith$InputbucketsOrderBy<TRes> get bucket {
    final local$bucket = _instance.bucket;
    return local$bucket == null
        ? CopyWith$InputbucketsOrderBy.stub(_then(_instance))
        : CopyWith$InputbucketsOrderBy(local$bucket, (e) => call(bucket: e));
  }
}

class _CopyWithStubImpl$InputfilesOrderBy<TRes>
    implements CopyWith$InputfilesOrderBy<TRes> {
  _CopyWithStubImpl$InputfilesOrderBy(this._res);

  TRes _res;

  call({
    InputbucketsOrderBy? bucket,
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? isUploaded,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      _res;
  CopyWith$InputbucketsOrderBy<TRes> get bucket =>
      CopyWith$InputbucketsOrderBy.stub(_res);
}

class InputfilesPkColumnsInput {
  factory InputfilesPkColumnsInput({required String id}) =>
      InputfilesPkColumnsInput._({
        r'id': id,
      });

  InputfilesPkColumnsInput._(this._$data);

  factory InputfilesPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputfilesPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputfilesPkColumnsInput<InputfilesPkColumnsInput> get copyWith =>
      CopyWith$InputfilesPkColumnsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputfilesPkColumnsInput<TRes> {
  factory CopyWith$InputfilesPkColumnsInput(
    InputfilesPkColumnsInput instance,
    TRes Function(InputfilesPkColumnsInput) then,
  ) = _CopyWithImpl$InputfilesPkColumnsInput;

  factory CopyWith$InputfilesPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputfilesPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputfilesPkColumnsInput<TRes>
    implements CopyWith$InputfilesPkColumnsInput<TRes> {
  _CopyWithImpl$InputfilesPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputfilesPkColumnsInput _instance;

  final TRes Function(InputfilesPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) => _then(InputfilesPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputfilesPkColumnsInput<TRes>
    implements CopyWith$InputfilesPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputfilesPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputfilesSetInput {
  factory InputfilesSetInput({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      InputfilesSetInput._({
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (isUploaded != null) r'isUploaded': isUploaded,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  InputfilesSetInput._(this._$data);

  factory InputfilesSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = (l$bucketId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] = (l$etag as String?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isUploaded')) {
      final l$isUploaded = data['isUploaded'];
      result$data['isUploaded'] = (l$isUploaded as bool?);
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = (l$mimeType as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = (l$size as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = (l$uploadedByUserId as String?);
    }
    return InputfilesSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get bucketId => (_$data['bucketId'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get etag => (_$data['etag'] as String?);
  String? get id => (_$data['id'] as String?);
  bool? get isUploaded => (_$data['isUploaded'] as bool?);
  String? get mimeType => (_$data['mimeType'] as String?);
  String? get name => (_$data['name'] as String?);
  int? get size => (_$data['size'] as int?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  String? get uploadedByUserId => (_$data['uploadedByUserId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] = l$bucketId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isUploaded')) {
      final l$isUploaded = isUploaded;
      result$data['isUploaded'] = l$isUploaded;
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] = l$mimeType;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId;
    }
    return result$data;
  }

  CopyWith$InputfilesSetInput<InputfilesSetInput> get copyWith =>
      CopyWith$InputfilesSetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesSetInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isUploaded = isUploaded;
    final lOther$isUploaded = other.isUploaded;
    if (_$data.containsKey('isUploaded') !=
        other._$data.containsKey('isUploaded')) {
      return false;
    }
    if (l$isUploaded != lOther$isUploaded) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$isUploaded = isUploaded;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isUploaded') ? l$isUploaded : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$InputfilesSetInput<TRes> {
  factory CopyWith$InputfilesSetInput(
    InputfilesSetInput instance,
    TRes Function(InputfilesSetInput) then,
  ) = _CopyWithImpl$InputfilesSetInput;

  factory CopyWith$InputfilesSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputfilesSetInput;

  TRes call({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  });
}

class _CopyWithImpl$InputfilesSetInput<TRes>
    implements CopyWith$InputfilesSetInput<TRes> {
  _CopyWithImpl$InputfilesSetInput(
    this._instance,
    this._then,
  );

  final InputfilesSetInput _instance;

  final TRes Function(InputfilesSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? isUploaded = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(InputfilesSetInput._({
        ..._instance._$data,
        if (bucketId != _undefined) 'bucketId': (bucketId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (etag != _undefined) 'etag': (etag as String?),
        if (id != _undefined) 'id': (id as String?),
        if (isUploaded != _undefined) 'isUploaded': (isUploaded as bool?),
        if (mimeType != _undefined) 'mimeType': (mimeType as String?),
        if (name != _undefined) 'name': (name as String?),
        if (size != _undefined) 'size': (size as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as String?),
      }));
}

class _CopyWithStubImpl$InputfilesSetInput<TRes>
    implements CopyWith$InputfilesSetInput<TRes> {
  _CopyWithStubImpl$InputfilesSetInput(this._res);

  TRes _res;

  call({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      _res;
}

class InputfilesUpdates {
  factory InputfilesUpdates({
    InputfilesIncInput? $_inc,
    InputfilesSetInput? $_set,
    required InputfilesBoolExp where,
  }) =>
      InputfilesUpdates._({
        if ($_inc != null) r'_inc': $_inc,
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputfilesUpdates._(this._$data);

  factory InputfilesUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_inc')) {
      final l$$_inc = data['_inc'];
      result$data['_inc'] = l$$_inc == null
          ? null
          : InputfilesIncInput.fromJson((l$$_inc as Map<String, dynamic>));
    }
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputfilesSetInput.fromJson((l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputfilesBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputfilesUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputfilesIncInput? get $_inc => (_$data['_inc'] as InputfilesIncInput?);
  InputfilesSetInput? get $_set => (_$data['_set'] as InputfilesSetInput?);
  InputfilesBoolExp get where => (_$data['where'] as InputfilesBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_inc')) {
      final l$$_inc = $_inc;
      result$data['_inc'] = l$$_inc?.toJson();
    }
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputfilesUpdates<InputfilesUpdates> get copyWith =>
      CopyWith$InputfilesUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputfilesUpdates) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_inc = $_inc;
    final lOther$$_inc = other.$_inc;
    if (_$data.containsKey('_inc') != other._$data.containsKey('_inc')) {
      return false;
    }
    if (l$$_inc != lOther$$_inc) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_inc = $_inc;
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_inc') ? l$$_inc : const {},
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputfilesUpdates<TRes> {
  factory CopyWith$InputfilesUpdates(
    InputfilesUpdates instance,
    TRes Function(InputfilesUpdates) then,
  ) = _CopyWithImpl$InputfilesUpdates;

  factory CopyWith$InputfilesUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputfilesUpdates;

  TRes call({
    InputfilesIncInput? $_inc,
    InputfilesSetInput? $_set,
    InputfilesBoolExp? where,
  });
  CopyWith$InputfilesIncInput<TRes> get $_inc;
  CopyWith$InputfilesSetInput<TRes> get $_set;
  CopyWith$InputfilesBoolExp<TRes> get where;
}

class _CopyWithImpl$InputfilesUpdates<TRes>
    implements CopyWith$InputfilesUpdates<TRes> {
  _CopyWithImpl$InputfilesUpdates(
    this._instance,
    this._then,
  );

  final InputfilesUpdates _instance;

  final TRes Function(InputfilesUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_inc = _undefined,
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputfilesUpdates._({
        ..._instance._$data,
        if ($_inc != _undefined) '_inc': ($_inc as InputfilesIncInput?),
        if ($_set != _undefined) '_set': ($_set as InputfilesSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputfilesBoolExp),
      }));
  CopyWith$InputfilesIncInput<TRes> get $_inc {
    final local$$_inc = _instance.$_inc;
    return local$$_inc == null
        ? CopyWith$InputfilesIncInput.stub(_then(_instance))
        : CopyWith$InputfilesIncInput(local$$_inc, (e) => call($_inc: e));
  }

  CopyWith$InputfilesSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputfilesSetInput.stub(_then(_instance))
        : CopyWith$InputfilesSetInput(local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputfilesBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputfilesBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputfilesUpdates<TRes>
    implements CopyWith$InputfilesUpdates<TRes> {
  _CopyWithStubImpl$InputfilesUpdates(this._res);

  TRes _res;

  call({
    InputfilesIncInput? $_inc,
    InputfilesSetInput? $_set,
    InputfilesBoolExp? where,
  }) =>
      _res;
  CopyWith$InputfilesIncInput<TRes> get $_inc =>
      CopyWith$InputfilesIncInput.stub(_res);
  CopyWith$InputfilesSetInput<TRes> get $_set =>
      CopyWith$InputfilesSetInput.stub(_res);
  CopyWith$InputfilesBoolExp<TRes> get where =>
      CopyWith$InputfilesBoolExp.stub(_res);
}

class Inputfiles_avg_order_by {
  factory Inputfiles_avg_order_by({EnumOrderBy? size}) =>
      Inputfiles_avg_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_avg_order_by._(this._$data);

  factory Inputfiles_avg_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_avg_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_avg_order_by<Inputfiles_avg_order_by> get copyWith =>
      CopyWith$Inputfiles_avg_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_avg_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_avg_order_by<TRes> {
  factory CopyWith$Inputfiles_avg_order_by(
    Inputfiles_avg_order_by instance,
    TRes Function(Inputfiles_avg_order_by) then,
  ) = _CopyWithImpl$Inputfiles_avg_order_by;

  factory CopyWith$Inputfiles_avg_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_avg_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_avg_order_by<TRes>
    implements CopyWith$Inputfiles_avg_order_by<TRes> {
  _CopyWithImpl$Inputfiles_avg_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_avg_order_by _instance;

  final TRes Function(Inputfiles_avg_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) => _then(Inputfiles_avg_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_avg_order_by<TRes>
    implements CopyWith$Inputfiles_avg_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_avg_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_max_order_by {
  factory Inputfiles_max_order_by({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      Inputfiles_max_order_by._({
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  Inputfiles_max_order_by._(this._$data);

  factory Inputfiles_max_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = l$bucketId == null
          ? null
          : fromJson$EnumOrderBy((l$bucketId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] =
          l$etag == null ? null : fromJson$EnumOrderBy((l$etag as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = l$mimeType == null
          ? null
          : fromJson$EnumOrderBy((l$mimeType as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$EnumOrderBy((l$name as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : fromJson$EnumOrderBy((l$uploadedByUserId as String));
    }
    return Inputfiles_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get bucketId => (_$data['bucketId'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get etag => (_$data['etag'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get mimeType => (_$data['mimeType'] as EnumOrderBy?);
  EnumOrderBy? get name => (_$data['name'] as EnumOrderBy?);
  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  EnumOrderBy? get uploadedByUserId =>
      (_$data['uploadedByUserId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] =
          l$bucketId == null ? null : toJson$EnumOrderBy(l$bucketId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag == null ? null : toJson$EnumOrderBy(l$etag);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] =
          l$mimeType == null ? null : toJson$EnumOrderBy(l$mimeType);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$EnumOrderBy(l$name);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : toJson$EnumOrderBy(l$uploadedByUserId);
    }
    return result$data;
  }

  CopyWith$Inputfiles_max_order_by<Inputfiles_max_order_by> get copyWith =>
      CopyWith$Inputfiles_max_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Inputfiles_max_order_by<TRes> {
  factory CopyWith$Inputfiles_max_order_by(
    Inputfiles_max_order_by instance,
    TRes Function(Inputfiles_max_order_by) then,
  ) = _CopyWithImpl$Inputfiles_max_order_by;

  factory CopyWith$Inputfiles_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_max_order_by;

  TRes call({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  });
}

class _CopyWithImpl$Inputfiles_max_order_by<TRes>
    implements CopyWith$Inputfiles_max_order_by<TRes> {
  _CopyWithImpl$Inputfiles_max_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_max_order_by _instance;

  final TRes Function(Inputfiles_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(Inputfiles_max_order_by._({
        ..._instance._$data,
        if (bucketId != _undefined) 'bucketId': (bucketId as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (etag != _undefined) 'etag': (etag as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (mimeType != _undefined) 'mimeType': (mimeType as EnumOrderBy?),
        if (name != _undefined) 'name': (name as EnumOrderBy?),
        if (size != _undefined) 'size': (size as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_max_order_by<TRes>
    implements CopyWith$Inputfiles_max_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      _res;
}

class Inputfiles_min_order_by {
  factory Inputfiles_min_order_by({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      Inputfiles_min_order_by._({
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  Inputfiles_min_order_by._(this._$data);

  factory Inputfiles_min_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = l$bucketId == null
          ? null
          : fromJson$EnumOrderBy((l$bucketId as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] =
          l$etag == null ? null : fromJson$EnumOrderBy((l$etag as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = l$mimeType == null
          ? null
          : fromJson$EnumOrderBy((l$mimeType as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$EnumOrderBy((l$name as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : fromJson$EnumOrderBy((l$uploadedByUserId as String));
    }
    return Inputfiles_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get bucketId => (_$data['bucketId'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get etag => (_$data['etag'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get mimeType => (_$data['mimeType'] as EnumOrderBy?);
  EnumOrderBy? get name => (_$data['name'] as EnumOrderBy?);
  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  EnumOrderBy? get uploadedByUserId =>
      (_$data['uploadedByUserId'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] =
          l$bucketId == null ? null : toJson$EnumOrderBy(l$bucketId);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag == null ? null : toJson$EnumOrderBy(l$etag);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] =
          l$mimeType == null ? null : toJson$EnumOrderBy(l$mimeType);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name == null ? null : toJson$EnumOrderBy(l$name);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId == null
          ? null
          : toJson$EnumOrderBy(l$uploadedByUserId);
    }
    return result$data;
  }

  CopyWith$Inputfiles_min_order_by<Inputfiles_min_order_by> get copyWith =>
      CopyWith$Inputfiles_min_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Inputfiles_min_order_by<TRes> {
  factory CopyWith$Inputfiles_min_order_by(
    Inputfiles_min_order_by instance,
    TRes Function(Inputfiles_min_order_by) then,
  ) = _CopyWithImpl$Inputfiles_min_order_by;

  factory CopyWith$Inputfiles_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_min_order_by;

  TRes call({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  });
}

class _CopyWithImpl$Inputfiles_min_order_by<TRes>
    implements CopyWith$Inputfiles_min_order_by<TRes> {
  _CopyWithImpl$Inputfiles_min_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_min_order_by _instance;

  final TRes Function(Inputfiles_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(Inputfiles_min_order_by._({
        ..._instance._$data,
        if (bucketId != _undefined) 'bucketId': (bucketId as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (etag != _undefined) 'etag': (etag as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (mimeType != _undefined) 'mimeType': (mimeType as EnumOrderBy?),
        if (name != _undefined) 'name': (name as EnumOrderBy?),
        if (size != _undefined) 'size': (size as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_min_order_by<TRes>
    implements CopyWith$Inputfiles_min_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? bucketId,
    EnumOrderBy? createdAt,
    EnumOrderBy? etag,
    EnumOrderBy? id,
    EnumOrderBy? mimeType,
    EnumOrderBy? name,
    EnumOrderBy? size,
    EnumOrderBy? updatedAt,
    EnumOrderBy? uploadedByUserId,
  }) =>
      _res;
}

class Inputfiles_stddev_order_by {
  factory Inputfiles_stddev_order_by({EnumOrderBy? size}) =>
      Inputfiles_stddev_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_stddev_order_by._(this._$data);

  factory Inputfiles_stddev_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_stddev_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_stddev_order_by<Inputfiles_stddev_order_by>
      get copyWith => CopyWith$Inputfiles_stddev_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_stddev_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_stddev_order_by<TRes> {
  factory CopyWith$Inputfiles_stddev_order_by(
    Inputfiles_stddev_order_by instance,
    TRes Function(Inputfiles_stddev_order_by) then,
  ) = _CopyWithImpl$Inputfiles_stddev_order_by;

  factory CopyWith$Inputfiles_stddev_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_stddev_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_stddev_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_order_by<TRes> {
  _CopyWithImpl$Inputfiles_stddev_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_stddev_order_by _instance;

  final TRes Function(Inputfiles_stddev_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) => _then(Inputfiles_stddev_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_stddev_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_stddev_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_stddev_pop_order_by {
  factory Inputfiles_stddev_pop_order_by({EnumOrderBy? size}) =>
      Inputfiles_stddev_pop_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_stddev_pop_order_by._(this._$data);

  factory Inputfiles_stddev_pop_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_stddev_pop_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_stddev_pop_order_by<Inputfiles_stddev_pop_order_by>
      get copyWith => CopyWith$Inputfiles_stddev_pop_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_stddev_pop_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_stddev_pop_order_by<TRes> {
  factory CopyWith$Inputfiles_stddev_pop_order_by(
    Inputfiles_stddev_pop_order_by instance,
    TRes Function(Inputfiles_stddev_pop_order_by) then,
  ) = _CopyWithImpl$Inputfiles_stddev_pop_order_by;

  factory CopyWith$Inputfiles_stddev_pop_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_stddev_pop_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_stddev_pop_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_pop_order_by<TRes> {
  _CopyWithImpl$Inputfiles_stddev_pop_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_stddev_pop_order_by _instance;

  final TRes Function(Inputfiles_stddev_pop_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) =>
      _then(Inputfiles_stddev_pop_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_stddev_pop_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_pop_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_stddev_pop_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_stddev_samp_order_by {
  factory Inputfiles_stddev_samp_order_by({EnumOrderBy? size}) =>
      Inputfiles_stddev_samp_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_stddev_samp_order_by._(this._$data);

  factory Inputfiles_stddev_samp_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_stddev_samp_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_stddev_samp_order_by<Inputfiles_stddev_samp_order_by>
      get copyWith => CopyWith$Inputfiles_stddev_samp_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_stddev_samp_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_stddev_samp_order_by<TRes> {
  factory CopyWith$Inputfiles_stddev_samp_order_by(
    Inputfiles_stddev_samp_order_by instance,
    TRes Function(Inputfiles_stddev_samp_order_by) then,
  ) = _CopyWithImpl$Inputfiles_stddev_samp_order_by;

  factory CopyWith$Inputfiles_stddev_samp_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_stddev_samp_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_stddev_samp_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_samp_order_by<TRes> {
  _CopyWithImpl$Inputfiles_stddev_samp_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_stddev_samp_order_by _instance;

  final TRes Function(Inputfiles_stddev_samp_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) =>
      _then(Inputfiles_stddev_samp_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_stddev_samp_order_by<TRes>
    implements CopyWith$Inputfiles_stddev_samp_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_stddev_samp_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_streamCursorInput {
  factory Inputfiles_streamCursorInput({
    required Inputfiles_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      Inputfiles_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  Inputfiles_streamCursorInput._(this._$data);

  factory Inputfiles_streamCursorInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] = Inputfiles_streamCursorValueInput.fromJson(
        (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return Inputfiles_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Inputfiles_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as Inputfiles_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$Inputfiles_streamCursorInput<Inputfiles_streamCursorInput>
      get copyWith => CopyWith$Inputfiles_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$Inputfiles_streamCursorInput<TRes> {
  factory CopyWith$Inputfiles_streamCursorInput(
    Inputfiles_streamCursorInput instance,
    TRes Function(Inputfiles_streamCursorInput) then,
  ) = _CopyWithImpl$Inputfiles_streamCursorInput;

  factory CopyWith$Inputfiles_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_streamCursorInput;

  TRes call({
    Inputfiles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$Inputfiles_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$Inputfiles_streamCursorInput<TRes>
    implements CopyWith$Inputfiles_streamCursorInput<TRes> {
  _CopyWithImpl$Inputfiles_streamCursorInput(
    this._instance,
    this._then,
  );

  final Inputfiles_streamCursorInput _instance;

  final TRes Function(Inputfiles_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(Inputfiles_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue': (initialValue as Inputfiles_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$Inputfiles_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$Inputfiles_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$Inputfiles_streamCursorInput<TRes>
    implements CopyWith$Inputfiles_streamCursorInput<TRes> {
  _CopyWithStubImpl$Inputfiles_streamCursorInput(this._res);

  TRes _res;

  call({
    Inputfiles_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$Inputfiles_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$Inputfiles_streamCursorValueInput.stub(_res);
}

class Inputfiles_streamCursorValueInput {
  factory Inputfiles_streamCursorValueInput({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      Inputfiles_streamCursorValueInput._({
        if (bucketId != null) r'bucketId': bucketId,
        if (createdAt != null) r'createdAt': createdAt,
        if (etag != null) r'etag': etag,
        if (id != null) r'id': id,
        if (isUploaded != null) r'isUploaded': isUploaded,
        if (mimeType != null) r'mimeType': mimeType,
        if (name != null) r'name': name,
        if (size != null) r'size': size,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uploadedByUserId != null) r'uploadedByUserId': uploadedByUserId,
      });

  Inputfiles_streamCursorValueInput._(this._$data);

  factory Inputfiles_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bucketId')) {
      final l$bucketId = data['bucketId'];
      result$data['bucketId'] = (l$bucketId as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('etag')) {
      final l$etag = data['etag'];
      result$data['etag'] = (l$etag as String?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isUploaded')) {
      final l$isUploaded = data['isUploaded'];
      result$data['isUploaded'] = (l$isUploaded as bool?);
    }
    if (data.containsKey('mimeType')) {
      final l$mimeType = data['mimeType'];
      result$data['mimeType'] = (l$mimeType as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = (l$size as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = data['uploadedByUserId'];
      result$data['uploadedByUserId'] = (l$uploadedByUserId as String?);
    }
    return Inputfiles_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get bucketId => (_$data['bucketId'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get etag => (_$data['etag'] as String?);
  String? get id => (_$data['id'] as String?);
  bool? get isUploaded => (_$data['isUploaded'] as bool?);
  String? get mimeType => (_$data['mimeType'] as String?);
  String? get name => (_$data['name'] as String?);
  int? get size => (_$data['size'] as int?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  String? get uploadedByUserId => (_$data['uploadedByUserId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bucketId')) {
      final l$bucketId = bucketId;
      result$data['bucketId'] = l$bucketId;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('etag')) {
      final l$etag = etag;
      result$data['etag'] = l$etag;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isUploaded')) {
      final l$isUploaded = isUploaded;
      result$data['isUploaded'] = l$isUploaded;
    }
    if (_$data.containsKey('mimeType')) {
      final l$mimeType = mimeType;
      result$data['mimeType'] = l$mimeType;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('uploadedByUserId')) {
      final l$uploadedByUserId = uploadedByUserId;
      result$data['uploadedByUserId'] = l$uploadedByUserId;
    }
    return result$data;
  }

  CopyWith$Inputfiles_streamCursorValueInput<Inputfiles_streamCursorValueInput>
      get copyWith => CopyWith$Inputfiles_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bucketId = bucketId;
    final lOther$bucketId = other.bucketId;
    if (_$data.containsKey('bucketId') !=
        other._$data.containsKey('bucketId')) {
      return false;
    }
    if (l$bucketId != lOther$bucketId) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$etag = etag;
    final lOther$etag = other.etag;
    if (_$data.containsKey('etag') != other._$data.containsKey('etag')) {
      return false;
    }
    if (l$etag != lOther$etag) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isUploaded = isUploaded;
    final lOther$isUploaded = other.isUploaded;
    if (_$data.containsKey('isUploaded') !=
        other._$data.containsKey('isUploaded')) {
      return false;
    }
    if (l$isUploaded != lOther$isUploaded) {
      return false;
    }
    final l$mimeType = mimeType;
    final lOther$mimeType = other.mimeType;
    if (_$data.containsKey('mimeType') !=
        other._$data.containsKey('mimeType')) {
      return false;
    }
    if (l$mimeType != lOther$mimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uploadedByUserId = uploadedByUserId;
    final lOther$uploadedByUserId = other.uploadedByUserId;
    if (_$data.containsKey('uploadedByUserId') !=
        other._$data.containsKey('uploadedByUserId')) {
      return false;
    }
    if (l$uploadedByUserId != lOther$uploadedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bucketId = bucketId;
    final l$createdAt = createdAt;
    final l$etag = etag;
    final l$id = id;
    final l$isUploaded = isUploaded;
    final l$mimeType = mimeType;
    final l$name = name;
    final l$size = size;
    final l$updatedAt = updatedAt;
    final l$uploadedByUserId = uploadedByUserId;
    return Object.hashAll([
      _$data.containsKey('bucketId') ? l$bucketId : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('etag') ? l$etag : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isUploaded') ? l$isUploaded : const {},
      _$data.containsKey('mimeType') ? l$mimeType : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uploadedByUserId') ? l$uploadedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Inputfiles_streamCursorValueInput<TRes> {
  factory CopyWith$Inputfiles_streamCursorValueInput(
    Inputfiles_streamCursorValueInput instance,
    TRes Function(Inputfiles_streamCursorValueInput) then,
  ) = _CopyWithImpl$Inputfiles_streamCursorValueInput;

  factory CopyWith$Inputfiles_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_streamCursorValueInput;

  TRes call({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  });
}

class _CopyWithImpl$Inputfiles_streamCursorValueInput<TRes>
    implements CopyWith$Inputfiles_streamCursorValueInput<TRes> {
  _CopyWithImpl$Inputfiles_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final Inputfiles_streamCursorValueInput _instance;

  final TRes Function(Inputfiles_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? bucketId = _undefined,
    Object? createdAt = _undefined,
    Object? etag = _undefined,
    Object? id = _undefined,
    Object? isUploaded = _undefined,
    Object? mimeType = _undefined,
    Object? name = _undefined,
    Object? size = _undefined,
    Object? updatedAt = _undefined,
    Object? uploadedByUserId = _undefined,
  }) =>
      _then(Inputfiles_streamCursorValueInput._({
        ..._instance._$data,
        if (bucketId != _undefined) 'bucketId': (bucketId as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (etag != _undefined) 'etag': (etag as String?),
        if (id != _undefined) 'id': (id as String?),
        if (isUploaded != _undefined) 'isUploaded': (isUploaded as bool?),
        if (mimeType != _undefined) 'mimeType': (mimeType as String?),
        if (name != _undefined) 'name': (name as String?),
        if (size != _undefined) 'size': (size as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (uploadedByUserId != _undefined)
          'uploadedByUserId': (uploadedByUserId as String?),
      }));
}

class _CopyWithStubImpl$Inputfiles_streamCursorValueInput<TRes>
    implements CopyWith$Inputfiles_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$Inputfiles_streamCursorValueInput(this._res);

  TRes _res;

  call({
    String? bucketId,
    DateTime? createdAt,
    String? etag,
    String? id,
    bool? isUploaded,
    String? mimeType,
    String? name,
    int? size,
    DateTime? updatedAt,
    String? uploadedByUserId,
  }) =>
      _res;
}

class Inputfiles_sum_order_by {
  factory Inputfiles_sum_order_by({EnumOrderBy? size}) =>
      Inputfiles_sum_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_sum_order_by._(this._$data);

  factory Inputfiles_sum_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_sum_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_sum_order_by<Inputfiles_sum_order_by> get copyWith =>
      CopyWith$Inputfiles_sum_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_sum_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_sum_order_by<TRes> {
  factory CopyWith$Inputfiles_sum_order_by(
    Inputfiles_sum_order_by instance,
    TRes Function(Inputfiles_sum_order_by) then,
  ) = _CopyWithImpl$Inputfiles_sum_order_by;

  factory CopyWith$Inputfiles_sum_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_sum_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_sum_order_by<TRes>
    implements CopyWith$Inputfiles_sum_order_by<TRes> {
  _CopyWithImpl$Inputfiles_sum_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_sum_order_by _instance;

  final TRes Function(Inputfiles_sum_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) => _then(Inputfiles_sum_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_sum_order_by<TRes>
    implements CopyWith$Inputfiles_sum_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_sum_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_var_pop_order_by {
  factory Inputfiles_var_pop_order_by({EnumOrderBy? size}) =>
      Inputfiles_var_pop_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_var_pop_order_by._(this._$data);

  factory Inputfiles_var_pop_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_var_pop_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_var_pop_order_by<Inputfiles_var_pop_order_by>
      get copyWith => CopyWith$Inputfiles_var_pop_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_var_pop_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_var_pop_order_by<TRes> {
  factory CopyWith$Inputfiles_var_pop_order_by(
    Inputfiles_var_pop_order_by instance,
    TRes Function(Inputfiles_var_pop_order_by) then,
  ) = _CopyWithImpl$Inputfiles_var_pop_order_by;

  factory CopyWith$Inputfiles_var_pop_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_var_pop_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_var_pop_order_by<TRes>
    implements CopyWith$Inputfiles_var_pop_order_by<TRes> {
  _CopyWithImpl$Inputfiles_var_pop_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_var_pop_order_by _instance;

  final TRes Function(Inputfiles_var_pop_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) =>
      _then(Inputfiles_var_pop_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_var_pop_order_by<TRes>
    implements CopyWith$Inputfiles_var_pop_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_var_pop_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_var_samp_order_by {
  factory Inputfiles_var_samp_order_by({EnumOrderBy? size}) =>
      Inputfiles_var_samp_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_var_samp_order_by._(this._$data);

  factory Inputfiles_var_samp_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_var_samp_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_var_samp_order_by<Inputfiles_var_samp_order_by>
      get copyWith => CopyWith$Inputfiles_var_samp_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_var_samp_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_var_samp_order_by<TRes> {
  factory CopyWith$Inputfiles_var_samp_order_by(
    Inputfiles_var_samp_order_by instance,
    TRes Function(Inputfiles_var_samp_order_by) then,
  ) = _CopyWithImpl$Inputfiles_var_samp_order_by;

  factory CopyWith$Inputfiles_var_samp_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_var_samp_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_var_samp_order_by<TRes>
    implements CopyWith$Inputfiles_var_samp_order_by<TRes> {
  _CopyWithImpl$Inputfiles_var_samp_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_var_samp_order_by _instance;

  final TRes Function(Inputfiles_var_samp_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) =>
      _then(Inputfiles_var_samp_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_var_samp_order_by<TRes>
    implements CopyWith$Inputfiles_var_samp_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_var_samp_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class Inputfiles_variance_order_by {
  factory Inputfiles_variance_order_by({EnumOrderBy? size}) =>
      Inputfiles_variance_order_by._({
        if (size != null) r'size': size,
      });

  Inputfiles_variance_order_by._(this._$data);

  factory Inputfiles_variance_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$EnumOrderBy((l$size as String));
    }
    return Inputfiles_variance_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get size => (_$data['size'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size == null ? null : toJson$EnumOrderBy(l$size);
    }
    return result$data;
  }

  CopyWith$Inputfiles_variance_order_by<Inputfiles_variance_order_by>
      get copyWith => CopyWith$Inputfiles_variance_order_by(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputfiles_variance_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$size = size;
    return Object.hashAll([_$data.containsKey('size') ? l$size : const {}]);
  }
}

abstract class CopyWith$Inputfiles_variance_order_by<TRes> {
  factory CopyWith$Inputfiles_variance_order_by(
    Inputfiles_variance_order_by instance,
    TRes Function(Inputfiles_variance_order_by) then,
  ) = _CopyWithImpl$Inputfiles_variance_order_by;

  factory CopyWith$Inputfiles_variance_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputfiles_variance_order_by;

  TRes call({EnumOrderBy? size});
}

class _CopyWithImpl$Inputfiles_variance_order_by<TRes>
    implements CopyWith$Inputfiles_variance_order_by<TRes> {
  _CopyWithImpl$Inputfiles_variance_order_by(
    this._instance,
    this._then,
  );

  final Inputfiles_variance_order_by _instance;

  final TRes Function(Inputfiles_variance_order_by) _then;

  static const _undefined = {};

  TRes call({Object? size = _undefined}) =>
      _then(Inputfiles_variance_order_by._({
        ..._instance._$data,
        if (size != _undefined) 'size': (size as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputfiles_variance_order_by<TRes>
    implements CopyWith$Inputfiles_variance_order_by<TRes> {
  _CopyWithStubImpl$Inputfiles_variance_order_by(this._res);

  TRes _res;

  call({EnumOrderBy? size}) => _res;
}

class InputusersAggregateOrderBy {
  factory InputusersAggregateOrderBy({
    EnumOrderBy? count,
    Inputusers_max_order_by? max,
    Inputusers_min_order_by? min,
  }) =>
      InputusersAggregateOrderBy._({
        if (count != null) r'count': count,
        if (max != null) r'max': max,
        if (min != null) r'min': min,
      });

  InputusersAggregateOrderBy._(this._$data);

  factory InputusersAggregateOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('count')) {
      final l$count = data['count'];
      result$data['count'] =
          l$count == null ? null : fromJson$EnumOrderBy((l$count as String));
    }
    if (data.containsKey('max')) {
      final l$max = data['max'];
      result$data['max'] = l$max == null
          ? null
          : Inputusers_max_order_by.fromJson((l$max as Map<String, dynamic>));
    }
    if (data.containsKey('min')) {
      final l$min = data['min'];
      result$data['min'] = l$min == null
          ? null
          : Inputusers_min_order_by.fromJson((l$min as Map<String, dynamic>));
    }
    return InputusersAggregateOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get count => (_$data['count'] as EnumOrderBy?);
  Inputusers_max_order_by? get max =>
      (_$data['max'] as Inputusers_max_order_by?);
  Inputusers_min_order_by? get min =>
      (_$data['min'] as Inputusers_min_order_by?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('count')) {
      final l$count = count;
      result$data['count'] =
          l$count == null ? null : toJson$EnumOrderBy(l$count);
    }
    if (_$data.containsKey('max')) {
      final l$max = max;
      result$data['max'] = l$max?.toJson();
    }
    if (_$data.containsKey('min')) {
      final l$min = min;
      result$data['min'] = l$min?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersAggregateOrderBy<InputusersAggregateOrderBy>
      get copyWith => CopyWith$InputusersAggregateOrderBy(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersAggregateOrderBy) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$count = count;
    final lOther$count = other.count;
    if (_$data.containsKey('count') != other._$data.containsKey('count')) {
      return false;
    }
    if (l$count != lOther$count) {
      return false;
    }
    final l$max = max;
    final lOther$max = other.max;
    if (_$data.containsKey('max') != other._$data.containsKey('max')) {
      return false;
    }
    if (l$max != lOther$max) {
      return false;
    }
    final l$min = min;
    final lOther$min = other.min;
    if (_$data.containsKey('min') != other._$data.containsKey('min')) {
      return false;
    }
    if (l$min != lOther$min) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$count = count;
    final l$max = max;
    final l$min = min;
    return Object.hashAll([
      _$data.containsKey('count') ? l$count : const {},
      _$data.containsKey('max') ? l$max : const {},
      _$data.containsKey('min') ? l$min : const {},
    ]);
  }
}

abstract class CopyWith$InputusersAggregateOrderBy<TRes> {
  factory CopyWith$InputusersAggregateOrderBy(
    InputusersAggregateOrderBy instance,
    TRes Function(InputusersAggregateOrderBy) then,
  ) = _CopyWithImpl$InputusersAggregateOrderBy;

  factory CopyWith$InputusersAggregateOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputusersAggregateOrderBy;

  TRes call({
    EnumOrderBy? count,
    Inputusers_max_order_by? max,
    Inputusers_min_order_by? min,
  });
  CopyWith$Inputusers_max_order_by<TRes> get max;
  CopyWith$Inputusers_min_order_by<TRes> get min;
}

class _CopyWithImpl$InputusersAggregateOrderBy<TRes>
    implements CopyWith$InputusersAggregateOrderBy<TRes> {
  _CopyWithImpl$InputusersAggregateOrderBy(
    this._instance,
    this._then,
  );

  final InputusersAggregateOrderBy _instance;

  final TRes Function(InputusersAggregateOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? count = _undefined,
    Object? max = _undefined,
    Object? min = _undefined,
  }) =>
      _then(InputusersAggregateOrderBy._({
        ..._instance._$data,
        if (count != _undefined) 'count': (count as EnumOrderBy?),
        if (max != _undefined) 'max': (max as Inputusers_max_order_by?),
        if (min != _undefined) 'min': (min as Inputusers_min_order_by?),
      }));
  CopyWith$Inputusers_max_order_by<TRes> get max {
    final local$max = _instance.max;
    return local$max == null
        ? CopyWith$Inputusers_max_order_by.stub(_then(_instance))
        : CopyWith$Inputusers_max_order_by(local$max, (e) => call(max: e));
  }

  CopyWith$Inputusers_min_order_by<TRes> get min {
    final local$min = _instance.min;
    return local$min == null
        ? CopyWith$Inputusers_min_order_by.stub(_then(_instance))
        : CopyWith$Inputusers_min_order_by(local$min, (e) => call(min: e));
  }
}

class _CopyWithStubImpl$InputusersAggregateOrderBy<TRes>
    implements CopyWith$InputusersAggregateOrderBy<TRes> {
  _CopyWithStubImpl$InputusersAggregateOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? count,
    Inputusers_max_order_by? max,
    Inputusers_min_order_by? min,
  }) =>
      _res;
  CopyWith$Inputusers_max_order_by<TRes> get max =>
      CopyWith$Inputusers_max_order_by.stub(_res);
  CopyWith$Inputusers_min_order_by<TRes> get min =>
      CopyWith$Inputusers_min_order_by.stub(_res);
}

class InputusersAppendInput {
  factory InputusersAppendInput({Map<String, dynamic>? metadata}) =>
      InputusersAppendInput._({
        if (metadata != null) r'metadata': metadata,
      });

  InputusersAppendInput._(this._$data);

  factory InputusersAppendInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as Map<String, dynamic>?);
    }
    return InputusersAppendInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    return result$data;
  }

  CopyWith$InputusersAppendInput<InputusersAppendInput> get copyWith =>
      CopyWith$InputusersAppendInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersAppendInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll(
        [_$data.containsKey('metadata') ? l$metadata : const {}]);
  }
}

abstract class CopyWith$InputusersAppendInput<TRes> {
  factory CopyWith$InputusersAppendInput(
    InputusersAppendInput instance,
    TRes Function(InputusersAppendInput) then,
  ) = _CopyWithImpl$InputusersAppendInput;

  factory CopyWith$InputusersAppendInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersAppendInput;

  TRes call({Map<String, dynamic>? metadata});
}

class _CopyWithImpl$InputusersAppendInput<TRes>
    implements CopyWith$InputusersAppendInput<TRes> {
  _CopyWithImpl$InputusersAppendInput(
    this._instance,
    this._then,
  );

  final InputusersAppendInput _instance;

  final TRes Function(InputusersAppendInput) _then;

  static const _undefined = {};

  TRes call({Object? metadata = _undefined}) => _then(InputusersAppendInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputusersAppendInput<TRes>
    implements CopyWith$InputusersAppendInput<TRes> {
  _CopyWithStubImpl$InputusersAppendInput(this._res);

  TRes _res;

  call({Map<String, dynamic>? metadata}) => _res;
}

class InputusersArrRelInsertInput {
  factory InputusersArrRelInsertInput({
    required List<InputusersInsertInput> data,
    InputusersOnConflict? onConflict,
  }) =>
      InputusersArrRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputusersArrRelInsertInput._(this._$data);

  factory InputusersArrRelInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => InputusersInsertInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputusersOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputusersArrRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputusersInsertInput> get data =>
      (_$data['data'] as List<InputusersInsertInput>);
  InputusersOnConflict? get onConflict =>
      (_$data['onConflict'] as InputusersOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersArrRelInsertInput<InputusersArrRelInsertInput>
      get copyWith => CopyWith$InputusersArrRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersArrRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputusersArrRelInsertInput<TRes> {
  factory CopyWith$InputusersArrRelInsertInput(
    InputusersArrRelInsertInput instance,
    TRes Function(InputusersArrRelInsertInput) then,
  ) = _CopyWithImpl$InputusersArrRelInsertInput;

  factory CopyWith$InputusersArrRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersArrRelInsertInput;

  TRes call({
    List<InputusersInsertInput>? data,
    InputusersOnConflict? onConflict,
  });
  TRes data(
      Iterable<InputusersInsertInput> Function(
              Iterable<CopyWith$InputusersInsertInput<InputusersInsertInput>>)
          _fn);
  CopyWith$InputusersOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputusersArrRelInsertInput<TRes>
    implements CopyWith$InputusersArrRelInsertInput<TRes> {
  _CopyWithImpl$InputusersArrRelInsertInput(
    this._instance,
    this._then,
  );

  final InputusersArrRelInsertInput _instance;

  final TRes Function(InputusersArrRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputusersArrRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<InputusersInsertInput>),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputusersOnConflict?),
      }));
  TRes data(
          Iterable<InputusersInsertInput> Function(
                  Iterable<
                      CopyWith$InputusersInsertInput<InputusersInsertInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data.map((e) => CopyWith$InputusersInsertInput(
                e,
                (i) => i,
              ))).toList());
  CopyWith$InputusersOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputusersOnConflict.stub(_then(_instance))
        : CopyWith$InputusersOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputusersArrRelInsertInput<TRes>
    implements CopyWith$InputusersArrRelInsertInput<TRes> {
  _CopyWithStubImpl$InputusersArrRelInsertInput(this._res);

  TRes _res;

  call({
    List<InputusersInsertInput>? data,
    InputusersOnConflict? onConflict,
  }) =>
      _res;
  data(_fn) => _res;
  CopyWith$InputusersOnConflict<TRes> get onConflict =>
      CopyWith$InputusersOnConflict.stub(_res);
}

class InputusersBoolExp {
  factory InputusersBoolExp({
    List<InputusersBoolExp>? $_and,
    InputusersBoolExp? $_not,
    List<InputusersBoolExp>? $_or,
    InputStringComparisonExp? activeMfaType,
    InputauthUserAuthenticatorsBoolExp? authenticators,
    InputStringComparisonExp? avatarUrl,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? currentChallenge,
    InputStringComparisonExp? defaultRole,
    InputauthRolesBoolExp? defaultRoleByRole,
    InputBooleanComparisonExp? disabled,
    InputStringComparisonExp? displayName,
    InputCitextComparisonExp? email,
    InputBooleanComparisonExp? emailVerified,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isAnonymous,
    InputTimestamptzComparisonExp? lastSeen,
    InputStringComparisonExp? locale,
    InputJsonbComparisonExp? metadata,
    InputCitextComparisonExp? newEmail,
    InputStringComparisonExp? otpHash,
    InputTimestamptzComparisonExp? otpHashExpiresAt,
    InputStringComparisonExp? otpMethodLastUsed,
    InputStringComparisonExp? passwordHash,
    InputStringComparisonExp? phoneNumber,
    InputBooleanComparisonExp? phoneNumberVerified,
    InputauthRefreshTokensBoolExp? refreshTokens,
    InputauthUserRolesBoolExp? roles,
    InputStringComparisonExp? ticket,
    InputTimestamptzComparisonExp? ticketExpiresAt,
    InputStringComparisonExp? totpSecret,
    InputTimestamptzComparisonExp? updatedAt,
    InputauthUserProvidersBoolExp? userProviders,
  }) =>
      InputusersBoolExp._({
        if ($_and != null) r'_and': $_and,
        if ($_not != null) r'_not': $_not,
        if ($_or != null) r'_or': $_or,
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (authenticators != null) r'authenticators': authenticators,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (defaultRoleByRole != null) r'defaultRoleByRole': defaultRoleByRole,
        if (disabled != null) r'disabled': disabled,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (emailVerified != null) r'emailVerified': emailVerified,
        if (id != null) r'id': id,
        if (isAnonymous != null) r'isAnonymous': isAnonymous,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (metadata != null) r'metadata': metadata,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberVerified != null)
          r'phoneNumberVerified': phoneNumberVerified,
        if (refreshTokens != null) r'refreshTokens': refreshTokens,
        if (roles != null) r'roles': roles,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userProviders != null) r'userProviders': userProviders,
      });

  InputusersBoolExp._(this._$data);

  factory InputusersBoolExp.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_and')) {
      final l$$_and = data['_and'];
      result$data['_and'] = (l$$_and as List<dynamic>?)
          ?.map((e) => InputusersBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('_not')) {
      final l$$_not = data['_not'];
      result$data['_not'] = l$$_not == null
          ? null
          : InputusersBoolExp.fromJson((l$$_not as Map<String, dynamic>));
    }
    if (data.containsKey('_or')) {
      final l$$_or = data['_or'];
      result$data['_or'] = (l$$_or as List<dynamic>?)
          ?.map((e) => InputusersBoolExp.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = l$activeMfaType == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$activeMfaType as Map<String, dynamic>));
    }
    if (data.containsKey('authenticators')) {
      final l$authenticators = data['authenticators'];
      result$data['authenticators'] = l$authenticators == null
          ? null
          : InputauthUserAuthenticatorsBoolExp.fromJson(
              (l$authenticators as Map<String, dynamic>));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$avatarUrl as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$currentChallenge as Map<String, dynamic>));
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = l$defaultRole == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$defaultRole as Map<String, dynamic>));
    }
    if (data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = data['defaultRoleByRole'];
      result$data['defaultRoleByRole'] = l$defaultRoleByRole == null
          ? null
          : InputauthRolesBoolExp.fromJson(
              (l$defaultRoleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('disabled')) {
      final l$disabled = data['disabled'];
      result$data['disabled'] = l$disabled == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$disabled as Map<String, dynamic>));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$displayName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : InputCitextComparisonExp.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('emailVerified')) {
      final l$emailVerified = data['emailVerified'];
      result$data['emailVerified'] = l$emailVerified == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$emailVerified as Map<String, dynamic>));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : InputUuidComparisonExp.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('isAnonymous')) {
      final l$isAnonymous = data['isAnonymous'];
      result$data['isAnonymous'] = l$isAnonymous == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$isAnonymous as Map<String, dynamic>));
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$lastSeen as Map<String, dynamic>));
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] = l$locale == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$locale as Map<String, dynamic>));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = l$metadata == null
          ? null
          : InputJsonbComparisonExp.fromJson(
              (l$metadata as Map<String, dynamic>));
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = l$newEmail == null
          ? null
          : InputCitextComparisonExp.fromJson(
              (l$newEmail as Map<String, dynamic>));
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = l$otpHash == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$otpHash as Map<String, dynamic>));
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$otpHashExpiresAt as Map<String, dynamic>));
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$otpMethodLastUsed as Map<String, dynamic>));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$passwordHash as Map<String, dynamic>));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$phoneNumber as Map<String, dynamic>));
    }
    if (data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = data['phoneNumberVerified'];
      result$data['phoneNumberVerified'] = l$phoneNumberVerified == null
          ? null
          : InputBooleanComparisonExp.fromJson(
              (l$phoneNumberVerified as Map<String, dynamic>));
    }
    if (data.containsKey('refreshTokens')) {
      final l$refreshTokens = data['refreshTokens'];
      result$data['refreshTokens'] = l$refreshTokens == null
          ? null
          : InputauthRefreshTokensBoolExp.fromJson(
              (l$refreshTokens as Map<String, dynamic>));
    }
    if (data.containsKey('roles')) {
      final l$roles = data['roles'];
      result$data['roles'] = l$roles == null
          ? null
          : InputauthUserRolesBoolExp.fromJson(
              (l$roles as Map<String, dynamic>));
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] = l$ticket == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$ticket as Map<String, dynamic>));
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$ticketExpiresAt as Map<String, dynamic>));
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = l$totpSecret == null
          ? null
          : InputStringComparisonExp.fromJson(
              (l$totpSecret as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : InputTimestamptzComparisonExp.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userProviders')) {
      final l$userProviders = data['userProviders'];
      result$data['userProviders'] = l$userProviders == null
          ? null
          : InputauthUserProvidersBoolExp.fromJson(
              (l$userProviders as Map<String, dynamic>));
    }
    return InputusersBoolExp._(result$data);
  }

  Map<String, dynamic> _$data;

  List<InputusersBoolExp>? get $_and =>
      (_$data['_and'] as List<InputusersBoolExp>?);
  InputusersBoolExp? get $_not => (_$data['_not'] as InputusersBoolExp?);
  List<InputusersBoolExp>? get $_or =>
      (_$data['_or'] as List<InputusersBoolExp>?);
  InputStringComparisonExp? get activeMfaType =>
      (_$data['activeMfaType'] as InputStringComparisonExp?);
  InputauthUserAuthenticatorsBoolExp? get authenticators =>
      (_$data['authenticators'] as InputauthUserAuthenticatorsBoolExp?);
  InputStringComparisonExp? get avatarUrl =>
      (_$data['avatarUrl'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get createdAt =>
      (_$data['createdAt'] as InputTimestamptzComparisonExp?);
  InputStringComparisonExp? get currentChallenge =>
      (_$data['currentChallenge'] as InputStringComparisonExp?);
  InputStringComparisonExp? get defaultRole =>
      (_$data['defaultRole'] as InputStringComparisonExp?);
  InputauthRolesBoolExp? get defaultRoleByRole =>
      (_$data['defaultRoleByRole'] as InputauthRolesBoolExp?);
  InputBooleanComparisonExp? get disabled =>
      (_$data['disabled'] as InputBooleanComparisonExp?);
  InputStringComparisonExp? get displayName =>
      (_$data['displayName'] as InputStringComparisonExp?);
  InputCitextComparisonExp? get email =>
      (_$data['email'] as InputCitextComparisonExp?);
  InputBooleanComparisonExp? get emailVerified =>
      (_$data['emailVerified'] as InputBooleanComparisonExp?);
  InputUuidComparisonExp? get id => (_$data['id'] as InputUuidComparisonExp?);
  InputBooleanComparisonExp? get isAnonymous =>
      (_$data['isAnonymous'] as InputBooleanComparisonExp?);
  InputTimestamptzComparisonExp? get lastSeen =>
      (_$data['lastSeen'] as InputTimestamptzComparisonExp?);
  InputStringComparisonExp? get locale =>
      (_$data['locale'] as InputStringComparisonExp?);
  InputJsonbComparisonExp? get metadata =>
      (_$data['metadata'] as InputJsonbComparisonExp?);
  InputCitextComparisonExp? get newEmail =>
      (_$data['newEmail'] as InputCitextComparisonExp?);
  InputStringComparisonExp? get otpHash =>
      (_$data['otpHash'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get otpHashExpiresAt =>
      (_$data['otpHashExpiresAt'] as InputTimestamptzComparisonExp?);
  InputStringComparisonExp? get otpMethodLastUsed =>
      (_$data['otpMethodLastUsed'] as InputStringComparisonExp?);
  InputStringComparisonExp? get passwordHash =>
      (_$data['passwordHash'] as InputStringComparisonExp?);
  InputStringComparisonExp? get phoneNumber =>
      (_$data['phoneNumber'] as InputStringComparisonExp?);
  InputBooleanComparisonExp? get phoneNumberVerified =>
      (_$data['phoneNumberVerified'] as InputBooleanComparisonExp?);
  InputauthRefreshTokensBoolExp? get refreshTokens =>
      (_$data['refreshTokens'] as InputauthRefreshTokensBoolExp?);
  InputauthUserRolesBoolExp? get roles =>
      (_$data['roles'] as InputauthUserRolesBoolExp?);
  InputStringComparisonExp? get ticket =>
      (_$data['ticket'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get ticketExpiresAt =>
      (_$data['ticketExpiresAt'] as InputTimestamptzComparisonExp?);
  InputStringComparisonExp? get totpSecret =>
      (_$data['totpSecret'] as InputStringComparisonExp?);
  InputTimestamptzComparisonExp? get updatedAt =>
      (_$data['updatedAt'] as InputTimestamptzComparisonExp?);
  InputauthUserProvidersBoolExp? get userProviders =>
      (_$data['userProviders'] as InputauthUserProvidersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_and')) {
      final l$$_and = $_and;
      result$data['_and'] = l$$_and?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('_not')) {
      final l$$_not = $_not;
      result$data['_not'] = l$$_not?.toJson();
    }
    if (_$data.containsKey('_or')) {
      final l$$_or = $_or;
      result$data['_or'] = l$$_or?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] = l$activeMfaType?.toJson();
    }
    if (_$data.containsKey('authenticators')) {
      final l$authenticators = authenticators;
      result$data['authenticators'] = l$authenticators?.toJson();
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge?.toJson();
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] = l$defaultRole?.toJson();
    }
    if (_$data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = defaultRoleByRole;
      result$data['defaultRoleByRole'] = l$defaultRoleByRole?.toJson();
    }
    if (_$data.containsKey('disabled')) {
      final l$disabled = disabled;
      result$data['disabled'] = l$disabled?.toJson();
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('emailVerified')) {
      final l$emailVerified = emailVerified;
      result$data['emailVerified'] = l$emailVerified?.toJson();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('isAnonymous')) {
      final l$isAnonymous = isAnonymous;
      result$data['isAnonymous'] = l$isAnonymous?.toJson();
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] = l$lastSeen?.toJson();
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] = l$locale?.toJson();
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.toJson();
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] = l$newEmail?.toJson();
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] = l$otpHash?.toJson();
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt?.toJson();
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed?.toJson();
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash?.toJson();
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber?.toJson();
    }
    if (_$data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = phoneNumberVerified;
      result$data['phoneNumberVerified'] = l$phoneNumberVerified?.toJson();
    }
    if (_$data.containsKey('refreshTokens')) {
      final l$refreshTokens = refreshTokens;
      result$data['refreshTokens'] = l$refreshTokens?.toJson();
    }
    if (_$data.containsKey('roles')) {
      final l$roles = roles;
      result$data['roles'] = l$roles?.toJson();
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] = l$ticket?.toJson();
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt?.toJson();
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] = l$totpSecret?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userProviders')) {
      final l$userProviders = userProviders;
      result$data['userProviders'] = l$userProviders?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersBoolExp<InputusersBoolExp> get copyWith =>
      CopyWith$InputusersBoolExp(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersBoolExp) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_and = $_and;
    final lOther$$_and = other.$_and;
    if (_$data.containsKey('_and') != other._$data.containsKey('_and')) {
      return false;
    }
    if (l$$_and != null && lOther$$_and != null) {
      if (l$$_and.length != lOther$$_and.length) {
        return false;
      }
      for (int i = 0; i < l$$_and.length; i++) {
        final l$$_and$entry = l$$_and[i];
        final lOther$$_and$entry = lOther$$_and[i];
        if (l$$_and$entry != lOther$$_and$entry) {
          return false;
        }
      }
    } else if (l$$_and != lOther$$_and) {
      return false;
    }
    final l$$_not = $_not;
    final lOther$$_not = other.$_not;
    if (_$data.containsKey('_not') != other._$data.containsKey('_not')) {
      return false;
    }
    if (l$$_not != lOther$$_not) {
      return false;
    }
    final l$$_or = $_or;
    final lOther$$_or = other.$_or;
    if (_$data.containsKey('_or') != other._$data.containsKey('_or')) {
      return false;
    }
    if (l$$_or != null && lOther$$_or != null) {
      if (l$$_or.length != lOther$$_or.length) {
        return false;
      }
      for (int i = 0; i < l$$_or.length; i++) {
        final l$$_or$entry = l$$_or[i];
        final lOther$$_or$entry = lOther$$_or[i];
        if (l$$_or$entry != lOther$$_or$entry) {
          return false;
        }
      }
    } else if (l$$_or != lOther$$_or) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$authenticators = authenticators;
    final lOther$authenticators = other.authenticators;
    if (_$data.containsKey('authenticators') !=
        other._$data.containsKey('authenticators')) {
      return false;
    }
    if (l$authenticators != lOther$authenticators) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$defaultRoleByRole = defaultRoleByRole;
    final lOther$defaultRoleByRole = other.defaultRoleByRole;
    if (_$data.containsKey('defaultRoleByRole') !=
        other._$data.containsKey('defaultRoleByRole')) {
      return false;
    }
    if (l$defaultRoleByRole != lOther$defaultRoleByRole) {
      return false;
    }
    final l$disabled = disabled;
    final lOther$disabled = other.disabled;
    if (_$data.containsKey('disabled') !=
        other._$data.containsKey('disabled')) {
      return false;
    }
    if (l$disabled != lOther$disabled) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailVerified = emailVerified;
    final lOther$emailVerified = other.emailVerified;
    if (_$data.containsKey('emailVerified') !=
        other._$data.containsKey('emailVerified')) {
      return false;
    }
    if (l$emailVerified != lOther$emailVerified) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isAnonymous = isAnonymous;
    final lOther$isAnonymous = other.isAnonymous;
    if (_$data.containsKey('isAnonymous') !=
        other._$data.containsKey('isAnonymous')) {
      return false;
    }
    if (l$isAnonymous != lOther$isAnonymous) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberVerified = phoneNumberVerified;
    final lOther$phoneNumberVerified = other.phoneNumberVerified;
    if (_$data.containsKey('phoneNumberVerified') !=
        other._$data.containsKey('phoneNumberVerified')) {
      return false;
    }
    if (l$phoneNumberVerified != lOther$phoneNumberVerified) {
      return false;
    }
    final l$refreshTokens = refreshTokens;
    final lOther$refreshTokens = other.refreshTokens;
    if (_$data.containsKey('refreshTokens') !=
        other._$data.containsKey('refreshTokens')) {
      return false;
    }
    if (l$refreshTokens != lOther$refreshTokens) {
      return false;
    }
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (_$data.containsKey('roles') != other._$data.containsKey('roles')) {
      return false;
    }
    if (l$roles != lOther$roles) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userProviders = userProviders;
    final lOther$userProviders = other.userProviders;
    if (_$data.containsKey('userProviders') !=
        other._$data.containsKey('userProviders')) {
      return false;
    }
    if (l$userProviders != lOther$userProviders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_and = $_and;
    final l$$_not = $_not;
    final l$$_or = $_or;
    final l$activeMfaType = activeMfaType;
    final l$authenticators = authenticators;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$defaultRoleByRole = defaultRoleByRole;
    final l$disabled = disabled;
    final l$displayName = displayName;
    final l$email = email;
    final l$emailVerified = emailVerified;
    final l$id = id;
    final l$isAnonymous = isAnonymous;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$metadata = metadata;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberVerified = phoneNumberVerified;
    final l$refreshTokens = refreshTokens;
    final l$roles = roles;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    final l$userProviders = userProviders;
    return Object.hashAll([
      _$data.containsKey('_and')
          ? l$$_and == null
              ? null
              : Object.hashAll(l$$_and.map((v) => v))
          : const {},
      _$data.containsKey('_not') ? l$$_not : const {},
      _$data.containsKey('_or')
          ? l$$_or == null
              ? null
              : Object.hashAll(l$$_or.map((v) => v))
          : const {},
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('authenticators') ? l$authenticators : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('defaultRoleByRole') ? l$defaultRoleByRole : const {},
      _$data.containsKey('disabled') ? l$disabled : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailVerified') ? l$emailVerified : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isAnonymous') ? l$isAnonymous : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberVerified')
          ? l$phoneNumberVerified
          : const {},
      _$data.containsKey('refreshTokens') ? l$refreshTokens : const {},
      _$data.containsKey('roles') ? l$roles : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userProviders') ? l$userProviders : const {},
    ]);
  }
}

abstract class CopyWith$InputusersBoolExp<TRes> {
  factory CopyWith$InputusersBoolExp(
    InputusersBoolExp instance,
    TRes Function(InputusersBoolExp) then,
  ) = _CopyWithImpl$InputusersBoolExp;

  factory CopyWith$InputusersBoolExp.stub(TRes res) =
      _CopyWithStubImpl$InputusersBoolExp;

  TRes call({
    List<InputusersBoolExp>? $_and,
    InputusersBoolExp? $_not,
    List<InputusersBoolExp>? $_or,
    InputStringComparisonExp? activeMfaType,
    InputauthUserAuthenticatorsBoolExp? authenticators,
    InputStringComparisonExp? avatarUrl,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? currentChallenge,
    InputStringComparisonExp? defaultRole,
    InputauthRolesBoolExp? defaultRoleByRole,
    InputBooleanComparisonExp? disabled,
    InputStringComparisonExp? displayName,
    InputCitextComparisonExp? email,
    InputBooleanComparisonExp? emailVerified,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isAnonymous,
    InputTimestamptzComparisonExp? lastSeen,
    InputStringComparisonExp? locale,
    InputJsonbComparisonExp? metadata,
    InputCitextComparisonExp? newEmail,
    InputStringComparisonExp? otpHash,
    InputTimestamptzComparisonExp? otpHashExpiresAt,
    InputStringComparisonExp? otpMethodLastUsed,
    InputStringComparisonExp? passwordHash,
    InputStringComparisonExp? phoneNumber,
    InputBooleanComparisonExp? phoneNumberVerified,
    InputauthRefreshTokensBoolExp? refreshTokens,
    InputauthUserRolesBoolExp? roles,
    InputStringComparisonExp? ticket,
    InputTimestamptzComparisonExp? ticketExpiresAt,
    InputStringComparisonExp? totpSecret,
    InputTimestamptzComparisonExp? updatedAt,
    InputauthUserProvidersBoolExp? userProviders,
  });
  TRes $_and(
      Iterable<InputusersBoolExp>? Function(
              Iterable<CopyWith$InputusersBoolExp<InputusersBoolExp>>?)
          _fn);
  CopyWith$InputusersBoolExp<TRes> get $_not;
  TRes $_or(
      Iterable<InputusersBoolExp>? Function(
              Iterable<CopyWith$InputusersBoolExp<InputusersBoolExp>>?)
          _fn);
  CopyWith$InputStringComparisonExp<TRes> get activeMfaType;
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get authenticators;
  CopyWith$InputStringComparisonExp<TRes> get avatarUrl;
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt;
  CopyWith$InputStringComparisonExp<TRes> get currentChallenge;
  CopyWith$InputStringComparisonExp<TRes> get defaultRole;
  CopyWith$InputauthRolesBoolExp<TRes> get defaultRoleByRole;
  CopyWith$InputBooleanComparisonExp<TRes> get disabled;
  CopyWith$InputStringComparisonExp<TRes> get displayName;
  CopyWith$InputCitextComparisonExp<TRes> get email;
  CopyWith$InputBooleanComparisonExp<TRes> get emailVerified;
  CopyWith$InputUuidComparisonExp<TRes> get id;
  CopyWith$InputBooleanComparisonExp<TRes> get isAnonymous;
  CopyWith$InputTimestamptzComparisonExp<TRes> get lastSeen;
  CopyWith$InputStringComparisonExp<TRes> get locale;
  CopyWith$InputJsonbComparisonExp<TRes> get metadata;
  CopyWith$InputCitextComparisonExp<TRes> get newEmail;
  CopyWith$InputStringComparisonExp<TRes> get otpHash;
  CopyWith$InputTimestamptzComparisonExp<TRes> get otpHashExpiresAt;
  CopyWith$InputStringComparisonExp<TRes> get otpMethodLastUsed;
  CopyWith$InputStringComparisonExp<TRes> get passwordHash;
  CopyWith$InputStringComparisonExp<TRes> get phoneNumber;
  CopyWith$InputBooleanComparisonExp<TRes> get phoneNumberVerified;
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get refreshTokens;
  CopyWith$InputauthUserRolesBoolExp<TRes> get roles;
  CopyWith$InputStringComparisonExp<TRes> get ticket;
  CopyWith$InputTimestamptzComparisonExp<TRes> get ticketExpiresAt;
  CopyWith$InputStringComparisonExp<TRes> get totpSecret;
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt;
  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders;
}

class _CopyWithImpl$InputusersBoolExp<TRes>
    implements CopyWith$InputusersBoolExp<TRes> {
  _CopyWithImpl$InputusersBoolExp(
    this._instance,
    this._then,
  );

  final InputusersBoolExp _instance;

  final TRes Function(InputusersBoolExp) _then;

  static const _undefined = {};

  TRes call({
    Object? $_and = _undefined,
    Object? $_not = _undefined,
    Object? $_or = _undefined,
    Object? activeMfaType = _undefined,
    Object? authenticators = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? defaultRoleByRole = _undefined,
    Object? disabled = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? emailVerified = _undefined,
    Object? id = _undefined,
    Object? isAnonymous = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? metadata = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberVerified = _undefined,
    Object? refreshTokens = _undefined,
    Object? roles = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
    Object? userProviders = _undefined,
  }) =>
      _then(InputusersBoolExp._({
        ..._instance._$data,
        if ($_and != _undefined) '_and': ($_and as List<InputusersBoolExp>?),
        if ($_not != _undefined) '_not': ($_not as InputusersBoolExp?),
        if ($_or != _undefined) '_or': ($_or as List<InputusersBoolExp>?),
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as InputStringComparisonExp?),
        if (authenticators != _undefined)
          'authenticators':
              (authenticators as InputauthUserAuthenticatorsBoolExp?),
        if (avatarUrl != _undefined)
          'avatarUrl': (avatarUrl as InputStringComparisonExp?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as InputTimestamptzComparisonExp?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as InputStringComparisonExp?),
        if (defaultRole != _undefined)
          'defaultRole': (defaultRole as InputStringComparisonExp?),
        if (defaultRoleByRole != _undefined)
          'defaultRoleByRole': (defaultRoleByRole as InputauthRolesBoolExp?),
        if (disabled != _undefined)
          'disabled': (disabled as InputBooleanComparisonExp?),
        if (displayName != _undefined)
          'displayName': (displayName as InputStringComparisonExp?),
        if (email != _undefined) 'email': (email as InputCitextComparisonExp?),
        if (emailVerified != _undefined)
          'emailVerified': (emailVerified as InputBooleanComparisonExp?),
        if (id != _undefined) 'id': (id as InputUuidComparisonExp?),
        if (isAnonymous != _undefined)
          'isAnonymous': (isAnonymous as InputBooleanComparisonExp?),
        if (lastSeen != _undefined)
          'lastSeen': (lastSeen as InputTimestamptzComparisonExp?),
        if (locale != _undefined)
          'locale': (locale as InputStringComparisonExp?),
        if (metadata != _undefined)
          'metadata': (metadata as InputJsonbComparisonExp?),
        if (newEmail != _undefined)
          'newEmail': (newEmail as InputCitextComparisonExp?),
        if (otpHash != _undefined)
          'otpHash': (otpHash as InputStringComparisonExp?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt':
              (otpHashExpiresAt as InputTimestamptzComparisonExp?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as InputStringComparisonExp?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as InputStringComparisonExp?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as InputStringComparisonExp?),
        if (phoneNumberVerified != _undefined)
          'phoneNumberVerified':
              (phoneNumberVerified as InputBooleanComparisonExp?),
        if (refreshTokens != _undefined)
          'refreshTokens': (refreshTokens as InputauthRefreshTokensBoolExp?),
        if (roles != _undefined) 'roles': (roles as InputauthUserRolesBoolExp?),
        if (ticket != _undefined)
          'ticket': (ticket as InputStringComparisonExp?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt':
              (ticketExpiresAt as InputTimestamptzComparisonExp?),
        if (totpSecret != _undefined)
          'totpSecret': (totpSecret as InputStringComparisonExp?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as InputTimestamptzComparisonExp?),
        if (userProviders != _undefined)
          'userProviders': (userProviders as InputauthUserProvidersBoolExp?),
      }));
  TRes $_and(
          Iterable<InputusersBoolExp>? Function(
                  Iterable<CopyWith$InputusersBoolExp<InputusersBoolExp>>?)
              _fn) =>
      call(
          $_and: _fn(_instance.$_and?.map((e) => CopyWith$InputusersBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputusersBoolExp<TRes> get $_not {
    final local$$_not = _instance.$_not;
    return local$$_not == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$$_not, (e) => call($_not: e));
  }

  TRes $_or(
          Iterable<InputusersBoolExp>? Function(
                  Iterable<CopyWith$InputusersBoolExp<InputusersBoolExp>>?)
              _fn) =>
      call(
          $_or: _fn(_instance.$_or?.map((e) => CopyWith$InputusersBoolExp(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$InputStringComparisonExp<TRes> get activeMfaType {
    final local$activeMfaType = _instance.activeMfaType;
    return local$activeMfaType == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$activeMfaType, (e) => call(activeMfaType: e));
  }

  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get authenticators {
    final local$authenticators = _instance.authenticators;
    return local$authenticators == null
        ? CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserAuthenticatorsBoolExp(
            local$authenticators, (e) => call(authenticators: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get avatarUrl {
    final local$avatarUrl = _instance.avatarUrl;
    return local$avatarUrl == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$avatarUrl, (e) => call(avatarUrl: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get currentChallenge {
    final local$currentChallenge = _instance.currentChallenge;
    return local$currentChallenge == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$currentChallenge, (e) => call(currentChallenge: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get defaultRole {
    final local$defaultRole = _instance.defaultRole;
    return local$defaultRole == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$defaultRole, (e) => call(defaultRole: e));
  }

  CopyWith$InputauthRolesBoolExp<TRes> get defaultRoleByRole {
    final local$defaultRoleByRole = _instance.defaultRoleByRole;
    return local$defaultRoleByRole == null
        ? CopyWith$InputauthRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRolesBoolExp(
            local$defaultRoleByRole, (e) => call(defaultRoleByRole: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get disabled {
    final local$disabled = _instance.disabled;
    return local$disabled == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$disabled, (e) => call(disabled: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get displayName {
    final local$displayName = _instance.displayName;
    return local$displayName == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$displayName, (e) => call(displayName: e));
  }

  CopyWith$InputCitextComparisonExp<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$InputCitextComparisonExp.stub(_then(_instance))
        : CopyWith$InputCitextComparisonExp(local$email, (e) => call(email: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get emailVerified {
    final local$emailVerified = _instance.emailVerified;
    return local$emailVerified == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$emailVerified, (e) => call(emailVerified: e));
  }

  CopyWith$InputUuidComparisonExp<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$InputUuidComparisonExp.stub(_then(_instance))
        : CopyWith$InputUuidComparisonExp(local$id, (e) => call(id: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get isAnonymous {
    final local$isAnonymous = _instance.isAnonymous;
    return local$isAnonymous == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$isAnonymous, (e) => call(isAnonymous: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get lastSeen {
    final local$lastSeen = _instance.lastSeen;
    return local$lastSeen == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$lastSeen, (e) => call(lastSeen: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get locale {
    final local$locale = _instance.locale;
    return local$locale == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$locale, (e) => call(locale: e));
  }

  CopyWith$InputJsonbComparisonExp<TRes> get metadata {
    final local$metadata = _instance.metadata;
    return local$metadata == null
        ? CopyWith$InputJsonbComparisonExp.stub(_then(_instance))
        : CopyWith$InputJsonbComparisonExp(
            local$metadata, (e) => call(metadata: e));
  }

  CopyWith$InputCitextComparisonExp<TRes> get newEmail {
    final local$newEmail = _instance.newEmail;
    return local$newEmail == null
        ? CopyWith$InputCitextComparisonExp.stub(_then(_instance))
        : CopyWith$InputCitextComparisonExp(
            local$newEmail, (e) => call(newEmail: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get otpHash {
    final local$otpHash = _instance.otpHash;
    return local$otpHash == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$otpHash, (e) => call(otpHash: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get otpHashExpiresAt {
    final local$otpHashExpiresAt = _instance.otpHashExpiresAt;
    return local$otpHashExpiresAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$otpHashExpiresAt, (e) => call(otpHashExpiresAt: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get otpMethodLastUsed {
    final local$otpMethodLastUsed = _instance.otpMethodLastUsed;
    return local$otpMethodLastUsed == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$otpMethodLastUsed, (e) => call(otpMethodLastUsed: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get passwordHash {
    final local$passwordHash = _instance.passwordHash;
    return local$passwordHash == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$passwordHash, (e) => call(passwordHash: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get phoneNumber {
    final local$phoneNumber = _instance.phoneNumber;
    return local$phoneNumber == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$phoneNumber, (e) => call(phoneNumber: e));
  }

  CopyWith$InputBooleanComparisonExp<TRes> get phoneNumberVerified {
    final local$phoneNumberVerified = _instance.phoneNumberVerified;
    return local$phoneNumberVerified == null
        ? CopyWith$InputBooleanComparisonExp.stub(_then(_instance))
        : CopyWith$InputBooleanComparisonExp(
            local$phoneNumberVerified, (e) => call(phoneNumberVerified: e));
  }

  CopyWith$InputauthRefreshTokensBoolExp<TRes> get refreshTokens {
    final local$refreshTokens = _instance.refreshTokens;
    return local$refreshTokens == null
        ? CopyWith$InputauthRefreshTokensBoolExp.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensBoolExp(
            local$refreshTokens, (e) => call(refreshTokens: e));
  }

  CopyWith$InputauthUserRolesBoolExp<TRes> get roles {
    final local$roles = _instance.roles;
    return local$roles == null
        ? CopyWith$InputauthUserRolesBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserRolesBoolExp(
            local$roles, (e) => call(roles: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get ticket {
    final local$ticket = _instance.ticket;
    return local$ticket == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$ticket, (e) => call(ticket: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get ticketExpiresAt {
    final local$ticketExpiresAt = _instance.ticketExpiresAt;
    return local$ticketExpiresAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$ticketExpiresAt, (e) => call(ticketExpiresAt: e));
  }

  CopyWith$InputStringComparisonExp<TRes> get totpSecret {
    final local$totpSecret = _instance.totpSecret;
    return local$totpSecret == null
        ? CopyWith$InputStringComparisonExp.stub(_then(_instance))
        : CopyWith$InputStringComparisonExp(
            local$totpSecret, (e) => call(totpSecret: e));
  }

  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$InputTimestamptzComparisonExp.stub(_then(_instance))
        : CopyWith$InputTimestamptzComparisonExp(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders {
    final local$userProviders = _instance.userProviders;
    return local$userProviders == null
        ? CopyWith$InputauthUserProvidersBoolExp.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersBoolExp(
            local$userProviders, (e) => call(userProviders: e));
  }
}

class _CopyWithStubImpl$InputusersBoolExp<TRes>
    implements CopyWith$InputusersBoolExp<TRes> {
  _CopyWithStubImpl$InputusersBoolExp(this._res);

  TRes _res;

  call({
    List<InputusersBoolExp>? $_and,
    InputusersBoolExp? $_not,
    List<InputusersBoolExp>? $_or,
    InputStringComparisonExp? activeMfaType,
    InputauthUserAuthenticatorsBoolExp? authenticators,
    InputStringComparisonExp? avatarUrl,
    InputTimestamptzComparisonExp? createdAt,
    InputStringComparisonExp? currentChallenge,
    InputStringComparisonExp? defaultRole,
    InputauthRolesBoolExp? defaultRoleByRole,
    InputBooleanComparisonExp? disabled,
    InputStringComparisonExp? displayName,
    InputCitextComparisonExp? email,
    InputBooleanComparisonExp? emailVerified,
    InputUuidComparisonExp? id,
    InputBooleanComparisonExp? isAnonymous,
    InputTimestamptzComparisonExp? lastSeen,
    InputStringComparisonExp? locale,
    InputJsonbComparisonExp? metadata,
    InputCitextComparisonExp? newEmail,
    InputStringComparisonExp? otpHash,
    InputTimestamptzComparisonExp? otpHashExpiresAt,
    InputStringComparisonExp? otpMethodLastUsed,
    InputStringComparisonExp? passwordHash,
    InputStringComparisonExp? phoneNumber,
    InputBooleanComparisonExp? phoneNumberVerified,
    InputauthRefreshTokensBoolExp? refreshTokens,
    InputauthUserRolesBoolExp? roles,
    InputStringComparisonExp? ticket,
    InputTimestamptzComparisonExp? ticketExpiresAt,
    InputStringComparisonExp? totpSecret,
    InputTimestamptzComparisonExp? updatedAt,
    InputauthUserProvidersBoolExp? userProviders,
  }) =>
      _res;
  $_and(_fn) => _res;
  CopyWith$InputusersBoolExp<TRes> get $_not =>
      CopyWith$InputusersBoolExp.stub(_res);
  $_or(_fn) => _res;
  CopyWith$InputStringComparisonExp<TRes> get activeMfaType =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputauthUserAuthenticatorsBoolExp<TRes> get authenticators =>
      CopyWith$InputauthUserAuthenticatorsBoolExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get avatarUrl =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get createdAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get currentChallenge =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get defaultRole =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputauthRolesBoolExp<TRes> get defaultRoleByRole =>
      CopyWith$InputauthRolesBoolExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get disabled =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get displayName =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputCitextComparisonExp<TRes> get email =>
      CopyWith$InputCitextComparisonExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get emailVerified =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputUuidComparisonExp<TRes> get id =>
      CopyWith$InputUuidComparisonExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get isAnonymous =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get lastSeen =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get locale =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputJsonbComparisonExp<TRes> get metadata =>
      CopyWith$InputJsonbComparisonExp.stub(_res);
  CopyWith$InputCitextComparisonExp<TRes> get newEmail =>
      CopyWith$InputCitextComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get otpHash =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get otpHashExpiresAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get otpMethodLastUsed =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get passwordHash =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get phoneNumber =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputBooleanComparisonExp<TRes> get phoneNumberVerified =>
      CopyWith$InputBooleanComparisonExp.stub(_res);
  CopyWith$InputauthRefreshTokensBoolExp<TRes> get refreshTokens =>
      CopyWith$InputauthRefreshTokensBoolExp.stub(_res);
  CopyWith$InputauthUserRolesBoolExp<TRes> get roles =>
      CopyWith$InputauthUserRolesBoolExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get ticket =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get ticketExpiresAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputStringComparisonExp<TRes> get totpSecret =>
      CopyWith$InputStringComparisonExp.stub(_res);
  CopyWith$InputTimestamptzComparisonExp<TRes> get updatedAt =>
      CopyWith$InputTimestamptzComparisonExp.stub(_res);
  CopyWith$InputauthUserProvidersBoolExp<TRes> get userProviders =>
      CopyWith$InputauthUserProvidersBoolExp.stub(_res);
}

class InputusersDeleteAtPathInput {
  factory InputusersDeleteAtPathInput({List<String>? metadata}) =>
      InputusersDeleteAtPathInput._({
        if (metadata != null) r'metadata': metadata,
      });

  InputusersDeleteAtPathInput._(this._$data);

  factory InputusersDeleteAtPathInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] =
          (l$metadata as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return InputusersDeleteAtPathInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get metadata => (_$data['metadata'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$InputusersDeleteAtPathInput<InputusersDeleteAtPathInput>
      get copyWith => CopyWith$InputusersDeleteAtPathInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersDeleteAtPathInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != null && lOther$metadata != null) {
      if (l$metadata.length != lOther$metadata.length) {
        return false;
      }
      for (int i = 0; i < l$metadata.length; i++) {
        final l$metadata$entry = l$metadata[i];
        final lOther$metadata$entry = lOther$metadata[i];
        if (l$metadata$entry != lOther$metadata$entry) {
          return false;
        }
      }
    } else if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll([
      _$data.containsKey('metadata')
          ? l$metadata == null
              ? null
              : Object.hashAll(l$metadata.map((v) => v))
          : const {}
    ]);
  }
}

abstract class CopyWith$InputusersDeleteAtPathInput<TRes> {
  factory CopyWith$InputusersDeleteAtPathInput(
    InputusersDeleteAtPathInput instance,
    TRes Function(InputusersDeleteAtPathInput) then,
  ) = _CopyWithImpl$InputusersDeleteAtPathInput;

  factory CopyWith$InputusersDeleteAtPathInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersDeleteAtPathInput;

  TRes call({List<String>? metadata});
}

class _CopyWithImpl$InputusersDeleteAtPathInput<TRes>
    implements CopyWith$InputusersDeleteAtPathInput<TRes> {
  _CopyWithImpl$InputusersDeleteAtPathInput(
    this._instance,
    this._then,
  );

  final InputusersDeleteAtPathInput _instance;

  final TRes Function(InputusersDeleteAtPathInput) _then;

  static const _undefined = {};

  TRes call({Object? metadata = _undefined}) =>
      _then(InputusersDeleteAtPathInput._({
        ..._instance._$data,
        if (metadata != _undefined) 'metadata': (metadata as List<String>?),
      }));
}

class _CopyWithStubImpl$InputusersDeleteAtPathInput<TRes>
    implements CopyWith$InputusersDeleteAtPathInput<TRes> {
  _CopyWithStubImpl$InputusersDeleteAtPathInput(this._res);

  TRes _res;

  call({List<String>? metadata}) => _res;
}

class InputusersDeleteElemInput {
  factory InputusersDeleteElemInput({int? metadata}) =>
      InputusersDeleteElemInput._({
        if (metadata != null) r'metadata': metadata,
      });

  InputusersDeleteElemInput._(this._$data);

  factory InputusersDeleteElemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as int?);
    }
    return InputusersDeleteElemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get metadata => (_$data['metadata'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    return result$data;
  }

  CopyWith$InputusersDeleteElemInput<InputusersDeleteElemInput> get copyWith =>
      CopyWith$InputusersDeleteElemInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersDeleteElemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll(
        [_$data.containsKey('metadata') ? l$metadata : const {}]);
  }
}

abstract class CopyWith$InputusersDeleteElemInput<TRes> {
  factory CopyWith$InputusersDeleteElemInput(
    InputusersDeleteElemInput instance,
    TRes Function(InputusersDeleteElemInput) then,
  ) = _CopyWithImpl$InputusersDeleteElemInput;

  factory CopyWith$InputusersDeleteElemInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersDeleteElemInput;

  TRes call({int? metadata});
}

class _CopyWithImpl$InputusersDeleteElemInput<TRes>
    implements CopyWith$InputusersDeleteElemInput<TRes> {
  _CopyWithImpl$InputusersDeleteElemInput(
    this._instance,
    this._then,
  );

  final InputusersDeleteElemInput _instance;

  final TRes Function(InputusersDeleteElemInput) _then;

  static const _undefined = {};

  TRes call({Object? metadata = _undefined}) =>
      _then(InputusersDeleteElemInput._({
        ..._instance._$data,
        if (metadata != _undefined) 'metadata': (metadata as int?),
      }));
}

class _CopyWithStubImpl$InputusersDeleteElemInput<TRes>
    implements CopyWith$InputusersDeleteElemInput<TRes> {
  _CopyWithStubImpl$InputusersDeleteElemInput(this._res);

  TRes _res;

  call({int? metadata}) => _res;
}

class InputusersDeleteKeyInput {
  factory InputusersDeleteKeyInput({String? metadata}) =>
      InputusersDeleteKeyInput._({
        if (metadata != null) r'metadata': metadata,
      });

  InputusersDeleteKeyInput._(this._$data);

  factory InputusersDeleteKeyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as String?);
    }
    return InputusersDeleteKeyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get metadata => (_$data['metadata'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    return result$data;
  }

  CopyWith$InputusersDeleteKeyInput<InputusersDeleteKeyInput> get copyWith =>
      CopyWith$InputusersDeleteKeyInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersDeleteKeyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll(
        [_$data.containsKey('metadata') ? l$metadata : const {}]);
  }
}

abstract class CopyWith$InputusersDeleteKeyInput<TRes> {
  factory CopyWith$InputusersDeleteKeyInput(
    InputusersDeleteKeyInput instance,
    TRes Function(InputusersDeleteKeyInput) then,
  ) = _CopyWithImpl$InputusersDeleteKeyInput;

  factory CopyWith$InputusersDeleteKeyInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersDeleteKeyInput;

  TRes call({String? metadata});
}

class _CopyWithImpl$InputusersDeleteKeyInput<TRes>
    implements CopyWith$InputusersDeleteKeyInput<TRes> {
  _CopyWithImpl$InputusersDeleteKeyInput(
    this._instance,
    this._then,
  );

  final InputusersDeleteKeyInput _instance;

  final TRes Function(InputusersDeleteKeyInput) _then;

  static const _undefined = {};

  TRes call({Object? metadata = _undefined}) =>
      _then(InputusersDeleteKeyInput._({
        ..._instance._$data,
        if (metadata != _undefined) 'metadata': (metadata as String?),
      }));
}

class _CopyWithStubImpl$InputusersDeleteKeyInput<TRes>
    implements CopyWith$InputusersDeleteKeyInput<TRes> {
  _CopyWithStubImpl$InputusersDeleteKeyInput(this._res);

  TRes _res;

  call({String? metadata}) => _res;
}

class InputusersInsertInput {
  factory InputusersInsertInput({
    String? activeMfaType,
    InputauthUserAuthenticatorsArrRelInsertInput? authenticators,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    InputauthRolesObjRelInsertInput? defaultRoleByRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    InputauthRefreshTokensArrRelInsertInput? refreshTokens,
    InputauthUserRolesArrRelInsertInput? roles,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  }) =>
      InputusersInsertInput._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (authenticators != null) r'authenticators': authenticators,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (defaultRoleByRole != null) r'defaultRoleByRole': defaultRoleByRole,
        if (disabled != null) r'disabled': disabled,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (emailVerified != null) r'emailVerified': emailVerified,
        if (id != null) r'id': id,
        if (isAnonymous != null) r'isAnonymous': isAnonymous,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (metadata != null) r'metadata': metadata,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberVerified != null)
          r'phoneNumberVerified': phoneNumberVerified,
        if (refreshTokens != null) r'refreshTokens': refreshTokens,
        if (roles != null) r'roles': roles,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userProviders != null) r'userProviders': userProviders,
      });

  InputusersInsertInput._(this._$data);

  factory InputusersInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = (l$activeMfaType as String?);
    }
    if (data.containsKey('authenticators')) {
      final l$authenticators = data['authenticators'];
      result$data['authenticators'] = l$authenticators == null
          ? null
          : InputauthUserAuthenticatorsArrRelInsertInput.fromJson(
              (l$authenticators as Map<String, dynamic>));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = (l$avatarUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = (l$currentChallenge as String?);
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = (l$defaultRole as String?);
    }
    if (data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = data['defaultRoleByRole'];
      result$data['defaultRoleByRole'] = l$defaultRoleByRole == null
          ? null
          : InputauthRolesObjRelInsertInput.fromJson(
              (l$defaultRoleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('disabled')) {
      final l$disabled = data['disabled'];
      result$data['disabled'] = (l$disabled as bool?);
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('emailVerified')) {
      final l$emailVerified = data['emailVerified'];
      result$data['emailVerified'] = (l$emailVerified as bool?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isAnonymous')) {
      final l$isAnonymous = data['isAnonymous'];
      result$data['isAnonymous'] = (l$isAnonymous as bool?);
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$lastSeen);
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] = (l$locale as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as Map<String, dynamic>?);
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = (l$newEmail as String?);
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = (l$otpHash as String?);
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$otpHashExpiresAt);
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = (l$otpMethodLastUsed as String?);
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = (l$passwordHash as String?);
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = (l$phoneNumber as String?);
    }
    if (data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = data['phoneNumberVerified'];
      result$data['phoneNumberVerified'] = (l$phoneNumberVerified as bool?);
    }
    if (data.containsKey('refreshTokens')) {
      final l$refreshTokens = data['refreshTokens'];
      result$data['refreshTokens'] = l$refreshTokens == null
          ? null
          : InputauthRefreshTokensArrRelInsertInput.fromJson(
              (l$refreshTokens as Map<String, dynamic>));
    }
    if (data.containsKey('roles')) {
      final l$roles = data['roles'];
      result$data['roles'] = l$roles == null
          ? null
          : InputauthUserRolesArrRelInsertInput.fromJson(
              (l$roles as Map<String, dynamic>));
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] = (l$ticket as String?);
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$ticketExpiresAt);
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = (l$totpSecret as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    if (data.containsKey('userProviders')) {
      final l$userProviders = data['userProviders'];
      result$data['userProviders'] = l$userProviders == null
          ? null
          : InputauthUserProvidersArrRelInsertInput.fromJson(
              (l$userProviders as Map<String, dynamic>));
    }
    return InputusersInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get activeMfaType => (_$data['activeMfaType'] as String?);
  InputauthUserAuthenticatorsArrRelInsertInput? get authenticators =>
      (_$data['authenticators']
          as InputauthUserAuthenticatorsArrRelInsertInput?);
  String? get avatarUrl => (_$data['avatarUrl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get currentChallenge => (_$data['currentChallenge'] as String?);
  String? get defaultRole => (_$data['defaultRole'] as String?);
  InputauthRolesObjRelInsertInput? get defaultRoleByRole =>
      (_$data['defaultRoleByRole'] as InputauthRolesObjRelInsertInput?);
  bool? get disabled => (_$data['disabled'] as bool?);
  String? get displayName => (_$data['displayName'] as String?);
  String? get email => (_$data['email'] as String?);
  bool? get emailVerified => (_$data['emailVerified'] as bool?);
  String? get id => (_$data['id'] as String?);
  bool? get isAnonymous => (_$data['isAnonymous'] as bool?);
  DateTime? get lastSeen => (_$data['lastSeen'] as DateTime?);
  String? get locale => (_$data['locale'] as String?);
  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);
  String? get newEmail => (_$data['newEmail'] as String?);
  String? get otpHash => (_$data['otpHash'] as String?);
  DateTime? get otpHashExpiresAt => (_$data['otpHashExpiresAt'] as DateTime?);
  String? get otpMethodLastUsed => (_$data['otpMethodLastUsed'] as String?);
  String? get passwordHash => (_$data['passwordHash'] as String?);
  String? get phoneNumber => (_$data['phoneNumber'] as String?);
  bool? get phoneNumberVerified => (_$data['phoneNumberVerified'] as bool?);
  InputauthRefreshTokensArrRelInsertInput? get refreshTokens =>
      (_$data['refreshTokens'] as InputauthRefreshTokensArrRelInsertInput?);
  InputauthUserRolesArrRelInsertInput? get roles =>
      (_$data['roles'] as InputauthUserRolesArrRelInsertInput?);
  String? get ticket => (_$data['ticket'] as String?);
  DateTime? get ticketExpiresAt => (_$data['ticketExpiresAt'] as DateTime?);
  String? get totpSecret => (_$data['totpSecret'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  InputauthUserProvidersArrRelInsertInput? get userProviders =>
      (_$data['userProviders'] as InputauthUserProvidersArrRelInsertInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] = l$activeMfaType;
    }
    if (_$data.containsKey('authenticators')) {
      final l$authenticators = authenticators;
      result$data['authenticators'] = l$authenticators?.toJson();
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge;
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] = l$defaultRole;
    }
    if (_$data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = defaultRoleByRole;
      result$data['defaultRoleByRole'] = l$defaultRoleByRole?.toJson();
    }
    if (_$data.containsKey('disabled')) {
      final l$disabled = disabled;
      result$data['disabled'] = l$disabled;
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('emailVerified')) {
      final l$emailVerified = emailVerified;
      result$data['emailVerified'] = l$emailVerified;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isAnonymous')) {
      final l$isAnonymous = isAnonymous;
      result$data['isAnonymous'] = l$isAnonymous;
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] = l$locale;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] = l$newEmail;
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] = l$otpHash;
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed;
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash;
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber;
    }
    if (_$data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = phoneNumberVerified;
      result$data['phoneNumberVerified'] = l$phoneNumberVerified;
    }
    if (_$data.containsKey('refreshTokens')) {
      final l$refreshTokens = refreshTokens;
      result$data['refreshTokens'] = l$refreshTokens?.toJson();
    }
    if (_$data.containsKey('roles')) {
      final l$roles = roles;
      result$data['roles'] = l$roles?.toJson();
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] = l$ticket;
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] = l$totpSecret;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    if (_$data.containsKey('userProviders')) {
      final l$userProviders = userProviders;
      result$data['userProviders'] = l$userProviders?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersInsertInput<InputusersInsertInput> get copyWith =>
      CopyWith$InputusersInsertInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersInsertInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$authenticators = authenticators;
    final lOther$authenticators = other.authenticators;
    if (_$data.containsKey('authenticators') !=
        other._$data.containsKey('authenticators')) {
      return false;
    }
    if (l$authenticators != lOther$authenticators) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$defaultRoleByRole = defaultRoleByRole;
    final lOther$defaultRoleByRole = other.defaultRoleByRole;
    if (_$data.containsKey('defaultRoleByRole') !=
        other._$data.containsKey('defaultRoleByRole')) {
      return false;
    }
    if (l$defaultRoleByRole != lOther$defaultRoleByRole) {
      return false;
    }
    final l$disabled = disabled;
    final lOther$disabled = other.disabled;
    if (_$data.containsKey('disabled') !=
        other._$data.containsKey('disabled')) {
      return false;
    }
    if (l$disabled != lOther$disabled) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailVerified = emailVerified;
    final lOther$emailVerified = other.emailVerified;
    if (_$data.containsKey('emailVerified') !=
        other._$data.containsKey('emailVerified')) {
      return false;
    }
    if (l$emailVerified != lOther$emailVerified) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isAnonymous = isAnonymous;
    final lOther$isAnonymous = other.isAnonymous;
    if (_$data.containsKey('isAnonymous') !=
        other._$data.containsKey('isAnonymous')) {
      return false;
    }
    if (l$isAnonymous != lOther$isAnonymous) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberVerified = phoneNumberVerified;
    final lOther$phoneNumberVerified = other.phoneNumberVerified;
    if (_$data.containsKey('phoneNumberVerified') !=
        other._$data.containsKey('phoneNumberVerified')) {
      return false;
    }
    if (l$phoneNumberVerified != lOther$phoneNumberVerified) {
      return false;
    }
    final l$refreshTokens = refreshTokens;
    final lOther$refreshTokens = other.refreshTokens;
    if (_$data.containsKey('refreshTokens') !=
        other._$data.containsKey('refreshTokens')) {
      return false;
    }
    if (l$refreshTokens != lOther$refreshTokens) {
      return false;
    }
    final l$roles = roles;
    final lOther$roles = other.roles;
    if (_$data.containsKey('roles') != other._$data.containsKey('roles')) {
      return false;
    }
    if (l$roles != lOther$roles) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userProviders = userProviders;
    final lOther$userProviders = other.userProviders;
    if (_$data.containsKey('userProviders') !=
        other._$data.containsKey('userProviders')) {
      return false;
    }
    if (l$userProviders != lOther$userProviders) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$authenticators = authenticators;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$defaultRoleByRole = defaultRoleByRole;
    final l$disabled = disabled;
    final l$displayName = displayName;
    final l$email = email;
    final l$emailVerified = emailVerified;
    final l$id = id;
    final l$isAnonymous = isAnonymous;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$metadata = metadata;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberVerified = phoneNumberVerified;
    final l$refreshTokens = refreshTokens;
    final l$roles = roles;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    final l$userProviders = userProviders;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('authenticators') ? l$authenticators : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('defaultRoleByRole') ? l$defaultRoleByRole : const {},
      _$data.containsKey('disabled') ? l$disabled : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailVerified') ? l$emailVerified : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isAnonymous') ? l$isAnonymous : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberVerified')
          ? l$phoneNumberVerified
          : const {},
      _$data.containsKey('refreshTokens') ? l$refreshTokens : const {},
      _$data.containsKey('roles') ? l$roles : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userProviders') ? l$userProviders : const {},
    ]);
  }
}

abstract class CopyWith$InputusersInsertInput<TRes> {
  factory CopyWith$InputusersInsertInput(
    InputusersInsertInput instance,
    TRes Function(InputusersInsertInput) then,
  ) = _CopyWithImpl$InputusersInsertInput;

  factory CopyWith$InputusersInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersInsertInput;

  TRes call({
    String? activeMfaType,
    InputauthUserAuthenticatorsArrRelInsertInput? authenticators,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    InputauthRolesObjRelInsertInput? defaultRoleByRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    InputauthRefreshTokensArrRelInsertInput? refreshTokens,
    InputauthUserRolesArrRelInsertInput? roles,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  });
  CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes>
      get authenticators;
  CopyWith$InputauthRolesObjRelInsertInput<TRes> get defaultRoleByRole;
  CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> get refreshTokens;
  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get roles;
  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders;
}

class _CopyWithImpl$InputusersInsertInput<TRes>
    implements CopyWith$InputusersInsertInput<TRes> {
  _CopyWithImpl$InputusersInsertInput(
    this._instance,
    this._then,
  );

  final InputusersInsertInput _instance;

  final TRes Function(InputusersInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? authenticators = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? defaultRoleByRole = _undefined,
    Object? disabled = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? emailVerified = _undefined,
    Object? id = _undefined,
    Object? isAnonymous = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? metadata = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberVerified = _undefined,
    Object? refreshTokens = _undefined,
    Object? roles = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
    Object? userProviders = _undefined,
  }) =>
      _then(InputusersInsertInput._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as String?),
        if (authenticators != _undefined)
          'authenticators':
              (authenticators as InputauthUserAuthenticatorsArrRelInsertInput?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as String?),
        if (defaultRole != _undefined) 'defaultRole': (defaultRole as String?),
        if (defaultRoleByRole != _undefined)
          'defaultRoleByRole':
              (defaultRoleByRole as InputauthRolesObjRelInsertInput?),
        if (disabled != _undefined) 'disabled': (disabled as bool?),
        if (displayName != _undefined) 'displayName': (displayName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (emailVerified != _undefined)
          'emailVerified': (emailVerified as bool?),
        if (id != _undefined) 'id': (id as String?),
        if (isAnonymous != _undefined) 'isAnonymous': (isAnonymous as bool?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as DateTime?),
        if (locale != _undefined) 'locale': (locale as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
        if (newEmail != _undefined) 'newEmail': (newEmail as String?),
        if (otpHash != _undefined) 'otpHash': (otpHash as String?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as DateTime?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as String?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as String?),
        if (phoneNumber != _undefined) 'phoneNumber': (phoneNumber as String?),
        if (phoneNumberVerified != _undefined)
          'phoneNumberVerified': (phoneNumberVerified as bool?),
        if (refreshTokens != _undefined)
          'refreshTokens':
              (refreshTokens as InputauthRefreshTokensArrRelInsertInput?),
        if (roles != _undefined)
          'roles': (roles as InputauthUserRolesArrRelInsertInput?),
        if (ticket != _undefined) 'ticket': (ticket as String?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as DateTime?),
        if (totpSecret != _undefined) 'totpSecret': (totpSecret as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
        if (userProviders != _undefined)
          'userProviders':
              (userProviders as InputauthUserProvidersArrRelInsertInput?),
      }));
  CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes>
      get authenticators {
    final local$authenticators = _instance.authenticators;
    return local$authenticators == null
        ? CopyWith$InputauthUserAuthenticatorsArrRelInsertInput.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticatorsArrRelInsertInput(
            local$authenticators, (e) => call(authenticators: e));
  }

  CopyWith$InputauthRolesObjRelInsertInput<TRes> get defaultRoleByRole {
    final local$defaultRoleByRole = _instance.defaultRoleByRole;
    return local$defaultRoleByRole == null
        ? CopyWith$InputauthRolesObjRelInsertInput.stub(_then(_instance))
        : CopyWith$InputauthRolesObjRelInsertInput(
            local$defaultRoleByRole, (e) => call(defaultRoleByRole: e));
  }

  CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> get refreshTokens {
    final local$refreshTokens = _instance.refreshTokens;
    return local$refreshTokens == null
        ? CopyWith$InputauthRefreshTokensArrRelInsertInput.stub(
            _then(_instance))
        : CopyWith$InputauthRefreshTokensArrRelInsertInput(
            local$refreshTokens, (e) => call(refreshTokens: e));
  }

  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get roles {
    final local$roles = _instance.roles;
    return local$roles == null
        ? CopyWith$InputauthUserRolesArrRelInsertInput.stub(_then(_instance))
        : CopyWith$InputauthUserRolesArrRelInsertInput(
            local$roles, (e) => call(roles: e));
  }

  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders {
    final local$userProviders = _instance.userProviders;
    return local$userProviders == null
        ? CopyWith$InputauthUserProvidersArrRelInsertInput.stub(
            _then(_instance))
        : CopyWith$InputauthUserProvidersArrRelInsertInput(
            local$userProviders, (e) => call(userProviders: e));
  }
}

class _CopyWithStubImpl$InputusersInsertInput<TRes>
    implements CopyWith$InputusersInsertInput<TRes> {
  _CopyWithStubImpl$InputusersInsertInput(this._res);

  TRes _res;

  call({
    String? activeMfaType,
    InputauthUserAuthenticatorsArrRelInsertInput? authenticators,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    InputauthRolesObjRelInsertInput? defaultRoleByRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    InputauthRefreshTokensArrRelInsertInput? refreshTokens,
    InputauthUserRolesArrRelInsertInput? roles,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
    InputauthUserProvidersArrRelInsertInput? userProviders,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticatorsArrRelInsertInput<TRes>
      get authenticators =>
          CopyWith$InputauthUserAuthenticatorsArrRelInsertInput.stub(_res);
  CopyWith$InputauthRolesObjRelInsertInput<TRes> get defaultRoleByRole =>
      CopyWith$InputauthRolesObjRelInsertInput.stub(_res);
  CopyWith$InputauthRefreshTokensArrRelInsertInput<TRes> get refreshTokens =>
      CopyWith$InputauthRefreshTokensArrRelInsertInput.stub(_res);
  CopyWith$InputauthUserRolesArrRelInsertInput<TRes> get roles =>
      CopyWith$InputauthUserRolesArrRelInsertInput.stub(_res);
  CopyWith$InputauthUserProvidersArrRelInsertInput<TRes> get userProviders =>
      CopyWith$InputauthUserProvidersArrRelInsertInput.stub(_res);
}

class InputusersObjRelInsertInput {
  factory InputusersObjRelInsertInput({
    required InputusersInsertInput data,
    InputusersOnConflict? onConflict,
  }) =>
      InputusersObjRelInsertInput._({
        r'data': data,
        if (onConflict != null) r'onConflict': onConflict,
      });

  InputusersObjRelInsertInput._(this._$data);

  factory InputusersObjRelInsertInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] =
        InputusersInsertInput.fromJson((l$data as Map<String, dynamic>));
    if (data.containsKey('onConflict')) {
      final l$onConflict = data['onConflict'];
      result$data['onConflict'] = l$onConflict == null
          ? null
          : InputusersOnConflict.fromJson(
              (l$onConflict as Map<String, dynamic>));
    }
    return InputusersObjRelInsertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  InputusersInsertInput get data => (_$data['data'] as InputusersInsertInput);
  InputusersOnConflict? get onConflict =>
      (_$data['onConflict'] as InputusersOnConflict?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('onConflict')) {
      final l$onConflict = onConflict;
      result$data['onConflict'] = l$onConflict?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersObjRelInsertInput<InputusersObjRelInsertInput>
      get copyWith => CopyWith$InputusersObjRelInsertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersObjRelInsertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$onConflict = onConflict;
    final lOther$onConflict = other.onConflict;
    if (_$data.containsKey('onConflict') !=
        other._$data.containsKey('onConflict')) {
      return false;
    }
    if (l$onConflict != lOther$onConflict) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$onConflict = onConflict;
    return Object.hashAll([
      l$data,
      _$data.containsKey('onConflict') ? l$onConflict : const {},
    ]);
  }
}

abstract class CopyWith$InputusersObjRelInsertInput<TRes> {
  factory CopyWith$InputusersObjRelInsertInput(
    InputusersObjRelInsertInput instance,
    TRes Function(InputusersObjRelInsertInput) then,
  ) = _CopyWithImpl$InputusersObjRelInsertInput;

  factory CopyWith$InputusersObjRelInsertInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersObjRelInsertInput;

  TRes call({
    InputusersInsertInput? data,
    InputusersOnConflict? onConflict,
  });
  CopyWith$InputusersInsertInput<TRes> get data;
  CopyWith$InputusersOnConflict<TRes> get onConflict;
}

class _CopyWithImpl$InputusersObjRelInsertInput<TRes>
    implements CopyWith$InputusersObjRelInsertInput<TRes> {
  _CopyWithImpl$InputusersObjRelInsertInput(
    this._instance,
    this._then,
  );

  final InputusersObjRelInsertInput _instance;

  final TRes Function(InputusersObjRelInsertInput) _then;

  static const _undefined = {};

  TRes call({
    Object? data = _undefined,
    Object? onConflict = _undefined,
  }) =>
      _then(InputusersObjRelInsertInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as InputusersInsertInput),
        if (onConflict != _undefined)
          'onConflict': (onConflict as InputusersOnConflict?),
      }));
  CopyWith$InputusersInsertInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$InputusersInsertInput(local$data, (e) => call(data: e));
  }

  CopyWith$InputusersOnConflict<TRes> get onConflict {
    final local$onConflict = _instance.onConflict;
    return local$onConflict == null
        ? CopyWith$InputusersOnConflict.stub(_then(_instance))
        : CopyWith$InputusersOnConflict(
            local$onConflict, (e) => call(onConflict: e));
  }
}

class _CopyWithStubImpl$InputusersObjRelInsertInput<TRes>
    implements CopyWith$InputusersObjRelInsertInput<TRes> {
  _CopyWithStubImpl$InputusersObjRelInsertInput(this._res);

  TRes _res;

  call({
    InputusersInsertInput? data,
    InputusersOnConflict? onConflict,
  }) =>
      _res;
  CopyWith$InputusersInsertInput<TRes> get data =>
      CopyWith$InputusersInsertInput.stub(_res);
  CopyWith$InputusersOnConflict<TRes> get onConflict =>
      CopyWith$InputusersOnConflict.stub(_res);
}

class InputusersOnConflict {
  factory InputusersOnConflict({
    required EnumusersConstraint constraint,
    required List<EnumusersUpdateColumn> update_columns,
    InputusersBoolExp? where,
  }) =>
      InputusersOnConflict._({
        r'constraint': constraint,
        r'update_columns': update_columns,
        if (where != null) r'where': where,
      });

  InputusersOnConflict._(this._$data);

  factory InputusersOnConflict.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$constraint = data['constraint'];
    result$data['constraint'] =
        fromJson$EnumusersConstraint((l$constraint as String));
    final l$update_columns = data['update_columns'];
    result$data['update_columns'] = (l$update_columns as List<dynamic>)
        .map((e) => fromJson$EnumusersUpdateColumn((e as String)))
        .toList();
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : InputusersBoolExp.fromJson((l$where as Map<String, dynamic>));
    }
    return InputusersOnConflict._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumusersConstraint get constraint =>
      (_$data['constraint'] as EnumusersConstraint);
  List<EnumusersUpdateColumn> get update_columns =>
      (_$data['update_columns'] as List<EnumusersUpdateColumn>);
  InputusersBoolExp? get where => (_$data['where'] as InputusersBoolExp?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$constraint = constraint;
    result$data['constraint'] = toJson$EnumusersConstraint(l$constraint);
    final l$update_columns = update_columns;
    result$data['update_columns'] =
        l$update_columns.map((e) => toJson$EnumusersUpdateColumn(e)).toList();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersOnConflict<InputusersOnConflict> get copyWith =>
      CopyWith$InputusersOnConflict(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersOnConflict) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$constraint = constraint;
    final lOther$constraint = other.constraint;
    if (l$constraint != lOther$constraint) {
      return false;
    }
    final l$update_columns = update_columns;
    final lOther$update_columns = other.update_columns;
    if (l$update_columns.length != lOther$update_columns.length) {
      return false;
    }
    for (int i = 0; i < l$update_columns.length; i++) {
      final l$update_columns$entry = l$update_columns[i];
      final lOther$update_columns$entry = lOther$update_columns[i];
      if (l$update_columns$entry != lOther$update_columns$entry) {
        return false;
      }
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$constraint = constraint;
    final l$update_columns = update_columns;
    final l$where = where;
    return Object.hashAll([
      l$constraint,
      Object.hashAll(l$update_columns.map((v) => v)),
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$InputusersOnConflict<TRes> {
  factory CopyWith$InputusersOnConflict(
    InputusersOnConflict instance,
    TRes Function(InputusersOnConflict) then,
  ) = _CopyWithImpl$InputusersOnConflict;

  factory CopyWith$InputusersOnConflict.stub(TRes res) =
      _CopyWithStubImpl$InputusersOnConflict;

  TRes call({
    EnumusersConstraint? constraint,
    List<EnumusersUpdateColumn>? update_columns,
    InputusersBoolExp? where,
  });
  CopyWith$InputusersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputusersOnConflict<TRes>
    implements CopyWith$InputusersOnConflict<TRes> {
  _CopyWithImpl$InputusersOnConflict(
    this._instance,
    this._then,
  );

  final InputusersOnConflict _instance;

  final TRes Function(InputusersOnConflict) _then;

  static const _undefined = {};

  TRes call({
    Object? constraint = _undefined,
    Object? update_columns = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputusersOnConflict._({
        ..._instance._$data,
        if (constraint != _undefined && constraint != null)
          'constraint': (constraint as EnumusersConstraint),
        if (update_columns != _undefined && update_columns != null)
          'update_columns': (update_columns as List<EnumusersUpdateColumn>),
        if (where != _undefined) 'where': (where as InputusersBoolExp?),
      }));
  CopyWith$InputusersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$InputusersBoolExp.stub(_then(_instance))
        : CopyWith$InputusersBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputusersOnConflict<TRes>
    implements CopyWith$InputusersOnConflict<TRes> {
  _CopyWithStubImpl$InputusersOnConflict(this._res);

  TRes _res;

  call({
    EnumusersConstraint? constraint,
    List<EnumusersUpdateColumn>? update_columns,
    InputusersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputusersBoolExp<TRes> get where =>
      CopyWith$InputusersBoolExp.stub(_res);
}

class InputusersOrderBy {
  factory InputusersOrderBy({
    EnumOrderBy? activeMfaType,
    InputauthUserAuthenticatorsAggregateOrderBy? authenticatorsAggregate,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    InputauthRolesOrderBy? defaultRoleByRole,
    EnumOrderBy? disabled,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? emailVerified,
    EnumOrderBy? id,
    EnumOrderBy? isAnonymous,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? metadata,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? phoneNumberVerified,
    InputauthRefreshTokensAggregateOrderBy? refreshTokensAggregate,
    InputauthUserRolesAggregateOrderBy? rolesAggregate,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  }) =>
      InputusersOrderBy._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (authenticatorsAggregate != null)
          r'authenticatorsAggregate': authenticatorsAggregate,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (defaultRoleByRole != null) r'defaultRoleByRole': defaultRoleByRole,
        if (disabled != null) r'disabled': disabled,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (emailVerified != null) r'emailVerified': emailVerified,
        if (id != null) r'id': id,
        if (isAnonymous != null) r'isAnonymous': isAnonymous,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (metadata != null) r'metadata': metadata,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberVerified != null)
          r'phoneNumberVerified': phoneNumberVerified,
        if (refreshTokensAggregate != null)
          r'refreshTokensAggregate': refreshTokensAggregate,
        if (rolesAggregate != null) r'rolesAggregate': rolesAggregate,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userProvidersAggregate != null)
          r'userProvidersAggregate': userProvidersAggregate,
      });

  InputusersOrderBy._(this._$data);

  factory InputusersOrderBy.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = l$activeMfaType == null
          ? null
          : fromJson$EnumOrderBy((l$activeMfaType as String));
    }
    if (data.containsKey('authenticatorsAggregate')) {
      final l$authenticatorsAggregate = data['authenticatorsAggregate'];
      result$data['authenticatorsAggregate'] = l$authenticatorsAggregate == null
          ? null
          : InputauthUserAuthenticatorsAggregateOrderBy.fromJson(
              (l$authenticatorsAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : fromJson$EnumOrderBy((l$avatarUrl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : fromJson$EnumOrderBy((l$currentChallenge as String));
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = l$defaultRole == null
          ? null
          : fromJson$EnumOrderBy((l$defaultRole as String));
    }
    if (data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = data['defaultRoleByRole'];
      result$data['defaultRoleByRole'] = l$defaultRoleByRole == null
          ? null
          : InputauthRolesOrderBy.fromJson(
              (l$defaultRoleByRole as Map<String, dynamic>));
    }
    if (data.containsKey('disabled')) {
      final l$disabled = data['disabled'];
      result$data['disabled'] = l$disabled == null
          ? null
          : fromJson$EnumOrderBy((l$disabled as String));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : fromJson$EnumOrderBy((l$displayName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] =
          l$email == null ? null : fromJson$EnumOrderBy((l$email as String));
    }
    if (data.containsKey('emailVerified')) {
      final l$emailVerified = data['emailVerified'];
      result$data['emailVerified'] = l$emailVerified == null
          ? null
          : fromJson$EnumOrderBy((l$emailVerified as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('isAnonymous')) {
      final l$isAnonymous = data['isAnonymous'];
      result$data['isAnonymous'] = l$isAnonymous == null
          ? null
          : fromJson$EnumOrderBy((l$isAnonymous as String));
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromJson$EnumOrderBy((l$lastSeen as String));
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] =
          l$locale == null ? null : fromJson$EnumOrderBy((l$locale as String));
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = l$metadata == null
          ? null
          : fromJson$EnumOrderBy((l$metadata as String));
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = l$newEmail == null
          ? null
          : fromJson$EnumOrderBy((l$newEmail as String));
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = l$otpHash == null
          ? null
          : fromJson$EnumOrderBy((l$otpHash as String));
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$otpHashExpiresAt as String));
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : fromJson$EnumOrderBy((l$otpMethodLastUsed as String));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : fromJson$EnumOrderBy((l$passwordHash as String));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : fromJson$EnumOrderBy((l$phoneNumber as String));
    }
    if (data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = data['phoneNumberVerified'];
      result$data['phoneNumberVerified'] = l$phoneNumberVerified == null
          ? null
          : fromJson$EnumOrderBy((l$phoneNumberVerified as String));
    }
    if (data.containsKey('refreshTokensAggregate')) {
      final l$refreshTokensAggregate = data['refreshTokensAggregate'];
      result$data['refreshTokensAggregate'] = l$refreshTokensAggregate == null
          ? null
          : InputauthRefreshTokensAggregateOrderBy.fromJson(
              (l$refreshTokensAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('rolesAggregate')) {
      final l$rolesAggregate = data['rolesAggregate'];
      result$data['rolesAggregate'] = l$rolesAggregate == null
          ? null
          : InputauthUserRolesAggregateOrderBy.fromJson(
              (l$rolesAggregate as Map<String, dynamic>));
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] =
          l$ticket == null ? null : fromJson$EnumOrderBy((l$ticket as String));
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$ticketExpiresAt as String));
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = l$totpSecret == null
          ? null
          : fromJson$EnumOrderBy((l$totpSecret as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    if (data.containsKey('userProvidersAggregate')) {
      final l$userProvidersAggregate = data['userProvidersAggregate'];
      result$data['userProvidersAggregate'] = l$userProvidersAggregate == null
          ? null
          : InputauthUserProvidersAggregateOrderBy.fromJson(
              (l$userProvidersAggregate as Map<String, dynamic>));
    }
    return InputusersOrderBy._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get activeMfaType => (_$data['activeMfaType'] as EnumOrderBy?);
  InputauthUserAuthenticatorsAggregateOrderBy? get authenticatorsAggregate =>
      (_$data['authenticatorsAggregate']
          as InputauthUserAuthenticatorsAggregateOrderBy?);
  EnumOrderBy? get avatarUrl => (_$data['avatarUrl'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get currentChallenge =>
      (_$data['currentChallenge'] as EnumOrderBy?);
  EnumOrderBy? get defaultRole => (_$data['defaultRole'] as EnumOrderBy?);
  InputauthRolesOrderBy? get defaultRoleByRole =>
      (_$data['defaultRoleByRole'] as InputauthRolesOrderBy?);
  EnumOrderBy? get disabled => (_$data['disabled'] as EnumOrderBy?);
  EnumOrderBy? get displayName => (_$data['displayName'] as EnumOrderBy?);
  EnumOrderBy? get email => (_$data['email'] as EnumOrderBy?);
  EnumOrderBy? get emailVerified => (_$data['emailVerified'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get isAnonymous => (_$data['isAnonymous'] as EnumOrderBy?);
  EnumOrderBy? get lastSeen => (_$data['lastSeen'] as EnumOrderBy?);
  EnumOrderBy? get locale => (_$data['locale'] as EnumOrderBy?);
  EnumOrderBy? get metadata => (_$data['metadata'] as EnumOrderBy?);
  EnumOrderBy? get newEmail => (_$data['newEmail'] as EnumOrderBy?);
  EnumOrderBy? get otpHash => (_$data['otpHash'] as EnumOrderBy?);
  EnumOrderBy? get otpHashExpiresAt =>
      (_$data['otpHashExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get otpMethodLastUsed =>
      (_$data['otpMethodLastUsed'] as EnumOrderBy?);
  EnumOrderBy? get passwordHash => (_$data['passwordHash'] as EnumOrderBy?);
  EnumOrderBy? get phoneNumber => (_$data['phoneNumber'] as EnumOrderBy?);
  EnumOrderBy? get phoneNumberVerified =>
      (_$data['phoneNumberVerified'] as EnumOrderBy?);
  InputauthRefreshTokensAggregateOrderBy? get refreshTokensAggregate =>
      (_$data['refreshTokensAggregate']
          as InputauthRefreshTokensAggregateOrderBy?);
  InputauthUserRolesAggregateOrderBy? get rolesAggregate =>
      (_$data['rolesAggregate'] as InputauthUserRolesAggregateOrderBy?);
  EnumOrderBy? get ticket => (_$data['ticket'] as EnumOrderBy?);
  EnumOrderBy? get ticketExpiresAt =>
      (_$data['ticketExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get totpSecret => (_$data['totpSecret'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  InputauthUserProvidersAggregateOrderBy? get userProvidersAggregate =>
      (_$data['userProvidersAggregate']
          as InputauthUserProvidersAggregateOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] =
          l$activeMfaType == null ? null : toJson$EnumOrderBy(l$activeMfaType);
    }
    if (_$data.containsKey('authenticatorsAggregate')) {
      final l$authenticatorsAggregate = authenticatorsAggregate;
      result$data['authenticatorsAggregate'] =
          l$authenticatorsAggregate?.toJson();
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] =
          l$avatarUrl == null ? null : toJson$EnumOrderBy(l$avatarUrl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : toJson$EnumOrderBy(l$currentChallenge);
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] =
          l$defaultRole == null ? null : toJson$EnumOrderBy(l$defaultRole);
    }
    if (_$data.containsKey('defaultRoleByRole')) {
      final l$defaultRoleByRole = defaultRoleByRole;
      result$data['defaultRoleByRole'] = l$defaultRoleByRole?.toJson();
    }
    if (_$data.containsKey('disabled')) {
      final l$disabled = disabled;
      result$data['disabled'] =
          l$disabled == null ? null : toJson$EnumOrderBy(l$disabled);
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] =
          l$displayName == null ? null : toJson$EnumOrderBy(l$displayName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] =
          l$email == null ? null : toJson$EnumOrderBy(l$email);
    }
    if (_$data.containsKey('emailVerified')) {
      final l$emailVerified = emailVerified;
      result$data['emailVerified'] =
          l$emailVerified == null ? null : toJson$EnumOrderBy(l$emailVerified);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('isAnonymous')) {
      final l$isAnonymous = isAnonymous;
      result$data['isAnonymous'] =
          l$isAnonymous == null ? null : toJson$EnumOrderBy(l$isAnonymous);
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] =
          l$lastSeen == null ? null : toJson$EnumOrderBy(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] =
          l$locale == null ? null : toJson$EnumOrderBy(l$locale);
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] =
          l$metadata == null ? null : toJson$EnumOrderBy(l$metadata);
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] =
          l$newEmail == null ? null : toJson$EnumOrderBy(l$newEmail);
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] =
          l$otpHash == null ? null : toJson$EnumOrderBy(l$otpHash);
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : toJson$EnumOrderBy(l$otpMethodLastUsed);
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] =
          l$passwordHash == null ? null : toJson$EnumOrderBy(l$passwordHash);
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] =
          l$phoneNumber == null ? null : toJson$EnumOrderBy(l$phoneNumber);
    }
    if (_$data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = phoneNumberVerified;
      result$data['phoneNumberVerified'] = l$phoneNumberVerified == null
          ? null
          : toJson$EnumOrderBy(l$phoneNumberVerified);
    }
    if (_$data.containsKey('refreshTokensAggregate')) {
      final l$refreshTokensAggregate = refreshTokensAggregate;
      result$data['refreshTokensAggregate'] =
          l$refreshTokensAggregate?.toJson();
    }
    if (_$data.containsKey('rolesAggregate')) {
      final l$rolesAggregate = rolesAggregate;
      result$data['rolesAggregate'] = l$rolesAggregate?.toJson();
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] =
          l$ticket == null ? null : toJson$EnumOrderBy(l$ticket);
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] =
          l$totpSecret == null ? null : toJson$EnumOrderBy(l$totpSecret);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    if (_$data.containsKey('userProvidersAggregate')) {
      final l$userProvidersAggregate = userProvidersAggregate;
      result$data['userProvidersAggregate'] =
          l$userProvidersAggregate?.toJson();
    }
    return result$data;
  }

  CopyWith$InputusersOrderBy<InputusersOrderBy> get copyWith =>
      CopyWith$InputusersOrderBy(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersOrderBy) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$authenticatorsAggregate = authenticatorsAggregate;
    final lOther$authenticatorsAggregate = other.authenticatorsAggregate;
    if (_$data.containsKey('authenticatorsAggregate') !=
        other._$data.containsKey('authenticatorsAggregate')) {
      return false;
    }
    if (l$authenticatorsAggregate != lOther$authenticatorsAggregate) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$defaultRoleByRole = defaultRoleByRole;
    final lOther$defaultRoleByRole = other.defaultRoleByRole;
    if (_$data.containsKey('defaultRoleByRole') !=
        other._$data.containsKey('defaultRoleByRole')) {
      return false;
    }
    if (l$defaultRoleByRole != lOther$defaultRoleByRole) {
      return false;
    }
    final l$disabled = disabled;
    final lOther$disabled = other.disabled;
    if (_$data.containsKey('disabled') !=
        other._$data.containsKey('disabled')) {
      return false;
    }
    if (l$disabled != lOther$disabled) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailVerified = emailVerified;
    final lOther$emailVerified = other.emailVerified;
    if (_$data.containsKey('emailVerified') !=
        other._$data.containsKey('emailVerified')) {
      return false;
    }
    if (l$emailVerified != lOther$emailVerified) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isAnonymous = isAnonymous;
    final lOther$isAnonymous = other.isAnonymous;
    if (_$data.containsKey('isAnonymous') !=
        other._$data.containsKey('isAnonymous')) {
      return false;
    }
    if (l$isAnonymous != lOther$isAnonymous) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberVerified = phoneNumberVerified;
    final lOther$phoneNumberVerified = other.phoneNumberVerified;
    if (_$data.containsKey('phoneNumberVerified') !=
        other._$data.containsKey('phoneNumberVerified')) {
      return false;
    }
    if (l$phoneNumberVerified != lOther$phoneNumberVerified) {
      return false;
    }
    final l$refreshTokensAggregate = refreshTokensAggregate;
    final lOther$refreshTokensAggregate = other.refreshTokensAggregate;
    if (_$data.containsKey('refreshTokensAggregate') !=
        other._$data.containsKey('refreshTokensAggregate')) {
      return false;
    }
    if (l$refreshTokensAggregate != lOther$refreshTokensAggregate) {
      return false;
    }
    final l$rolesAggregate = rolesAggregate;
    final lOther$rolesAggregate = other.rolesAggregate;
    if (_$data.containsKey('rolesAggregate') !=
        other._$data.containsKey('rolesAggregate')) {
      return false;
    }
    if (l$rolesAggregate != lOther$rolesAggregate) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userProvidersAggregate = userProvidersAggregate;
    final lOther$userProvidersAggregate = other.userProvidersAggregate;
    if (_$data.containsKey('userProvidersAggregate') !=
        other._$data.containsKey('userProvidersAggregate')) {
      return false;
    }
    if (l$userProvidersAggregate != lOther$userProvidersAggregate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$authenticatorsAggregate = authenticatorsAggregate;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$defaultRoleByRole = defaultRoleByRole;
    final l$disabled = disabled;
    final l$displayName = displayName;
    final l$email = email;
    final l$emailVerified = emailVerified;
    final l$id = id;
    final l$isAnonymous = isAnonymous;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$metadata = metadata;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberVerified = phoneNumberVerified;
    final l$refreshTokensAggregate = refreshTokensAggregate;
    final l$rolesAggregate = rolesAggregate;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    final l$userProvidersAggregate = userProvidersAggregate;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('authenticatorsAggregate')
          ? l$authenticatorsAggregate
          : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('defaultRoleByRole') ? l$defaultRoleByRole : const {},
      _$data.containsKey('disabled') ? l$disabled : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailVerified') ? l$emailVerified : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isAnonymous') ? l$isAnonymous : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberVerified')
          ? l$phoneNumberVerified
          : const {},
      _$data.containsKey('refreshTokensAggregate')
          ? l$refreshTokensAggregate
          : const {},
      _$data.containsKey('rolesAggregate') ? l$rolesAggregate : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userProvidersAggregate')
          ? l$userProvidersAggregate
          : const {},
    ]);
  }
}

abstract class CopyWith$InputusersOrderBy<TRes> {
  factory CopyWith$InputusersOrderBy(
    InputusersOrderBy instance,
    TRes Function(InputusersOrderBy) then,
  ) = _CopyWithImpl$InputusersOrderBy;

  factory CopyWith$InputusersOrderBy.stub(TRes res) =
      _CopyWithStubImpl$InputusersOrderBy;

  TRes call({
    EnumOrderBy? activeMfaType,
    InputauthUserAuthenticatorsAggregateOrderBy? authenticatorsAggregate,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    InputauthRolesOrderBy? defaultRoleByRole,
    EnumOrderBy? disabled,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? emailVerified,
    EnumOrderBy? id,
    EnumOrderBy? isAnonymous,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? metadata,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? phoneNumberVerified,
    InputauthRefreshTokensAggregateOrderBy? refreshTokensAggregate,
    InputauthUserRolesAggregateOrderBy? rolesAggregate,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  });
  CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes>
      get authenticatorsAggregate;
  CopyWith$InputauthRolesOrderBy<TRes> get defaultRoleByRole;
  CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes>
      get refreshTokensAggregate;
  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get rolesAggregate;
  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate;
}

class _CopyWithImpl$InputusersOrderBy<TRes>
    implements CopyWith$InputusersOrderBy<TRes> {
  _CopyWithImpl$InputusersOrderBy(
    this._instance,
    this._then,
  );

  final InputusersOrderBy _instance;

  final TRes Function(InputusersOrderBy) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? authenticatorsAggregate = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? defaultRoleByRole = _undefined,
    Object? disabled = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? emailVerified = _undefined,
    Object? id = _undefined,
    Object? isAnonymous = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? metadata = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberVerified = _undefined,
    Object? refreshTokensAggregate = _undefined,
    Object? rolesAggregate = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
    Object? userProvidersAggregate = _undefined,
  }) =>
      _then(InputusersOrderBy._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as EnumOrderBy?),
        if (authenticatorsAggregate != _undefined)
          'authenticatorsAggregate': (authenticatorsAggregate
              as InputauthUserAuthenticatorsAggregateOrderBy?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as EnumOrderBy?),
        if (defaultRole != _undefined)
          'defaultRole': (defaultRole as EnumOrderBy?),
        if (defaultRoleByRole != _undefined)
          'defaultRoleByRole': (defaultRoleByRole as InputauthRolesOrderBy?),
        if (disabled != _undefined) 'disabled': (disabled as EnumOrderBy?),
        if (displayName != _undefined)
          'displayName': (displayName as EnumOrderBy?),
        if (email != _undefined) 'email': (email as EnumOrderBy?),
        if (emailVerified != _undefined)
          'emailVerified': (emailVerified as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (isAnonymous != _undefined)
          'isAnonymous': (isAnonymous as EnumOrderBy?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as EnumOrderBy?),
        if (locale != _undefined) 'locale': (locale as EnumOrderBy?),
        if (metadata != _undefined) 'metadata': (metadata as EnumOrderBy?),
        if (newEmail != _undefined) 'newEmail': (newEmail as EnumOrderBy?),
        if (otpHash != _undefined) 'otpHash': (otpHash as EnumOrderBy?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as EnumOrderBy?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as EnumOrderBy?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as EnumOrderBy?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as EnumOrderBy?),
        if (phoneNumberVerified != _undefined)
          'phoneNumberVerified': (phoneNumberVerified as EnumOrderBy?),
        if (refreshTokensAggregate != _undefined)
          'refreshTokensAggregate': (refreshTokensAggregate
              as InputauthRefreshTokensAggregateOrderBy?),
        if (rolesAggregate != _undefined)
          'rolesAggregate':
              (rolesAggregate as InputauthUserRolesAggregateOrderBy?),
        if (ticket != _undefined) 'ticket': (ticket as EnumOrderBy?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as EnumOrderBy?),
        if (totpSecret != _undefined)
          'totpSecret': (totpSecret as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
        if (userProvidersAggregate != _undefined)
          'userProvidersAggregate': (userProvidersAggregate
              as InputauthUserProvidersAggregateOrderBy?),
      }));
  CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes>
      get authenticatorsAggregate {
    final local$authenticatorsAggregate = _instance.authenticatorsAggregate;
    return local$authenticatorsAggregate == null
        ? CopyWith$InputauthUserAuthenticatorsAggregateOrderBy.stub(
            _then(_instance))
        : CopyWith$InputauthUserAuthenticatorsAggregateOrderBy(
            local$authenticatorsAggregate,
            (e) => call(authenticatorsAggregate: e));
  }

  CopyWith$InputauthRolesOrderBy<TRes> get defaultRoleByRole {
    final local$defaultRoleByRole = _instance.defaultRoleByRole;
    return local$defaultRoleByRole == null
        ? CopyWith$InputauthRolesOrderBy.stub(_then(_instance))
        : CopyWith$InputauthRolesOrderBy(
            local$defaultRoleByRole, (e) => call(defaultRoleByRole: e));
  }

  CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes>
      get refreshTokensAggregate {
    final local$refreshTokensAggregate = _instance.refreshTokensAggregate;
    return local$refreshTokensAggregate == null
        ? CopyWith$InputauthRefreshTokensAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputauthRefreshTokensAggregateOrderBy(
            local$refreshTokensAggregate,
            (e) => call(refreshTokensAggregate: e));
  }

  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get rolesAggregate {
    final local$rolesAggregate = _instance.rolesAggregate;
    return local$rolesAggregate == null
        ? CopyWith$InputauthUserRolesAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputauthUserRolesAggregateOrderBy(
            local$rolesAggregate, (e) => call(rolesAggregate: e));
  }

  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate {
    final local$userProvidersAggregate = _instance.userProvidersAggregate;
    return local$userProvidersAggregate == null
        ? CopyWith$InputauthUserProvidersAggregateOrderBy.stub(_then(_instance))
        : CopyWith$InputauthUserProvidersAggregateOrderBy(
            local$userProvidersAggregate,
            (e) => call(userProvidersAggregate: e));
  }
}

class _CopyWithStubImpl$InputusersOrderBy<TRes>
    implements CopyWith$InputusersOrderBy<TRes> {
  _CopyWithStubImpl$InputusersOrderBy(this._res);

  TRes _res;

  call({
    EnumOrderBy? activeMfaType,
    InputauthUserAuthenticatorsAggregateOrderBy? authenticatorsAggregate,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    InputauthRolesOrderBy? defaultRoleByRole,
    EnumOrderBy? disabled,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? emailVerified,
    EnumOrderBy? id,
    EnumOrderBy? isAnonymous,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? metadata,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? phoneNumberVerified,
    InputauthRefreshTokensAggregateOrderBy? refreshTokensAggregate,
    InputauthUserRolesAggregateOrderBy? rolesAggregate,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
    InputauthUserProvidersAggregateOrderBy? userProvidersAggregate,
  }) =>
      _res;
  CopyWith$InputauthUserAuthenticatorsAggregateOrderBy<TRes>
      get authenticatorsAggregate =>
          CopyWith$InputauthUserAuthenticatorsAggregateOrderBy.stub(_res);
  CopyWith$InputauthRolesOrderBy<TRes> get defaultRoleByRole =>
      CopyWith$InputauthRolesOrderBy.stub(_res);
  CopyWith$InputauthRefreshTokensAggregateOrderBy<TRes>
      get refreshTokensAggregate =>
          CopyWith$InputauthRefreshTokensAggregateOrderBy.stub(_res);
  CopyWith$InputauthUserRolesAggregateOrderBy<TRes> get rolesAggregate =>
      CopyWith$InputauthUserRolesAggregateOrderBy.stub(_res);
  CopyWith$InputauthUserProvidersAggregateOrderBy<TRes>
      get userProvidersAggregate =>
          CopyWith$InputauthUserProvidersAggregateOrderBy.stub(_res);
}

class InputusersPkColumnsInput {
  factory InputusersPkColumnsInput({required String id}) =>
      InputusersPkColumnsInput._({
        r'id': id,
      });

  InputusersPkColumnsInput._(this._$data);

  factory InputusersPkColumnsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return InputusersPkColumnsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$InputusersPkColumnsInput<InputusersPkColumnsInput> get copyWith =>
      CopyWith$InputusersPkColumnsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersPkColumnsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([l$id]);
  }
}

abstract class CopyWith$InputusersPkColumnsInput<TRes> {
  factory CopyWith$InputusersPkColumnsInput(
    InputusersPkColumnsInput instance,
    TRes Function(InputusersPkColumnsInput) then,
  ) = _CopyWithImpl$InputusersPkColumnsInput;

  factory CopyWith$InputusersPkColumnsInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersPkColumnsInput;

  TRes call({String? id});
}

class _CopyWithImpl$InputusersPkColumnsInput<TRes>
    implements CopyWith$InputusersPkColumnsInput<TRes> {
  _CopyWithImpl$InputusersPkColumnsInput(
    this._instance,
    this._then,
  );

  final InputusersPkColumnsInput _instance;

  final TRes Function(InputusersPkColumnsInput) _then;

  static const _undefined = {};

  TRes call({Object? id = _undefined}) => _then(InputusersPkColumnsInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$InputusersPkColumnsInput<TRes>
    implements CopyWith$InputusersPkColumnsInput<TRes> {
  _CopyWithStubImpl$InputusersPkColumnsInput(this._res);

  TRes _res;

  call({String? id}) => _res;
}

class InputusersPrependInput {
  factory InputusersPrependInput({Map<String, dynamic>? metadata}) =>
      InputusersPrependInput._({
        if (metadata != null) r'metadata': metadata,
      });

  InputusersPrependInput._(this._$data);

  factory InputusersPrependInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as Map<String, dynamic>?);
    }
    return InputusersPrependInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    return result$data;
  }

  CopyWith$InputusersPrependInput<InputusersPrependInput> get copyWith =>
      CopyWith$InputusersPrependInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersPrependInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$metadata = metadata;
    return Object.hashAll(
        [_$data.containsKey('metadata') ? l$metadata : const {}]);
  }
}

abstract class CopyWith$InputusersPrependInput<TRes> {
  factory CopyWith$InputusersPrependInput(
    InputusersPrependInput instance,
    TRes Function(InputusersPrependInput) then,
  ) = _CopyWithImpl$InputusersPrependInput;

  factory CopyWith$InputusersPrependInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersPrependInput;

  TRes call({Map<String, dynamic>? metadata});
}

class _CopyWithImpl$InputusersPrependInput<TRes>
    implements CopyWith$InputusersPrependInput<TRes> {
  _CopyWithImpl$InputusersPrependInput(
    this._instance,
    this._then,
  );

  final InputusersPrependInput _instance;

  final TRes Function(InputusersPrependInput) _then;

  static const _undefined = {};

  TRes call({Object? metadata = _undefined}) => _then(InputusersPrependInput._({
        ..._instance._$data,
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
      }));
}

class _CopyWithStubImpl$InputusersPrependInput<TRes>
    implements CopyWith$InputusersPrependInput<TRes> {
  _CopyWithStubImpl$InputusersPrependInput(this._res);

  TRes _res;

  call({Map<String, dynamic>? metadata}) => _res;
}

class InputusersSetInput {
  factory InputusersSetInput({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  }) =>
      InputusersSetInput._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (disabled != null) r'disabled': disabled,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (emailVerified != null) r'emailVerified': emailVerified,
        if (id != null) r'id': id,
        if (isAnonymous != null) r'isAnonymous': isAnonymous,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (metadata != null) r'metadata': metadata,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberVerified != null)
          r'phoneNumberVerified': phoneNumberVerified,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  InputusersSetInput._(this._$data);

  factory InputusersSetInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = (l$activeMfaType as String?);
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = (l$avatarUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = (l$currentChallenge as String?);
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = (l$defaultRole as String?);
    }
    if (data.containsKey('disabled')) {
      final l$disabled = data['disabled'];
      result$data['disabled'] = (l$disabled as bool?);
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('emailVerified')) {
      final l$emailVerified = data['emailVerified'];
      result$data['emailVerified'] = (l$emailVerified as bool?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isAnonymous')) {
      final l$isAnonymous = data['isAnonymous'];
      result$data['isAnonymous'] = (l$isAnonymous as bool?);
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$lastSeen);
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] = (l$locale as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as Map<String, dynamic>?);
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = (l$newEmail as String?);
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = (l$otpHash as String?);
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$otpHashExpiresAt);
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = (l$otpMethodLastUsed as String?);
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = (l$passwordHash as String?);
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = (l$phoneNumber as String?);
    }
    if (data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = data['phoneNumberVerified'];
      result$data['phoneNumberVerified'] = (l$phoneNumberVerified as bool?);
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] = (l$ticket as String?);
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$ticketExpiresAt);
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = (l$totpSecret as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    return InputusersSetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get activeMfaType => (_$data['activeMfaType'] as String?);
  String? get avatarUrl => (_$data['avatarUrl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get currentChallenge => (_$data['currentChallenge'] as String?);
  String? get defaultRole => (_$data['defaultRole'] as String?);
  bool? get disabled => (_$data['disabled'] as bool?);
  String? get displayName => (_$data['displayName'] as String?);
  String? get email => (_$data['email'] as String?);
  bool? get emailVerified => (_$data['emailVerified'] as bool?);
  String? get id => (_$data['id'] as String?);
  bool? get isAnonymous => (_$data['isAnonymous'] as bool?);
  DateTime? get lastSeen => (_$data['lastSeen'] as DateTime?);
  String? get locale => (_$data['locale'] as String?);
  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);
  String? get newEmail => (_$data['newEmail'] as String?);
  String? get otpHash => (_$data['otpHash'] as String?);
  DateTime? get otpHashExpiresAt => (_$data['otpHashExpiresAt'] as DateTime?);
  String? get otpMethodLastUsed => (_$data['otpMethodLastUsed'] as String?);
  String? get passwordHash => (_$data['passwordHash'] as String?);
  String? get phoneNumber => (_$data['phoneNumber'] as String?);
  bool? get phoneNumberVerified => (_$data['phoneNumberVerified'] as bool?);
  String? get ticket => (_$data['ticket'] as String?);
  DateTime? get ticketExpiresAt => (_$data['ticketExpiresAt'] as DateTime?);
  String? get totpSecret => (_$data['totpSecret'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] = l$activeMfaType;
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge;
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] = l$defaultRole;
    }
    if (_$data.containsKey('disabled')) {
      final l$disabled = disabled;
      result$data['disabled'] = l$disabled;
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('emailVerified')) {
      final l$emailVerified = emailVerified;
      result$data['emailVerified'] = l$emailVerified;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isAnonymous')) {
      final l$isAnonymous = isAnonymous;
      result$data['isAnonymous'] = l$isAnonymous;
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] = l$locale;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] = l$newEmail;
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] = l$otpHash;
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed;
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash;
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber;
    }
    if (_$data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = phoneNumberVerified;
      result$data['phoneNumberVerified'] = l$phoneNumberVerified;
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] = l$ticket;
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] = l$totpSecret;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$InputusersSetInput<InputusersSetInput> get copyWith =>
      CopyWith$InputusersSetInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersSetInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$disabled = disabled;
    final lOther$disabled = other.disabled;
    if (_$data.containsKey('disabled') !=
        other._$data.containsKey('disabled')) {
      return false;
    }
    if (l$disabled != lOther$disabled) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailVerified = emailVerified;
    final lOther$emailVerified = other.emailVerified;
    if (_$data.containsKey('emailVerified') !=
        other._$data.containsKey('emailVerified')) {
      return false;
    }
    if (l$emailVerified != lOther$emailVerified) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isAnonymous = isAnonymous;
    final lOther$isAnonymous = other.isAnonymous;
    if (_$data.containsKey('isAnonymous') !=
        other._$data.containsKey('isAnonymous')) {
      return false;
    }
    if (l$isAnonymous != lOther$isAnonymous) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberVerified = phoneNumberVerified;
    final lOther$phoneNumberVerified = other.phoneNumberVerified;
    if (_$data.containsKey('phoneNumberVerified') !=
        other._$data.containsKey('phoneNumberVerified')) {
      return false;
    }
    if (l$phoneNumberVerified != lOther$phoneNumberVerified) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$disabled = disabled;
    final l$displayName = displayName;
    final l$email = email;
    final l$emailVerified = emailVerified;
    final l$id = id;
    final l$isAnonymous = isAnonymous;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$metadata = metadata;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberVerified = phoneNumberVerified;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('disabled') ? l$disabled : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailVerified') ? l$emailVerified : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isAnonymous') ? l$isAnonymous : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberVerified')
          ? l$phoneNumberVerified
          : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$InputusersSetInput<TRes> {
  factory CopyWith$InputusersSetInput(
    InputusersSetInput instance,
    TRes Function(InputusersSetInput) then,
  ) = _CopyWithImpl$InputusersSetInput;

  factory CopyWith$InputusersSetInput.stub(TRes res) =
      _CopyWithStubImpl$InputusersSetInput;

  TRes call({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$InputusersSetInput<TRes>
    implements CopyWith$InputusersSetInput<TRes> {
  _CopyWithImpl$InputusersSetInput(
    this._instance,
    this._then,
  );

  final InputusersSetInput _instance;

  final TRes Function(InputusersSetInput) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? disabled = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? emailVerified = _undefined,
    Object? id = _undefined,
    Object? isAnonymous = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? metadata = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberVerified = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(InputusersSetInput._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as String?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as String?),
        if (defaultRole != _undefined) 'defaultRole': (defaultRole as String?),
        if (disabled != _undefined) 'disabled': (disabled as bool?),
        if (displayName != _undefined) 'displayName': (displayName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (emailVerified != _undefined)
          'emailVerified': (emailVerified as bool?),
        if (id != _undefined) 'id': (id as String?),
        if (isAnonymous != _undefined) 'isAnonymous': (isAnonymous as bool?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as DateTime?),
        if (locale != _undefined) 'locale': (locale as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
        if (newEmail != _undefined) 'newEmail': (newEmail as String?),
        if (otpHash != _undefined) 'otpHash': (otpHash as String?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as DateTime?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as String?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as String?),
        if (phoneNumber != _undefined) 'phoneNumber': (phoneNumber as String?),
        if (phoneNumberVerified != _undefined)
          'phoneNumberVerified': (phoneNumberVerified as bool?),
        if (ticket != _undefined) 'ticket': (ticket as String?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as DateTime?),
        if (totpSecret != _undefined) 'totpSecret': (totpSecret as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$InputusersSetInput<TRes>
    implements CopyWith$InputusersSetInput<TRes> {
  _CopyWithStubImpl$InputusersSetInput(this._res);

  TRes _res;

  call({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  }) =>
      _res;
}

class InputusersUpdates {
  factory InputusersUpdates({
    InputusersAppendInput? $_append,
    InputusersDeleteAtPathInput? $_deleteAtPath,
    InputusersDeleteElemInput? $_deleteElem,
    InputusersDeleteKeyInput? $_deleteKey,
    InputusersPrependInput? $_prepend,
    InputusersSetInput? $_set,
    required InputusersBoolExp where,
  }) =>
      InputusersUpdates._({
        if ($_append != null) r'_append': $_append,
        if ($_deleteAtPath != null) r'_deleteAtPath': $_deleteAtPath,
        if ($_deleteElem != null) r'_deleteElem': $_deleteElem,
        if ($_deleteKey != null) r'_deleteKey': $_deleteKey,
        if ($_prepend != null) r'_prepend': $_prepend,
        if ($_set != null) r'_set': $_set,
        r'where': where,
      });

  InputusersUpdates._(this._$data);

  factory InputusersUpdates.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_append')) {
      final l$$_append = data['_append'];
      result$data['_append'] = l$$_append == null
          ? null
          : InputusersAppendInput.fromJson(
              (l$$_append as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteAtPath')) {
      final l$$_deleteAtPath = data['_deleteAtPath'];
      result$data['_deleteAtPath'] = l$$_deleteAtPath == null
          ? null
          : InputusersDeleteAtPathInput.fromJson(
              (l$$_deleteAtPath as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteElem')) {
      final l$$_deleteElem = data['_deleteElem'];
      result$data['_deleteElem'] = l$$_deleteElem == null
          ? null
          : InputusersDeleteElemInput.fromJson(
              (l$$_deleteElem as Map<String, dynamic>));
    }
    if (data.containsKey('_deleteKey')) {
      final l$$_deleteKey = data['_deleteKey'];
      result$data['_deleteKey'] = l$$_deleteKey == null
          ? null
          : InputusersDeleteKeyInput.fromJson(
              (l$$_deleteKey as Map<String, dynamic>));
    }
    if (data.containsKey('_prepend')) {
      final l$$_prepend = data['_prepend'];
      result$data['_prepend'] = l$$_prepend == null
          ? null
          : InputusersPrependInput.fromJson(
              (l$$_prepend as Map<String, dynamic>));
    }
    if (data.containsKey('_set')) {
      final l$$_set = data['_set'];
      result$data['_set'] = l$$_set == null
          ? null
          : InputusersSetInput.fromJson((l$$_set as Map<String, dynamic>));
    }
    final l$where = data['where'];
    result$data['where'] =
        InputusersBoolExp.fromJson((l$where as Map<String, dynamic>));
    return InputusersUpdates._(result$data);
  }

  Map<String, dynamic> _$data;

  InputusersAppendInput? get $_append =>
      (_$data['_append'] as InputusersAppendInput?);
  InputusersDeleteAtPathInput? get $_deleteAtPath =>
      (_$data['_deleteAtPath'] as InputusersDeleteAtPathInput?);
  InputusersDeleteElemInput? get $_deleteElem =>
      (_$data['_deleteElem'] as InputusersDeleteElemInput?);
  InputusersDeleteKeyInput? get $_deleteKey =>
      (_$data['_deleteKey'] as InputusersDeleteKeyInput?);
  InputusersPrependInput? get $_prepend =>
      (_$data['_prepend'] as InputusersPrependInput?);
  InputusersSetInput? get $_set => (_$data['_set'] as InputusersSetInput?);
  InputusersBoolExp get where => (_$data['where'] as InputusersBoolExp);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_append')) {
      final l$$_append = $_append;
      result$data['_append'] = l$$_append?.toJson();
    }
    if (_$data.containsKey('_deleteAtPath')) {
      final l$$_deleteAtPath = $_deleteAtPath;
      result$data['_deleteAtPath'] = l$$_deleteAtPath?.toJson();
    }
    if (_$data.containsKey('_deleteElem')) {
      final l$$_deleteElem = $_deleteElem;
      result$data['_deleteElem'] = l$$_deleteElem?.toJson();
    }
    if (_$data.containsKey('_deleteKey')) {
      final l$$_deleteKey = $_deleteKey;
      result$data['_deleteKey'] = l$$_deleteKey?.toJson();
    }
    if (_$data.containsKey('_prepend')) {
      final l$$_prepend = $_prepend;
      result$data['_prepend'] = l$$_prepend?.toJson();
    }
    if (_$data.containsKey('_set')) {
      final l$$_set = $_set;
      result$data['_set'] = l$$_set?.toJson();
    }
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$InputusersUpdates<InputusersUpdates> get copyWith =>
      CopyWith$InputusersUpdates(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is InputusersUpdates) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_append = $_append;
    final lOther$$_append = other.$_append;
    if (_$data.containsKey('_append') != other._$data.containsKey('_append')) {
      return false;
    }
    if (l$$_append != lOther$$_append) {
      return false;
    }
    final l$$_deleteAtPath = $_deleteAtPath;
    final lOther$$_deleteAtPath = other.$_deleteAtPath;
    if (_$data.containsKey('_deleteAtPath') !=
        other._$data.containsKey('_deleteAtPath')) {
      return false;
    }
    if (l$$_deleteAtPath != lOther$$_deleteAtPath) {
      return false;
    }
    final l$$_deleteElem = $_deleteElem;
    final lOther$$_deleteElem = other.$_deleteElem;
    if (_$data.containsKey('_deleteElem') !=
        other._$data.containsKey('_deleteElem')) {
      return false;
    }
    if (l$$_deleteElem != lOther$$_deleteElem) {
      return false;
    }
    final l$$_deleteKey = $_deleteKey;
    final lOther$$_deleteKey = other.$_deleteKey;
    if (_$data.containsKey('_deleteKey') !=
        other._$data.containsKey('_deleteKey')) {
      return false;
    }
    if (l$$_deleteKey != lOther$$_deleteKey) {
      return false;
    }
    final l$$_prepend = $_prepend;
    final lOther$$_prepend = other.$_prepend;
    if (_$data.containsKey('_prepend') !=
        other._$data.containsKey('_prepend')) {
      return false;
    }
    if (l$$_prepend != lOther$$_prepend) {
      return false;
    }
    final l$$_set = $_set;
    final lOther$$_set = other.$_set;
    if (_$data.containsKey('_set') != other._$data.containsKey('_set')) {
      return false;
    }
    if (l$$_set != lOther$$_set) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_append = $_append;
    final l$$_deleteAtPath = $_deleteAtPath;
    final l$$_deleteElem = $_deleteElem;
    final l$$_deleteKey = $_deleteKey;
    final l$$_prepend = $_prepend;
    final l$$_set = $_set;
    final l$where = where;
    return Object.hashAll([
      _$data.containsKey('_append') ? l$$_append : const {},
      _$data.containsKey('_deleteAtPath') ? l$$_deleteAtPath : const {},
      _$data.containsKey('_deleteElem') ? l$$_deleteElem : const {},
      _$data.containsKey('_deleteKey') ? l$$_deleteKey : const {},
      _$data.containsKey('_prepend') ? l$$_prepend : const {},
      _$data.containsKey('_set') ? l$$_set : const {},
      l$where,
    ]);
  }
}

abstract class CopyWith$InputusersUpdates<TRes> {
  factory CopyWith$InputusersUpdates(
    InputusersUpdates instance,
    TRes Function(InputusersUpdates) then,
  ) = _CopyWithImpl$InputusersUpdates;

  factory CopyWith$InputusersUpdates.stub(TRes res) =
      _CopyWithStubImpl$InputusersUpdates;

  TRes call({
    InputusersAppendInput? $_append,
    InputusersDeleteAtPathInput? $_deleteAtPath,
    InputusersDeleteElemInput? $_deleteElem,
    InputusersDeleteKeyInput? $_deleteKey,
    InputusersPrependInput? $_prepend,
    InputusersSetInput? $_set,
    InputusersBoolExp? where,
  });
  CopyWith$InputusersAppendInput<TRes> get $_append;
  CopyWith$InputusersDeleteAtPathInput<TRes> get $_deleteAtPath;
  CopyWith$InputusersDeleteElemInput<TRes> get $_deleteElem;
  CopyWith$InputusersDeleteKeyInput<TRes> get $_deleteKey;
  CopyWith$InputusersPrependInput<TRes> get $_prepend;
  CopyWith$InputusersSetInput<TRes> get $_set;
  CopyWith$InputusersBoolExp<TRes> get where;
}

class _CopyWithImpl$InputusersUpdates<TRes>
    implements CopyWith$InputusersUpdates<TRes> {
  _CopyWithImpl$InputusersUpdates(
    this._instance,
    this._then,
  );

  final InputusersUpdates _instance;

  final TRes Function(InputusersUpdates) _then;

  static const _undefined = {};

  TRes call({
    Object? $_append = _undefined,
    Object? $_deleteAtPath = _undefined,
    Object? $_deleteElem = _undefined,
    Object? $_deleteKey = _undefined,
    Object? $_prepend = _undefined,
    Object? $_set = _undefined,
    Object? where = _undefined,
  }) =>
      _then(InputusersUpdates._({
        ..._instance._$data,
        if ($_append != _undefined)
          '_append': ($_append as InputusersAppendInput?),
        if ($_deleteAtPath != _undefined)
          '_deleteAtPath': ($_deleteAtPath as InputusersDeleteAtPathInput?),
        if ($_deleteElem != _undefined)
          '_deleteElem': ($_deleteElem as InputusersDeleteElemInput?),
        if ($_deleteKey != _undefined)
          '_deleteKey': ($_deleteKey as InputusersDeleteKeyInput?),
        if ($_prepend != _undefined)
          '_prepend': ($_prepend as InputusersPrependInput?),
        if ($_set != _undefined) '_set': ($_set as InputusersSetInput?),
        if (where != _undefined && where != null)
          'where': (where as InputusersBoolExp),
      }));
  CopyWith$InputusersAppendInput<TRes> get $_append {
    final local$$_append = _instance.$_append;
    return local$$_append == null
        ? CopyWith$InputusersAppendInput.stub(_then(_instance))
        : CopyWith$InputusersAppendInput(
            local$$_append, (e) => call($_append: e));
  }

  CopyWith$InputusersDeleteAtPathInput<TRes> get $_deleteAtPath {
    final local$$_deleteAtPath = _instance.$_deleteAtPath;
    return local$$_deleteAtPath == null
        ? CopyWith$InputusersDeleteAtPathInput.stub(_then(_instance))
        : CopyWith$InputusersDeleteAtPathInput(
            local$$_deleteAtPath, (e) => call($_deleteAtPath: e));
  }

  CopyWith$InputusersDeleteElemInput<TRes> get $_deleteElem {
    final local$$_deleteElem = _instance.$_deleteElem;
    return local$$_deleteElem == null
        ? CopyWith$InputusersDeleteElemInput.stub(_then(_instance))
        : CopyWith$InputusersDeleteElemInput(
            local$$_deleteElem, (e) => call($_deleteElem: e));
  }

  CopyWith$InputusersDeleteKeyInput<TRes> get $_deleteKey {
    final local$$_deleteKey = _instance.$_deleteKey;
    return local$$_deleteKey == null
        ? CopyWith$InputusersDeleteKeyInput.stub(_then(_instance))
        : CopyWith$InputusersDeleteKeyInput(
            local$$_deleteKey, (e) => call($_deleteKey: e));
  }

  CopyWith$InputusersPrependInput<TRes> get $_prepend {
    final local$$_prepend = _instance.$_prepend;
    return local$$_prepend == null
        ? CopyWith$InputusersPrependInput.stub(_then(_instance))
        : CopyWith$InputusersPrependInput(
            local$$_prepend, (e) => call($_prepend: e));
  }

  CopyWith$InputusersSetInput<TRes> get $_set {
    final local$$_set = _instance.$_set;
    return local$$_set == null
        ? CopyWith$InputusersSetInput.stub(_then(_instance))
        : CopyWith$InputusersSetInput(local$$_set, (e) => call($_set: e));
  }

  CopyWith$InputusersBoolExp<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$InputusersBoolExp(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$InputusersUpdates<TRes>
    implements CopyWith$InputusersUpdates<TRes> {
  _CopyWithStubImpl$InputusersUpdates(this._res);

  TRes _res;

  call({
    InputusersAppendInput? $_append,
    InputusersDeleteAtPathInput? $_deleteAtPath,
    InputusersDeleteElemInput? $_deleteElem,
    InputusersDeleteKeyInput? $_deleteKey,
    InputusersPrependInput? $_prepend,
    InputusersSetInput? $_set,
    InputusersBoolExp? where,
  }) =>
      _res;
  CopyWith$InputusersAppendInput<TRes> get $_append =>
      CopyWith$InputusersAppendInput.stub(_res);
  CopyWith$InputusersDeleteAtPathInput<TRes> get $_deleteAtPath =>
      CopyWith$InputusersDeleteAtPathInput.stub(_res);
  CopyWith$InputusersDeleteElemInput<TRes> get $_deleteElem =>
      CopyWith$InputusersDeleteElemInput.stub(_res);
  CopyWith$InputusersDeleteKeyInput<TRes> get $_deleteKey =>
      CopyWith$InputusersDeleteKeyInput.stub(_res);
  CopyWith$InputusersPrependInput<TRes> get $_prepend =>
      CopyWith$InputusersPrependInput.stub(_res);
  CopyWith$InputusersSetInput<TRes> get $_set =>
      CopyWith$InputusersSetInput.stub(_res);
  CopyWith$InputusersBoolExp<TRes> get where =>
      CopyWith$InputusersBoolExp.stub(_res);
}

class Inputusers_max_order_by {
  factory Inputusers_max_order_by({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  }) =>
      Inputusers_max_order_by._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (id != null) r'id': id,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Inputusers_max_order_by._(this._$data);

  factory Inputusers_max_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = l$activeMfaType == null
          ? null
          : fromJson$EnumOrderBy((l$activeMfaType as String));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : fromJson$EnumOrderBy((l$avatarUrl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : fromJson$EnumOrderBy((l$currentChallenge as String));
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = l$defaultRole == null
          ? null
          : fromJson$EnumOrderBy((l$defaultRole as String));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : fromJson$EnumOrderBy((l$displayName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] =
          l$email == null ? null : fromJson$EnumOrderBy((l$email as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromJson$EnumOrderBy((l$lastSeen as String));
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] =
          l$locale == null ? null : fromJson$EnumOrderBy((l$locale as String));
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = l$newEmail == null
          ? null
          : fromJson$EnumOrderBy((l$newEmail as String));
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = l$otpHash == null
          ? null
          : fromJson$EnumOrderBy((l$otpHash as String));
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$otpHashExpiresAt as String));
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : fromJson$EnumOrderBy((l$otpMethodLastUsed as String));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : fromJson$EnumOrderBy((l$passwordHash as String));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : fromJson$EnumOrderBy((l$phoneNumber as String));
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] =
          l$ticket == null ? null : fromJson$EnumOrderBy((l$ticket as String));
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$ticketExpiresAt as String));
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = l$totpSecret == null
          ? null
          : fromJson$EnumOrderBy((l$totpSecret as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    return Inputusers_max_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get activeMfaType => (_$data['activeMfaType'] as EnumOrderBy?);
  EnumOrderBy? get avatarUrl => (_$data['avatarUrl'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get currentChallenge =>
      (_$data['currentChallenge'] as EnumOrderBy?);
  EnumOrderBy? get defaultRole => (_$data['defaultRole'] as EnumOrderBy?);
  EnumOrderBy? get displayName => (_$data['displayName'] as EnumOrderBy?);
  EnumOrderBy? get email => (_$data['email'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get lastSeen => (_$data['lastSeen'] as EnumOrderBy?);
  EnumOrderBy? get locale => (_$data['locale'] as EnumOrderBy?);
  EnumOrderBy? get newEmail => (_$data['newEmail'] as EnumOrderBy?);
  EnumOrderBy? get otpHash => (_$data['otpHash'] as EnumOrderBy?);
  EnumOrderBy? get otpHashExpiresAt =>
      (_$data['otpHashExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get otpMethodLastUsed =>
      (_$data['otpMethodLastUsed'] as EnumOrderBy?);
  EnumOrderBy? get passwordHash => (_$data['passwordHash'] as EnumOrderBy?);
  EnumOrderBy? get phoneNumber => (_$data['phoneNumber'] as EnumOrderBy?);
  EnumOrderBy? get ticket => (_$data['ticket'] as EnumOrderBy?);
  EnumOrderBy? get ticketExpiresAt =>
      (_$data['ticketExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get totpSecret => (_$data['totpSecret'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] =
          l$activeMfaType == null ? null : toJson$EnumOrderBy(l$activeMfaType);
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] =
          l$avatarUrl == null ? null : toJson$EnumOrderBy(l$avatarUrl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : toJson$EnumOrderBy(l$currentChallenge);
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] =
          l$defaultRole == null ? null : toJson$EnumOrderBy(l$defaultRole);
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] =
          l$displayName == null ? null : toJson$EnumOrderBy(l$displayName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] =
          l$email == null ? null : toJson$EnumOrderBy(l$email);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] =
          l$lastSeen == null ? null : toJson$EnumOrderBy(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] =
          l$locale == null ? null : toJson$EnumOrderBy(l$locale);
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] =
          l$newEmail == null ? null : toJson$EnumOrderBy(l$newEmail);
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] =
          l$otpHash == null ? null : toJson$EnumOrderBy(l$otpHash);
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : toJson$EnumOrderBy(l$otpMethodLastUsed);
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] =
          l$passwordHash == null ? null : toJson$EnumOrderBy(l$passwordHash);
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] =
          l$phoneNumber == null ? null : toJson$EnumOrderBy(l$phoneNumber);
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] =
          l$ticket == null ? null : toJson$EnumOrderBy(l$ticket);
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] =
          l$totpSecret == null ? null : toJson$EnumOrderBy(l$totpSecret);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Inputusers_max_order_by<Inputusers_max_order_by> get copyWith =>
      CopyWith$Inputusers_max_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputusers_max_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$displayName = displayName;
    final l$email = email;
    final l$id = id;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Inputusers_max_order_by<TRes> {
  factory CopyWith$Inputusers_max_order_by(
    Inputusers_max_order_by instance,
    TRes Function(Inputusers_max_order_by) then,
  ) = _CopyWithImpl$Inputusers_max_order_by;

  factory CopyWith$Inputusers_max_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputusers_max_order_by;

  TRes call({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  });
}

class _CopyWithImpl$Inputusers_max_order_by<TRes>
    implements CopyWith$Inputusers_max_order_by<TRes> {
  _CopyWithImpl$Inputusers_max_order_by(
    this._instance,
    this._then,
  );

  final Inputusers_max_order_by _instance;

  final TRes Function(Inputusers_max_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? id = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Inputusers_max_order_by._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as EnumOrderBy?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as EnumOrderBy?),
        if (defaultRole != _undefined)
          'defaultRole': (defaultRole as EnumOrderBy?),
        if (displayName != _undefined)
          'displayName': (displayName as EnumOrderBy?),
        if (email != _undefined) 'email': (email as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as EnumOrderBy?),
        if (locale != _undefined) 'locale': (locale as EnumOrderBy?),
        if (newEmail != _undefined) 'newEmail': (newEmail as EnumOrderBy?),
        if (otpHash != _undefined) 'otpHash': (otpHash as EnumOrderBy?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as EnumOrderBy?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as EnumOrderBy?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as EnumOrderBy?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as EnumOrderBy?),
        if (ticket != _undefined) 'ticket': (ticket as EnumOrderBy?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as EnumOrderBy?),
        if (totpSecret != _undefined)
          'totpSecret': (totpSecret as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputusers_max_order_by<TRes>
    implements CopyWith$Inputusers_max_order_by<TRes> {
  _CopyWithStubImpl$Inputusers_max_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  }) =>
      _res;
}

class Inputusers_min_order_by {
  factory Inputusers_min_order_by({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  }) =>
      Inputusers_min_order_by._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (id != null) r'id': id,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Inputusers_min_order_by._(this._$data);

  factory Inputusers_min_order_by.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = l$activeMfaType == null
          ? null
          : fromJson$EnumOrderBy((l$activeMfaType as String));
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = l$avatarUrl == null
          ? null
          : fromJson$EnumOrderBy((l$avatarUrl as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$EnumOrderBy((l$createdAt as String));
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : fromJson$EnumOrderBy((l$currentChallenge as String));
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = l$defaultRole == null
          ? null
          : fromJson$EnumOrderBy((l$defaultRole as String));
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = l$displayName == null
          ? null
          : fromJson$EnumOrderBy((l$displayName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] =
          l$email == null ? null : fromJson$EnumOrderBy((l$email as String));
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$EnumOrderBy((l$id as String));
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromJson$EnumOrderBy((l$lastSeen as String));
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] =
          l$locale == null ? null : fromJson$EnumOrderBy((l$locale as String));
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = l$newEmail == null
          ? null
          : fromJson$EnumOrderBy((l$newEmail as String));
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = l$otpHash == null
          ? null
          : fromJson$EnumOrderBy((l$otpHash as String));
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$otpHashExpiresAt as String));
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : fromJson$EnumOrderBy((l$otpMethodLastUsed as String));
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = l$passwordHash == null
          ? null
          : fromJson$EnumOrderBy((l$passwordHash as String));
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = l$phoneNumber == null
          ? null
          : fromJson$EnumOrderBy((l$phoneNumber as String));
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] =
          l$ticket == null ? null : fromJson$EnumOrderBy((l$ticket as String));
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromJson$EnumOrderBy((l$ticketExpiresAt as String));
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = l$totpSecret == null
          ? null
          : fromJson$EnumOrderBy((l$totpSecret as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$EnumOrderBy((l$updatedAt as String));
    }
    return Inputusers_min_order_by._(result$data);
  }

  Map<String, dynamic> _$data;

  EnumOrderBy? get activeMfaType => (_$data['activeMfaType'] as EnumOrderBy?);
  EnumOrderBy? get avatarUrl => (_$data['avatarUrl'] as EnumOrderBy?);
  EnumOrderBy? get createdAt => (_$data['createdAt'] as EnumOrderBy?);
  EnumOrderBy? get currentChallenge =>
      (_$data['currentChallenge'] as EnumOrderBy?);
  EnumOrderBy? get defaultRole => (_$data['defaultRole'] as EnumOrderBy?);
  EnumOrderBy? get displayName => (_$data['displayName'] as EnumOrderBy?);
  EnumOrderBy? get email => (_$data['email'] as EnumOrderBy?);
  EnumOrderBy? get id => (_$data['id'] as EnumOrderBy?);
  EnumOrderBy? get lastSeen => (_$data['lastSeen'] as EnumOrderBy?);
  EnumOrderBy? get locale => (_$data['locale'] as EnumOrderBy?);
  EnumOrderBy? get newEmail => (_$data['newEmail'] as EnumOrderBy?);
  EnumOrderBy? get otpHash => (_$data['otpHash'] as EnumOrderBy?);
  EnumOrderBy? get otpHashExpiresAt =>
      (_$data['otpHashExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get otpMethodLastUsed =>
      (_$data['otpMethodLastUsed'] as EnumOrderBy?);
  EnumOrderBy? get passwordHash => (_$data['passwordHash'] as EnumOrderBy?);
  EnumOrderBy? get phoneNumber => (_$data['phoneNumber'] as EnumOrderBy?);
  EnumOrderBy? get ticket => (_$data['ticket'] as EnumOrderBy?);
  EnumOrderBy? get ticketExpiresAt =>
      (_$data['ticketExpiresAt'] as EnumOrderBy?);
  EnumOrderBy? get totpSecret => (_$data['totpSecret'] as EnumOrderBy?);
  EnumOrderBy? get updatedAt => (_$data['updatedAt'] as EnumOrderBy?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] =
          l$activeMfaType == null ? null : toJson$EnumOrderBy(l$activeMfaType);
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] =
          l$avatarUrl == null ? null : toJson$EnumOrderBy(l$avatarUrl);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$EnumOrderBy(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge == null
          ? null
          : toJson$EnumOrderBy(l$currentChallenge);
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] =
          l$defaultRole == null ? null : toJson$EnumOrderBy(l$defaultRole);
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] =
          l$displayName == null ? null : toJson$EnumOrderBy(l$displayName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] =
          l$email == null ? null : toJson$EnumOrderBy(l$email);
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$EnumOrderBy(l$id);
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] =
          l$lastSeen == null ? null : toJson$EnumOrderBy(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] =
          l$locale == null ? null : toJson$EnumOrderBy(l$locale);
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] =
          l$newEmail == null ? null : toJson$EnumOrderBy(l$newEmail);
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] =
          l$otpHash == null ? null : toJson$EnumOrderBy(l$otpHash);
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed == null
          ? null
          : toJson$EnumOrderBy(l$otpMethodLastUsed);
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] =
          l$passwordHash == null ? null : toJson$EnumOrderBy(l$passwordHash);
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] =
          l$phoneNumber == null ? null : toJson$EnumOrderBy(l$phoneNumber);
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] =
          l$ticket == null ? null : toJson$EnumOrderBy(l$ticket);
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : toJson$EnumOrderBy(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] =
          l$totpSecret == null ? null : toJson$EnumOrderBy(l$totpSecret);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$EnumOrderBy(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Inputusers_min_order_by<Inputusers_min_order_by> get copyWith =>
      CopyWith$Inputusers_min_order_by(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputusers_min_order_by) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$displayName = displayName;
    final l$email = email;
    final l$id = id;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Inputusers_min_order_by<TRes> {
  factory CopyWith$Inputusers_min_order_by(
    Inputusers_min_order_by instance,
    TRes Function(Inputusers_min_order_by) then,
  ) = _CopyWithImpl$Inputusers_min_order_by;

  factory CopyWith$Inputusers_min_order_by.stub(TRes res) =
      _CopyWithStubImpl$Inputusers_min_order_by;

  TRes call({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  });
}

class _CopyWithImpl$Inputusers_min_order_by<TRes>
    implements CopyWith$Inputusers_min_order_by<TRes> {
  _CopyWithImpl$Inputusers_min_order_by(
    this._instance,
    this._then,
  );

  final Inputusers_min_order_by _instance;

  final TRes Function(Inputusers_min_order_by) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? id = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Inputusers_min_order_by._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as EnumOrderBy?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as EnumOrderBy?),
        if (createdAt != _undefined) 'createdAt': (createdAt as EnumOrderBy?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as EnumOrderBy?),
        if (defaultRole != _undefined)
          'defaultRole': (defaultRole as EnumOrderBy?),
        if (displayName != _undefined)
          'displayName': (displayName as EnumOrderBy?),
        if (email != _undefined) 'email': (email as EnumOrderBy?),
        if (id != _undefined) 'id': (id as EnumOrderBy?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as EnumOrderBy?),
        if (locale != _undefined) 'locale': (locale as EnumOrderBy?),
        if (newEmail != _undefined) 'newEmail': (newEmail as EnumOrderBy?),
        if (otpHash != _undefined) 'otpHash': (otpHash as EnumOrderBy?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as EnumOrderBy?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as EnumOrderBy?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as EnumOrderBy?),
        if (phoneNumber != _undefined)
          'phoneNumber': (phoneNumber as EnumOrderBy?),
        if (ticket != _undefined) 'ticket': (ticket as EnumOrderBy?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as EnumOrderBy?),
        if (totpSecret != _undefined)
          'totpSecret': (totpSecret as EnumOrderBy?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as EnumOrderBy?),
      }));
}

class _CopyWithStubImpl$Inputusers_min_order_by<TRes>
    implements CopyWith$Inputusers_min_order_by<TRes> {
  _CopyWithStubImpl$Inputusers_min_order_by(this._res);

  TRes _res;

  call({
    EnumOrderBy? activeMfaType,
    EnumOrderBy? avatarUrl,
    EnumOrderBy? createdAt,
    EnumOrderBy? currentChallenge,
    EnumOrderBy? defaultRole,
    EnumOrderBy? displayName,
    EnumOrderBy? email,
    EnumOrderBy? id,
    EnumOrderBy? lastSeen,
    EnumOrderBy? locale,
    EnumOrderBy? newEmail,
    EnumOrderBy? otpHash,
    EnumOrderBy? otpHashExpiresAt,
    EnumOrderBy? otpMethodLastUsed,
    EnumOrderBy? passwordHash,
    EnumOrderBy? phoneNumber,
    EnumOrderBy? ticket,
    EnumOrderBy? ticketExpiresAt,
    EnumOrderBy? totpSecret,
    EnumOrderBy? updatedAt,
  }) =>
      _res;
}

class Inputusers_streamCursorInput {
  factory Inputusers_streamCursorInput({
    required Inputusers_streamCursorValueInput initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      Inputusers_streamCursorInput._({
        r'initialValue': initialValue,
        if (ordering != null) r'ordering': ordering,
      });

  Inputusers_streamCursorInput._(this._$data);

  factory Inputusers_streamCursorInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$initialValue = data['initialValue'];
    result$data['initialValue'] = Inputusers_streamCursorValueInput.fromJson(
        (l$initialValue as Map<String, dynamic>));
    if (data.containsKey('ordering')) {
      final l$ordering = data['ordering'];
      result$data['ordering'] = l$ordering == null
          ? null
          : fromJson$EnumCursorOrdering((l$ordering as String));
    }
    return Inputusers_streamCursorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Inputusers_streamCursorValueInput get initialValue =>
      (_$data['initialValue'] as Inputusers_streamCursorValueInput);
  EnumCursorOrdering? get ordering =>
      (_$data['ordering'] as EnumCursorOrdering?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$initialValue = initialValue;
    result$data['initialValue'] = l$initialValue.toJson();
    if (_$data.containsKey('ordering')) {
      final l$ordering = ordering;
      result$data['ordering'] =
          l$ordering == null ? null : toJson$EnumCursorOrdering(l$ordering);
    }
    return result$data;
  }

  CopyWith$Inputusers_streamCursorInput<Inputusers_streamCursorInput>
      get copyWith => CopyWith$Inputusers_streamCursorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputusers_streamCursorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$initialValue = initialValue;
    final lOther$initialValue = other.initialValue;
    if (l$initialValue != lOther$initialValue) {
      return false;
    }
    final l$ordering = ordering;
    final lOther$ordering = other.ordering;
    if (_$data.containsKey('ordering') !=
        other._$data.containsKey('ordering')) {
      return false;
    }
    if (l$ordering != lOther$ordering) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$initialValue = initialValue;
    final l$ordering = ordering;
    return Object.hashAll([
      l$initialValue,
      _$data.containsKey('ordering') ? l$ordering : const {},
    ]);
  }
}

abstract class CopyWith$Inputusers_streamCursorInput<TRes> {
  factory CopyWith$Inputusers_streamCursorInput(
    Inputusers_streamCursorInput instance,
    TRes Function(Inputusers_streamCursorInput) then,
  ) = _CopyWithImpl$Inputusers_streamCursorInput;

  factory CopyWith$Inputusers_streamCursorInput.stub(TRes res) =
      _CopyWithStubImpl$Inputusers_streamCursorInput;

  TRes call({
    Inputusers_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  });
  CopyWith$Inputusers_streamCursorValueInput<TRes> get initialValue;
}

class _CopyWithImpl$Inputusers_streamCursorInput<TRes>
    implements CopyWith$Inputusers_streamCursorInput<TRes> {
  _CopyWithImpl$Inputusers_streamCursorInput(
    this._instance,
    this._then,
  );

  final Inputusers_streamCursorInput _instance;

  final TRes Function(Inputusers_streamCursorInput) _then;

  static const _undefined = {};

  TRes call({
    Object? initialValue = _undefined,
    Object? ordering = _undefined,
  }) =>
      _then(Inputusers_streamCursorInput._({
        ..._instance._$data,
        if (initialValue != _undefined && initialValue != null)
          'initialValue': (initialValue as Inputusers_streamCursorValueInput),
        if (ordering != _undefined)
          'ordering': (ordering as EnumCursorOrdering?),
      }));
  CopyWith$Inputusers_streamCursorValueInput<TRes> get initialValue {
    final local$initialValue = _instance.initialValue;
    return CopyWith$Inputusers_streamCursorValueInput(
        local$initialValue, (e) => call(initialValue: e));
  }
}

class _CopyWithStubImpl$Inputusers_streamCursorInput<TRes>
    implements CopyWith$Inputusers_streamCursorInput<TRes> {
  _CopyWithStubImpl$Inputusers_streamCursorInput(this._res);

  TRes _res;

  call({
    Inputusers_streamCursorValueInput? initialValue,
    EnumCursorOrdering? ordering,
  }) =>
      _res;
  CopyWith$Inputusers_streamCursorValueInput<TRes> get initialValue =>
      CopyWith$Inputusers_streamCursorValueInput.stub(_res);
}

class Inputusers_streamCursorValueInput {
  factory Inputusers_streamCursorValueInput({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  }) =>
      Inputusers_streamCursorValueInput._({
        if (activeMfaType != null) r'activeMfaType': activeMfaType,
        if (avatarUrl != null) r'avatarUrl': avatarUrl,
        if (createdAt != null) r'createdAt': createdAt,
        if (currentChallenge != null) r'currentChallenge': currentChallenge,
        if (defaultRole != null) r'defaultRole': defaultRole,
        if (disabled != null) r'disabled': disabled,
        if (displayName != null) r'displayName': displayName,
        if (email != null) r'email': email,
        if (emailVerified != null) r'emailVerified': emailVerified,
        if (id != null) r'id': id,
        if (isAnonymous != null) r'isAnonymous': isAnonymous,
        if (lastSeen != null) r'lastSeen': lastSeen,
        if (locale != null) r'locale': locale,
        if (metadata != null) r'metadata': metadata,
        if (newEmail != null) r'newEmail': newEmail,
        if (otpHash != null) r'otpHash': otpHash,
        if (otpHashExpiresAt != null) r'otpHashExpiresAt': otpHashExpiresAt,
        if (otpMethodLastUsed != null) r'otpMethodLastUsed': otpMethodLastUsed,
        if (passwordHash != null) r'passwordHash': passwordHash,
        if (phoneNumber != null) r'phoneNumber': phoneNumber,
        if (phoneNumberVerified != null)
          r'phoneNumberVerified': phoneNumberVerified,
        if (ticket != null) r'ticket': ticket,
        if (ticketExpiresAt != null) r'ticketExpiresAt': ticketExpiresAt,
        if (totpSecret != null) r'totpSecret': totpSecret,
        if (updatedAt != null) r'updatedAt': updatedAt,
      });

  Inputusers_streamCursorValueInput._(this._$data);

  factory Inputusers_streamCursorValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('activeMfaType')) {
      final l$activeMfaType = data['activeMfaType'];
      result$data['activeMfaType'] = (l$activeMfaType as String?);
    }
    if (data.containsKey('avatarUrl')) {
      final l$avatarUrl = data['avatarUrl'];
      result$data['avatarUrl'] = (l$avatarUrl as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$createdAt);
    }
    if (data.containsKey('currentChallenge')) {
      final l$currentChallenge = data['currentChallenge'];
      result$data['currentChallenge'] = (l$currentChallenge as String?);
    }
    if (data.containsKey('defaultRole')) {
      final l$defaultRole = data['defaultRole'];
      result$data['defaultRole'] = (l$defaultRole as String?);
    }
    if (data.containsKey('disabled')) {
      final l$disabled = data['disabled'];
      result$data['disabled'] = (l$disabled as bool?);
    }
    if (data.containsKey('displayName')) {
      final l$displayName = data['displayName'];
      result$data['displayName'] = (l$displayName as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('emailVerified')) {
      final l$emailVerified = data['emailVerified'];
      result$data['emailVerified'] = (l$emailVerified as bool?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('isAnonymous')) {
      final l$isAnonymous = data['isAnonymous'];
      result$data['isAnonymous'] = (l$isAnonymous as bool?);
    }
    if (data.containsKey('lastSeen')) {
      final l$lastSeen = data['lastSeen'];
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$lastSeen);
    }
    if (data.containsKey('locale')) {
      final l$locale = data['locale'];
      result$data['locale'] = (l$locale as String?);
    }
    if (data.containsKey('metadata')) {
      final l$metadata = data['metadata'];
      result$data['metadata'] = (l$metadata as Map<String, dynamic>?);
    }
    if (data.containsKey('newEmail')) {
      final l$newEmail = data['newEmail'];
      result$data['newEmail'] = (l$newEmail as String?);
    }
    if (data.containsKey('otpHash')) {
      final l$otpHash = data['otpHash'];
      result$data['otpHash'] = (l$otpHash as String?);
    }
    if (data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = data['otpHashExpiresAt'];
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$otpHashExpiresAt);
    }
    if (data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = data['otpMethodLastUsed'];
      result$data['otpMethodLastUsed'] = (l$otpMethodLastUsed as String?);
    }
    if (data.containsKey('passwordHash')) {
      final l$passwordHash = data['passwordHash'];
      result$data['passwordHash'] = (l$passwordHash as String?);
    }
    if (data.containsKey('phoneNumber')) {
      final l$phoneNumber = data['phoneNumber'];
      result$data['phoneNumber'] = (l$phoneNumber as String?);
    }
    if (data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = data['phoneNumberVerified'];
      result$data['phoneNumberVerified'] = (l$phoneNumberVerified as bool?);
    }
    if (data.containsKey('ticket')) {
      final l$ticket = data['ticket'];
      result$data['ticket'] = (l$ticket as String?);
    }
    if (data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = data['ticketExpiresAt'];
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$ticketExpiresAt);
    }
    if (data.containsKey('totpSecret')) {
      final l$totpSecret = data['totpSecret'];
      result$data['totpSecret'] = (l$totpSecret as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromGraphQLTimestamptzToDartDateTime(l$updatedAt);
    }
    return Inputusers_streamCursorValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get activeMfaType => (_$data['activeMfaType'] as String?);
  String? get avatarUrl => (_$data['avatarUrl'] as String?);
  DateTime? get createdAt => (_$data['createdAt'] as DateTime?);
  String? get currentChallenge => (_$data['currentChallenge'] as String?);
  String? get defaultRole => (_$data['defaultRole'] as String?);
  bool? get disabled => (_$data['disabled'] as bool?);
  String? get displayName => (_$data['displayName'] as String?);
  String? get email => (_$data['email'] as String?);
  bool? get emailVerified => (_$data['emailVerified'] as bool?);
  String? get id => (_$data['id'] as String?);
  bool? get isAnonymous => (_$data['isAnonymous'] as bool?);
  DateTime? get lastSeen => (_$data['lastSeen'] as DateTime?);
  String? get locale => (_$data['locale'] as String?);
  Map<String, dynamic>? get metadata =>
      (_$data['metadata'] as Map<String, dynamic>?);
  String? get newEmail => (_$data['newEmail'] as String?);
  String? get otpHash => (_$data['otpHash'] as String?);
  DateTime? get otpHashExpiresAt => (_$data['otpHashExpiresAt'] as DateTime?);
  String? get otpMethodLastUsed => (_$data['otpMethodLastUsed'] as String?);
  String? get passwordHash => (_$data['passwordHash'] as String?);
  String? get phoneNumber => (_$data['phoneNumber'] as String?);
  bool? get phoneNumberVerified => (_$data['phoneNumberVerified'] as bool?);
  String? get ticket => (_$data['ticket'] as String?);
  DateTime? get ticketExpiresAt => (_$data['ticketExpiresAt'] as DateTime?);
  String? get totpSecret => (_$data['totpSecret'] as String?);
  DateTime? get updatedAt => (_$data['updatedAt'] as DateTime?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('activeMfaType')) {
      final l$activeMfaType = activeMfaType;
      result$data['activeMfaType'] = l$activeMfaType;
    }
    if (_$data.containsKey('avatarUrl')) {
      final l$avatarUrl = avatarUrl;
      result$data['avatarUrl'] = l$avatarUrl;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$createdAt);
    }
    if (_$data.containsKey('currentChallenge')) {
      final l$currentChallenge = currentChallenge;
      result$data['currentChallenge'] = l$currentChallenge;
    }
    if (_$data.containsKey('defaultRole')) {
      final l$defaultRole = defaultRole;
      result$data['defaultRole'] = l$defaultRole;
    }
    if (_$data.containsKey('disabled')) {
      final l$disabled = disabled;
      result$data['disabled'] = l$disabled;
    }
    if (_$data.containsKey('displayName')) {
      final l$displayName = displayName;
      result$data['displayName'] = l$displayName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('emailVerified')) {
      final l$emailVerified = emailVerified;
      result$data['emailVerified'] = l$emailVerified;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('isAnonymous')) {
      final l$isAnonymous = isAnonymous;
      result$data['isAnonymous'] = l$isAnonymous;
    }
    if (_$data.containsKey('lastSeen')) {
      final l$lastSeen = lastSeen;
      result$data['lastSeen'] = l$lastSeen == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$lastSeen);
    }
    if (_$data.containsKey('locale')) {
      final l$locale = locale;
      result$data['locale'] = l$locale;
    }
    if (_$data.containsKey('metadata')) {
      final l$metadata = metadata;
      result$data['metadata'] = l$metadata;
    }
    if (_$data.containsKey('newEmail')) {
      final l$newEmail = newEmail;
      result$data['newEmail'] = l$newEmail;
    }
    if (_$data.containsKey('otpHash')) {
      final l$otpHash = otpHash;
      result$data['otpHash'] = l$otpHash;
    }
    if (_$data.containsKey('otpHashExpiresAt')) {
      final l$otpHashExpiresAt = otpHashExpiresAt;
      result$data['otpHashExpiresAt'] = l$otpHashExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$otpHashExpiresAt);
    }
    if (_$data.containsKey('otpMethodLastUsed')) {
      final l$otpMethodLastUsed = otpMethodLastUsed;
      result$data['otpMethodLastUsed'] = l$otpMethodLastUsed;
    }
    if (_$data.containsKey('passwordHash')) {
      final l$passwordHash = passwordHash;
      result$data['passwordHash'] = l$passwordHash;
    }
    if (_$data.containsKey('phoneNumber')) {
      final l$phoneNumber = phoneNumber;
      result$data['phoneNumber'] = l$phoneNumber;
    }
    if (_$data.containsKey('phoneNumberVerified')) {
      final l$phoneNumberVerified = phoneNumberVerified;
      result$data['phoneNumberVerified'] = l$phoneNumberVerified;
    }
    if (_$data.containsKey('ticket')) {
      final l$ticket = ticket;
      result$data['ticket'] = l$ticket;
    }
    if (_$data.containsKey('ticketExpiresAt')) {
      final l$ticketExpiresAt = ticketExpiresAt;
      result$data['ticketExpiresAt'] = l$ticketExpiresAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$ticketExpiresAt);
    }
    if (_$data.containsKey('totpSecret')) {
      final l$totpSecret = totpSecret;
      result$data['totpSecret'] = l$totpSecret;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromDartDateTimeToGraphQLTimestamptz(l$updatedAt);
    }
    return result$data;
  }

  CopyWith$Inputusers_streamCursorValueInput<Inputusers_streamCursorValueInput>
      get copyWith => CopyWith$Inputusers_streamCursorValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Inputusers_streamCursorValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$activeMfaType = activeMfaType;
    final lOther$activeMfaType = other.activeMfaType;
    if (_$data.containsKey('activeMfaType') !=
        other._$data.containsKey('activeMfaType')) {
      return false;
    }
    if (l$activeMfaType != lOther$activeMfaType) {
      return false;
    }
    final l$avatarUrl = avatarUrl;
    final lOther$avatarUrl = other.avatarUrl;
    if (_$data.containsKey('avatarUrl') !=
        other._$data.containsKey('avatarUrl')) {
      return false;
    }
    if (l$avatarUrl != lOther$avatarUrl) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$currentChallenge = currentChallenge;
    final lOther$currentChallenge = other.currentChallenge;
    if (_$data.containsKey('currentChallenge') !=
        other._$data.containsKey('currentChallenge')) {
      return false;
    }
    if (l$currentChallenge != lOther$currentChallenge) {
      return false;
    }
    final l$defaultRole = defaultRole;
    final lOther$defaultRole = other.defaultRole;
    if (_$data.containsKey('defaultRole') !=
        other._$data.containsKey('defaultRole')) {
      return false;
    }
    if (l$defaultRole != lOther$defaultRole) {
      return false;
    }
    final l$disabled = disabled;
    final lOther$disabled = other.disabled;
    if (_$data.containsKey('disabled') !=
        other._$data.containsKey('disabled')) {
      return false;
    }
    if (l$disabled != lOther$disabled) {
      return false;
    }
    final l$displayName = displayName;
    final lOther$displayName = other.displayName;
    if (_$data.containsKey('displayName') !=
        other._$data.containsKey('displayName')) {
      return false;
    }
    if (l$displayName != lOther$displayName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$emailVerified = emailVerified;
    final lOther$emailVerified = other.emailVerified;
    if (_$data.containsKey('emailVerified') !=
        other._$data.containsKey('emailVerified')) {
      return false;
    }
    if (l$emailVerified != lOther$emailVerified) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$isAnonymous = isAnonymous;
    final lOther$isAnonymous = other.isAnonymous;
    if (_$data.containsKey('isAnonymous') !=
        other._$data.containsKey('isAnonymous')) {
      return false;
    }
    if (l$isAnonymous != lOther$isAnonymous) {
      return false;
    }
    final l$lastSeen = lastSeen;
    final lOther$lastSeen = other.lastSeen;
    if (_$data.containsKey('lastSeen') !=
        other._$data.containsKey('lastSeen')) {
      return false;
    }
    if (l$lastSeen != lOther$lastSeen) {
      return false;
    }
    final l$locale = locale;
    final lOther$locale = other.locale;
    if (_$data.containsKey('locale') != other._$data.containsKey('locale')) {
      return false;
    }
    if (l$locale != lOther$locale) {
      return false;
    }
    final l$metadata = metadata;
    final lOther$metadata = other.metadata;
    if (_$data.containsKey('metadata') !=
        other._$data.containsKey('metadata')) {
      return false;
    }
    if (l$metadata != lOther$metadata) {
      return false;
    }
    final l$newEmail = newEmail;
    final lOther$newEmail = other.newEmail;
    if (_$data.containsKey('newEmail') !=
        other._$data.containsKey('newEmail')) {
      return false;
    }
    if (l$newEmail != lOther$newEmail) {
      return false;
    }
    final l$otpHash = otpHash;
    final lOther$otpHash = other.otpHash;
    if (_$data.containsKey('otpHash') != other._$data.containsKey('otpHash')) {
      return false;
    }
    if (l$otpHash != lOther$otpHash) {
      return false;
    }
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final lOther$otpHashExpiresAt = other.otpHashExpiresAt;
    if (_$data.containsKey('otpHashExpiresAt') !=
        other._$data.containsKey('otpHashExpiresAt')) {
      return false;
    }
    if (l$otpHashExpiresAt != lOther$otpHashExpiresAt) {
      return false;
    }
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final lOther$otpMethodLastUsed = other.otpMethodLastUsed;
    if (_$data.containsKey('otpMethodLastUsed') !=
        other._$data.containsKey('otpMethodLastUsed')) {
      return false;
    }
    if (l$otpMethodLastUsed != lOther$otpMethodLastUsed) {
      return false;
    }
    final l$passwordHash = passwordHash;
    final lOther$passwordHash = other.passwordHash;
    if (_$data.containsKey('passwordHash') !=
        other._$data.containsKey('passwordHash')) {
      return false;
    }
    if (l$passwordHash != lOther$passwordHash) {
      return false;
    }
    final l$phoneNumber = phoneNumber;
    final lOther$phoneNumber = other.phoneNumber;
    if (_$data.containsKey('phoneNumber') !=
        other._$data.containsKey('phoneNumber')) {
      return false;
    }
    if (l$phoneNumber != lOther$phoneNumber) {
      return false;
    }
    final l$phoneNumberVerified = phoneNumberVerified;
    final lOther$phoneNumberVerified = other.phoneNumberVerified;
    if (_$data.containsKey('phoneNumberVerified') !=
        other._$data.containsKey('phoneNumberVerified')) {
      return false;
    }
    if (l$phoneNumberVerified != lOther$phoneNumberVerified) {
      return false;
    }
    final l$ticket = ticket;
    final lOther$ticket = other.ticket;
    if (_$data.containsKey('ticket') != other._$data.containsKey('ticket')) {
      return false;
    }
    if (l$ticket != lOther$ticket) {
      return false;
    }
    final l$ticketExpiresAt = ticketExpiresAt;
    final lOther$ticketExpiresAt = other.ticketExpiresAt;
    if (_$data.containsKey('ticketExpiresAt') !=
        other._$data.containsKey('ticketExpiresAt')) {
      return false;
    }
    if (l$ticketExpiresAt != lOther$ticketExpiresAt) {
      return false;
    }
    final l$totpSecret = totpSecret;
    final lOther$totpSecret = other.totpSecret;
    if (_$data.containsKey('totpSecret') !=
        other._$data.containsKey('totpSecret')) {
      return false;
    }
    if (l$totpSecret != lOther$totpSecret) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$activeMfaType = activeMfaType;
    final l$avatarUrl = avatarUrl;
    final l$createdAt = createdAt;
    final l$currentChallenge = currentChallenge;
    final l$defaultRole = defaultRole;
    final l$disabled = disabled;
    final l$displayName = displayName;
    final l$email = email;
    final l$emailVerified = emailVerified;
    final l$id = id;
    final l$isAnonymous = isAnonymous;
    final l$lastSeen = lastSeen;
    final l$locale = locale;
    final l$metadata = metadata;
    final l$newEmail = newEmail;
    final l$otpHash = otpHash;
    final l$otpHashExpiresAt = otpHashExpiresAt;
    final l$otpMethodLastUsed = otpMethodLastUsed;
    final l$passwordHash = passwordHash;
    final l$phoneNumber = phoneNumber;
    final l$phoneNumberVerified = phoneNumberVerified;
    final l$ticket = ticket;
    final l$ticketExpiresAt = ticketExpiresAt;
    final l$totpSecret = totpSecret;
    final l$updatedAt = updatedAt;
    return Object.hashAll([
      _$data.containsKey('activeMfaType') ? l$activeMfaType : const {},
      _$data.containsKey('avatarUrl') ? l$avatarUrl : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('currentChallenge') ? l$currentChallenge : const {},
      _$data.containsKey('defaultRole') ? l$defaultRole : const {},
      _$data.containsKey('disabled') ? l$disabled : const {},
      _$data.containsKey('displayName') ? l$displayName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('emailVerified') ? l$emailVerified : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('isAnonymous') ? l$isAnonymous : const {},
      _$data.containsKey('lastSeen') ? l$lastSeen : const {},
      _$data.containsKey('locale') ? l$locale : const {},
      _$data.containsKey('metadata') ? l$metadata : const {},
      _$data.containsKey('newEmail') ? l$newEmail : const {},
      _$data.containsKey('otpHash') ? l$otpHash : const {},
      _$data.containsKey('otpHashExpiresAt') ? l$otpHashExpiresAt : const {},
      _$data.containsKey('otpMethodLastUsed') ? l$otpMethodLastUsed : const {},
      _$data.containsKey('passwordHash') ? l$passwordHash : const {},
      _$data.containsKey('phoneNumber') ? l$phoneNumber : const {},
      _$data.containsKey('phoneNumberVerified')
          ? l$phoneNumberVerified
          : const {},
      _$data.containsKey('ticket') ? l$ticket : const {},
      _$data.containsKey('ticketExpiresAt') ? l$ticketExpiresAt : const {},
      _$data.containsKey('totpSecret') ? l$totpSecret : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
    ]);
  }
}

abstract class CopyWith$Inputusers_streamCursorValueInput<TRes> {
  factory CopyWith$Inputusers_streamCursorValueInput(
    Inputusers_streamCursorValueInput instance,
    TRes Function(Inputusers_streamCursorValueInput) then,
  ) = _CopyWithImpl$Inputusers_streamCursorValueInput;

  factory CopyWith$Inputusers_streamCursorValueInput.stub(TRes res) =
      _CopyWithStubImpl$Inputusers_streamCursorValueInput;

  TRes call({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  });
}

class _CopyWithImpl$Inputusers_streamCursorValueInput<TRes>
    implements CopyWith$Inputusers_streamCursorValueInput<TRes> {
  _CopyWithImpl$Inputusers_streamCursorValueInput(
    this._instance,
    this._then,
  );

  final Inputusers_streamCursorValueInput _instance;

  final TRes Function(Inputusers_streamCursorValueInput) _then;

  static const _undefined = {};

  TRes call({
    Object? activeMfaType = _undefined,
    Object? avatarUrl = _undefined,
    Object? createdAt = _undefined,
    Object? currentChallenge = _undefined,
    Object? defaultRole = _undefined,
    Object? disabled = _undefined,
    Object? displayName = _undefined,
    Object? email = _undefined,
    Object? emailVerified = _undefined,
    Object? id = _undefined,
    Object? isAnonymous = _undefined,
    Object? lastSeen = _undefined,
    Object? locale = _undefined,
    Object? metadata = _undefined,
    Object? newEmail = _undefined,
    Object? otpHash = _undefined,
    Object? otpHashExpiresAt = _undefined,
    Object? otpMethodLastUsed = _undefined,
    Object? passwordHash = _undefined,
    Object? phoneNumber = _undefined,
    Object? phoneNumberVerified = _undefined,
    Object? ticket = _undefined,
    Object? ticketExpiresAt = _undefined,
    Object? totpSecret = _undefined,
    Object? updatedAt = _undefined,
  }) =>
      _then(Inputusers_streamCursorValueInput._({
        ..._instance._$data,
        if (activeMfaType != _undefined)
          'activeMfaType': (activeMfaType as String?),
        if (avatarUrl != _undefined) 'avatarUrl': (avatarUrl as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as DateTime?),
        if (currentChallenge != _undefined)
          'currentChallenge': (currentChallenge as String?),
        if (defaultRole != _undefined) 'defaultRole': (defaultRole as String?),
        if (disabled != _undefined) 'disabled': (disabled as bool?),
        if (displayName != _undefined) 'displayName': (displayName as String?),
        if (email != _undefined) 'email': (email as String?),
        if (emailVerified != _undefined)
          'emailVerified': (emailVerified as bool?),
        if (id != _undefined) 'id': (id as String?),
        if (isAnonymous != _undefined) 'isAnonymous': (isAnonymous as bool?),
        if (lastSeen != _undefined) 'lastSeen': (lastSeen as DateTime?),
        if (locale != _undefined) 'locale': (locale as String?),
        if (metadata != _undefined)
          'metadata': (metadata as Map<String, dynamic>?),
        if (newEmail != _undefined) 'newEmail': (newEmail as String?),
        if (otpHash != _undefined) 'otpHash': (otpHash as String?),
        if (otpHashExpiresAt != _undefined)
          'otpHashExpiresAt': (otpHashExpiresAt as DateTime?),
        if (otpMethodLastUsed != _undefined)
          'otpMethodLastUsed': (otpMethodLastUsed as String?),
        if (passwordHash != _undefined)
          'passwordHash': (passwordHash as String?),
        if (phoneNumber != _undefined) 'phoneNumber': (phoneNumber as String?),
        if (phoneNumberVerified != _undefined)
          'phoneNumberVerified': (phoneNumberVerified as bool?),
        if (ticket != _undefined) 'ticket': (ticket as String?),
        if (ticketExpiresAt != _undefined)
          'ticketExpiresAt': (ticketExpiresAt as DateTime?),
        if (totpSecret != _undefined) 'totpSecret': (totpSecret as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as DateTime?),
      }));
}

class _CopyWithStubImpl$Inputusers_streamCursorValueInput<TRes>
    implements CopyWith$Inputusers_streamCursorValueInput<TRes> {
  _CopyWithStubImpl$Inputusers_streamCursorValueInput(this._res);

  TRes _res;

  call({
    String? activeMfaType,
    String? avatarUrl,
    DateTime? createdAt,
    String? currentChallenge,
    String? defaultRole,
    bool? disabled,
    String? displayName,
    String? email,
    bool? emailVerified,
    String? id,
    bool? isAnonymous,
    DateTime? lastSeen,
    String? locale,
    Map<String, dynamic>? metadata,
    String? newEmail,
    String? otpHash,
    DateTime? otpHashExpiresAt,
    String? otpMethodLastUsed,
    String? passwordHash,
    String? phoneNumber,
    bool? phoneNumberVerified,
    String? ticket,
    DateTime? ticketExpiresAt,
    String? totpSecret,
    DateTime? updatedAt,
  }) =>
      _res;
}

enum EnumCursorOrdering { ASC, DESC, $unknown }

String toJson$EnumCursorOrdering(EnumCursorOrdering e) {
  switch (e) {
    case EnumCursorOrdering.ASC:
      return r'ASC';
    case EnumCursorOrdering.DESC:
      return r'DESC';
    case EnumCursorOrdering.$unknown:
      return r'$unknown';
  }
}

EnumCursorOrdering fromJson$EnumCursorOrdering(String value) {
  switch (value) {
    case r'ASC':
      return EnumCursorOrdering.ASC;
    case r'DESC':
      return EnumCursorOrdering.DESC;
    default:
      return EnumCursorOrdering.$unknown;
  }
}

enum EnumOrderBy {
  ASC,
  ASC_NULLS_FIRST,
  ASC_NULLS_LAST,
  DESC,
  DESC_NULLS_FIRST,
  DESC_NULLS_LAST,
  $unknown
}

String toJson$EnumOrderBy(EnumOrderBy e) {
  switch (e) {
    case EnumOrderBy.ASC:
      return r'ASC';
    case EnumOrderBy.ASC_NULLS_FIRST:
      return r'ASC_NULLS_FIRST';
    case EnumOrderBy.ASC_NULLS_LAST:
      return r'ASC_NULLS_LAST';
    case EnumOrderBy.DESC:
      return r'DESC';
    case EnumOrderBy.DESC_NULLS_FIRST:
      return r'DESC_NULLS_FIRST';
    case EnumOrderBy.DESC_NULLS_LAST:
      return r'DESC_NULLS_LAST';
    case EnumOrderBy.$unknown:
      return r'$unknown';
  }
}

EnumOrderBy fromJson$EnumOrderBy(String value) {
  switch (value) {
    case r'ASC':
      return EnumOrderBy.ASC;
    case r'ASC_NULLS_FIRST':
      return EnumOrderBy.ASC_NULLS_FIRST;
    case r'ASC_NULLS_LAST':
      return EnumOrderBy.ASC_NULLS_LAST;
    case r'DESC':
      return EnumOrderBy.DESC;
    case r'DESC_NULLS_FIRST':
      return EnumOrderBy.DESC_NULLS_FIRST;
    case r'DESC_NULLS_LAST':
      return EnumOrderBy.DESC_NULLS_LAST;
    default:
      return EnumOrderBy.$unknown;
  }
}

enum EnumauthProviderRequestsConstraint { provider_requests_pkey, $unknown }

String toJson$EnumauthProviderRequestsConstraint(
    EnumauthProviderRequestsConstraint e) {
  switch (e) {
    case EnumauthProviderRequestsConstraint.provider_requests_pkey:
      return r'provider_requests_pkey';
    case EnumauthProviderRequestsConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthProviderRequestsConstraint fromJson$EnumauthProviderRequestsConstraint(
    String value) {
  switch (value) {
    case r'provider_requests_pkey':
      return EnumauthProviderRequestsConstraint.provider_requests_pkey;
    default:
      return EnumauthProviderRequestsConstraint.$unknown;
  }
}

enum EnumauthProviderRequestsSelectColumn { id, options, $unknown }

String toJson$EnumauthProviderRequestsSelectColumn(
    EnumauthProviderRequestsSelectColumn e) {
  switch (e) {
    case EnumauthProviderRequestsSelectColumn.id:
      return r'id';
    case EnumauthProviderRequestsSelectColumn.options:
      return r'options';
    case EnumauthProviderRequestsSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthProviderRequestsSelectColumn
    fromJson$EnumauthProviderRequestsSelectColumn(String value) {
  switch (value) {
    case r'id':
      return EnumauthProviderRequestsSelectColumn.id;
    case r'options':
      return EnumauthProviderRequestsSelectColumn.options;
    default:
      return EnumauthProviderRequestsSelectColumn.$unknown;
  }
}

enum EnumauthProviderRequestsUpdateColumn { id, options, $unknown }

String toJson$EnumauthProviderRequestsUpdateColumn(
    EnumauthProviderRequestsUpdateColumn e) {
  switch (e) {
    case EnumauthProviderRequestsUpdateColumn.id:
      return r'id';
    case EnumauthProviderRequestsUpdateColumn.options:
      return r'options';
    case EnumauthProviderRequestsUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthProviderRequestsUpdateColumn
    fromJson$EnumauthProviderRequestsUpdateColumn(String value) {
  switch (value) {
    case r'id':
      return EnumauthProviderRequestsUpdateColumn.id;
    case r'options':
      return EnumauthProviderRequestsUpdateColumn.options;
    default:
      return EnumauthProviderRequestsUpdateColumn.$unknown;
  }
}

enum EnumauthProvidersConstraint { providers_pkey, $unknown }

String toJson$EnumauthProvidersConstraint(EnumauthProvidersConstraint e) {
  switch (e) {
    case EnumauthProvidersConstraint.providers_pkey:
      return r'providers_pkey';
    case EnumauthProvidersConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthProvidersConstraint fromJson$EnumauthProvidersConstraint(String value) {
  switch (value) {
    case r'providers_pkey':
      return EnumauthProvidersConstraint.providers_pkey;
    default:
      return EnumauthProvidersConstraint.$unknown;
  }
}

enum EnumauthProvidersSelectColumn { id, $unknown }

String toJson$EnumauthProvidersSelectColumn(EnumauthProvidersSelectColumn e) {
  switch (e) {
    case EnumauthProvidersSelectColumn.id:
      return r'id';
    case EnumauthProvidersSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthProvidersSelectColumn fromJson$EnumauthProvidersSelectColumn(
    String value) {
  switch (value) {
    case r'id':
      return EnumauthProvidersSelectColumn.id;
    default:
      return EnumauthProvidersSelectColumn.$unknown;
  }
}

enum EnumauthProvidersUpdateColumn { id, $unknown }

String toJson$EnumauthProvidersUpdateColumn(EnumauthProvidersUpdateColumn e) {
  switch (e) {
    case EnumauthProvidersUpdateColumn.id:
      return r'id';
    case EnumauthProvidersUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthProvidersUpdateColumn fromJson$EnumauthProvidersUpdateColumn(
    String value) {
  switch (value) {
    case r'id':
      return EnumauthProvidersUpdateColumn.id;
    default:
      return EnumauthProvidersUpdateColumn.$unknown;
  }
}

enum EnumauthRefreshTokensConstraint { refresh_tokens_pkey, $unknown }

String toJson$EnumauthRefreshTokensConstraint(
    EnumauthRefreshTokensConstraint e) {
  switch (e) {
    case EnumauthRefreshTokensConstraint.refresh_tokens_pkey:
      return r'refresh_tokens_pkey';
    case EnumauthRefreshTokensConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthRefreshTokensConstraint fromJson$EnumauthRefreshTokensConstraint(
    String value) {
  switch (value) {
    case r'refresh_tokens_pkey':
      return EnumauthRefreshTokensConstraint.refresh_tokens_pkey;
    default:
      return EnumauthRefreshTokensConstraint.$unknown;
  }
}

enum EnumauthRefreshTokensSelectColumn {
  createdAt,
  expiresAt,
  refreshToken,
  userId,
  $unknown
}

String toJson$EnumauthRefreshTokensSelectColumn(
    EnumauthRefreshTokensSelectColumn e) {
  switch (e) {
    case EnumauthRefreshTokensSelectColumn.createdAt:
      return r'createdAt';
    case EnumauthRefreshTokensSelectColumn.expiresAt:
      return r'expiresAt';
    case EnumauthRefreshTokensSelectColumn.refreshToken:
      return r'refreshToken';
    case EnumauthRefreshTokensSelectColumn.userId:
      return r'userId';
    case EnumauthRefreshTokensSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthRefreshTokensSelectColumn fromJson$EnumauthRefreshTokensSelectColumn(
    String value) {
  switch (value) {
    case r'createdAt':
      return EnumauthRefreshTokensSelectColumn.createdAt;
    case r'expiresAt':
      return EnumauthRefreshTokensSelectColumn.expiresAt;
    case r'refreshToken':
      return EnumauthRefreshTokensSelectColumn.refreshToken;
    case r'userId':
      return EnumauthRefreshTokensSelectColumn.userId;
    default:
      return EnumauthRefreshTokensSelectColumn.$unknown;
  }
}

enum EnumauthRefreshTokensUpdateColumn {
  createdAt,
  expiresAt,
  refreshToken,
  userId,
  $unknown
}

String toJson$EnumauthRefreshTokensUpdateColumn(
    EnumauthRefreshTokensUpdateColumn e) {
  switch (e) {
    case EnumauthRefreshTokensUpdateColumn.createdAt:
      return r'createdAt';
    case EnumauthRefreshTokensUpdateColumn.expiresAt:
      return r'expiresAt';
    case EnumauthRefreshTokensUpdateColumn.refreshToken:
      return r'refreshToken';
    case EnumauthRefreshTokensUpdateColumn.userId:
      return r'userId';
    case EnumauthRefreshTokensUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthRefreshTokensUpdateColumn fromJson$EnumauthRefreshTokensUpdateColumn(
    String value) {
  switch (value) {
    case r'createdAt':
      return EnumauthRefreshTokensUpdateColumn.createdAt;
    case r'expiresAt':
      return EnumauthRefreshTokensUpdateColumn.expiresAt;
    case r'refreshToken':
      return EnumauthRefreshTokensUpdateColumn.refreshToken;
    case r'userId':
      return EnumauthRefreshTokensUpdateColumn.userId;
    default:
      return EnumauthRefreshTokensUpdateColumn.$unknown;
  }
}

enum EnumauthRolesConstraint { roles_pkey, $unknown }

String toJson$EnumauthRolesConstraint(EnumauthRolesConstraint e) {
  switch (e) {
    case EnumauthRolesConstraint.roles_pkey:
      return r'roles_pkey';
    case EnumauthRolesConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthRolesConstraint fromJson$EnumauthRolesConstraint(String value) {
  switch (value) {
    case r'roles_pkey':
      return EnumauthRolesConstraint.roles_pkey;
    default:
      return EnumauthRolesConstraint.$unknown;
  }
}

enum EnumauthRolesSelectColumn { role, $unknown }

String toJson$EnumauthRolesSelectColumn(EnumauthRolesSelectColumn e) {
  switch (e) {
    case EnumauthRolesSelectColumn.role:
      return r'role';
    case EnumauthRolesSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthRolesSelectColumn fromJson$EnumauthRolesSelectColumn(String value) {
  switch (value) {
    case r'role':
      return EnumauthRolesSelectColumn.role;
    default:
      return EnumauthRolesSelectColumn.$unknown;
  }
}

enum EnumauthRolesUpdateColumn { role, $unknown }

String toJson$EnumauthRolesUpdateColumn(EnumauthRolesUpdateColumn e) {
  switch (e) {
    case EnumauthRolesUpdateColumn.role:
      return r'role';
    case EnumauthRolesUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthRolesUpdateColumn fromJson$EnumauthRolesUpdateColumn(String value) {
  switch (value) {
    case r'role':
      return EnumauthRolesUpdateColumn.role;
    default:
      return EnumauthRolesUpdateColumn.$unknown;
  }
}

enum EnumauthUserAuthenticatorsConstraint {
  user_authenticators_credential_id_key,
  user_authenticators_pkey,
  $unknown
}

String toJson$EnumauthUserAuthenticatorsConstraint(
    EnumauthUserAuthenticatorsConstraint e) {
  switch (e) {
    case EnumauthUserAuthenticatorsConstraint
        .user_authenticators_credential_id_key:
      return r'user_authenticators_credential_id_key';
    case EnumauthUserAuthenticatorsConstraint.user_authenticators_pkey:
      return r'user_authenticators_pkey';
    case EnumauthUserAuthenticatorsConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthUserAuthenticatorsConstraint
    fromJson$EnumauthUserAuthenticatorsConstraint(String value) {
  switch (value) {
    case r'user_authenticators_credential_id_key':
      return EnumauthUserAuthenticatorsConstraint
          .user_authenticators_credential_id_key;
    case r'user_authenticators_pkey':
      return EnumauthUserAuthenticatorsConstraint.user_authenticators_pkey;
    default:
      return EnumauthUserAuthenticatorsConstraint.$unknown;
  }
}

enum EnumauthUserAuthenticatorsSelectColumn {
  counter,
  credentialId,
  credentialPublicKey,
  id,
  transports,
  userId,
  $unknown
}

String toJson$EnumauthUserAuthenticatorsSelectColumn(
    EnumauthUserAuthenticatorsSelectColumn e) {
  switch (e) {
    case EnumauthUserAuthenticatorsSelectColumn.counter:
      return r'counter';
    case EnumauthUserAuthenticatorsSelectColumn.credentialId:
      return r'credentialId';
    case EnumauthUserAuthenticatorsSelectColumn.credentialPublicKey:
      return r'credentialPublicKey';
    case EnumauthUserAuthenticatorsSelectColumn.id:
      return r'id';
    case EnumauthUserAuthenticatorsSelectColumn.transports:
      return r'transports';
    case EnumauthUserAuthenticatorsSelectColumn.userId:
      return r'userId';
    case EnumauthUserAuthenticatorsSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserAuthenticatorsSelectColumn
    fromJson$EnumauthUserAuthenticatorsSelectColumn(String value) {
  switch (value) {
    case r'counter':
      return EnumauthUserAuthenticatorsSelectColumn.counter;
    case r'credentialId':
      return EnumauthUserAuthenticatorsSelectColumn.credentialId;
    case r'credentialPublicKey':
      return EnumauthUserAuthenticatorsSelectColumn.credentialPublicKey;
    case r'id':
      return EnumauthUserAuthenticatorsSelectColumn.id;
    case r'transports':
      return EnumauthUserAuthenticatorsSelectColumn.transports;
    case r'userId':
      return EnumauthUserAuthenticatorsSelectColumn.userId;
    default:
      return EnumauthUserAuthenticatorsSelectColumn.$unknown;
  }
}

enum EnumauthUserAuthenticatorsUpdateColumn {
  counter,
  credentialId,
  credentialPublicKey,
  id,
  transports,
  userId,
  $unknown
}

String toJson$EnumauthUserAuthenticatorsUpdateColumn(
    EnumauthUserAuthenticatorsUpdateColumn e) {
  switch (e) {
    case EnumauthUserAuthenticatorsUpdateColumn.counter:
      return r'counter';
    case EnumauthUserAuthenticatorsUpdateColumn.credentialId:
      return r'credentialId';
    case EnumauthUserAuthenticatorsUpdateColumn.credentialPublicKey:
      return r'credentialPublicKey';
    case EnumauthUserAuthenticatorsUpdateColumn.id:
      return r'id';
    case EnumauthUserAuthenticatorsUpdateColumn.transports:
      return r'transports';
    case EnumauthUserAuthenticatorsUpdateColumn.userId:
      return r'userId';
    case EnumauthUserAuthenticatorsUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserAuthenticatorsUpdateColumn
    fromJson$EnumauthUserAuthenticatorsUpdateColumn(String value) {
  switch (value) {
    case r'counter':
      return EnumauthUserAuthenticatorsUpdateColumn.counter;
    case r'credentialId':
      return EnumauthUserAuthenticatorsUpdateColumn.credentialId;
    case r'credentialPublicKey':
      return EnumauthUserAuthenticatorsUpdateColumn.credentialPublicKey;
    case r'id':
      return EnumauthUserAuthenticatorsUpdateColumn.id;
    case r'transports':
      return EnumauthUserAuthenticatorsUpdateColumn.transports;
    case r'userId':
      return EnumauthUserAuthenticatorsUpdateColumn.userId;
    default:
      return EnumauthUserAuthenticatorsUpdateColumn.$unknown;
  }
}

enum EnumauthUserProvidersConstraint {
  user_providers_pkey,
  user_providers_provider_id_provider_user_id_key,
  user_providers_user_id_provider_id_key,
  $unknown
}

String toJson$EnumauthUserProvidersConstraint(
    EnumauthUserProvidersConstraint e) {
  switch (e) {
    case EnumauthUserProvidersConstraint.user_providers_pkey:
      return r'user_providers_pkey';
    case EnumauthUserProvidersConstraint
        .user_providers_provider_id_provider_user_id_key:
      return r'user_providers_provider_id_provider_user_id_key';
    case EnumauthUserProvidersConstraint.user_providers_user_id_provider_id_key:
      return r'user_providers_user_id_provider_id_key';
    case EnumauthUserProvidersConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthUserProvidersConstraint fromJson$EnumauthUserProvidersConstraint(
    String value) {
  switch (value) {
    case r'user_providers_pkey':
      return EnumauthUserProvidersConstraint.user_providers_pkey;
    case r'user_providers_provider_id_provider_user_id_key':
      return EnumauthUserProvidersConstraint
          .user_providers_provider_id_provider_user_id_key;
    case r'user_providers_user_id_provider_id_key':
      return EnumauthUserProvidersConstraint
          .user_providers_user_id_provider_id_key;
    default:
      return EnumauthUserProvidersConstraint.$unknown;
  }
}

enum EnumauthUserProvidersSelectColumn {
  accessToken,
  createdAt,
  id,
  providerId,
  providerUserId,
  refreshToken,
  updatedAt,
  userId,
  $unknown
}

String toJson$EnumauthUserProvidersSelectColumn(
    EnumauthUserProvidersSelectColumn e) {
  switch (e) {
    case EnumauthUserProvidersSelectColumn.accessToken:
      return r'accessToken';
    case EnumauthUserProvidersSelectColumn.createdAt:
      return r'createdAt';
    case EnumauthUserProvidersSelectColumn.id:
      return r'id';
    case EnumauthUserProvidersSelectColumn.providerId:
      return r'providerId';
    case EnumauthUserProvidersSelectColumn.providerUserId:
      return r'providerUserId';
    case EnumauthUserProvidersSelectColumn.refreshToken:
      return r'refreshToken';
    case EnumauthUserProvidersSelectColumn.updatedAt:
      return r'updatedAt';
    case EnumauthUserProvidersSelectColumn.userId:
      return r'userId';
    case EnumauthUserProvidersSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserProvidersSelectColumn fromJson$EnumauthUserProvidersSelectColumn(
    String value) {
  switch (value) {
    case r'accessToken':
      return EnumauthUserProvidersSelectColumn.accessToken;
    case r'createdAt':
      return EnumauthUserProvidersSelectColumn.createdAt;
    case r'id':
      return EnumauthUserProvidersSelectColumn.id;
    case r'providerId':
      return EnumauthUserProvidersSelectColumn.providerId;
    case r'providerUserId':
      return EnumauthUserProvidersSelectColumn.providerUserId;
    case r'refreshToken':
      return EnumauthUserProvidersSelectColumn.refreshToken;
    case r'updatedAt':
      return EnumauthUserProvidersSelectColumn.updatedAt;
    case r'userId':
      return EnumauthUserProvidersSelectColumn.userId;
    default:
      return EnumauthUserProvidersSelectColumn.$unknown;
  }
}

enum EnumauthUserProvidersUpdateColumn {
  accessToken,
  createdAt,
  id,
  providerId,
  providerUserId,
  refreshToken,
  updatedAt,
  userId,
  $unknown
}

String toJson$EnumauthUserProvidersUpdateColumn(
    EnumauthUserProvidersUpdateColumn e) {
  switch (e) {
    case EnumauthUserProvidersUpdateColumn.accessToken:
      return r'accessToken';
    case EnumauthUserProvidersUpdateColumn.createdAt:
      return r'createdAt';
    case EnumauthUserProvidersUpdateColumn.id:
      return r'id';
    case EnumauthUserProvidersUpdateColumn.providerId:
      return r'providerId';
    case EnumauthUserProvidersUpdateColumn.providerUserId:
      return r'providerUserId';
    case EnumauthUserProvidersUpdateColumn.refreshToken:
      return r'refreshToken';
    case EnumauthUserProvidersUpdateColumn.updatedAt:
      return r'updatedAt';
    case EnumauthUserProvidersUpdateColumn.userId:
      return r'userId';
    case EnumauthUserProvidersUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserProvidersUpdateColumn fromJson$EnumauthUserProvidersUpdateColumn(
    String value) {
  switch (value) {
    case r'accessToken':
      return EnumauthUserProvidersUpdateColumn.accessToken;
    case r'createdAt':
      return EnumauthUserProvidersUpdateColumn.createdAt;
    case r'id':
      return EnumauthUserProvidersUpdateColumn.id;
    case r'providerId':
      return EnumauthUserProvidersUpdateColumn.providerId;
    case r'providerUserId':
      return EnumauthUserProvidersUpdateColumn.providerUserId;
    case r'refreshToken':
      return EnumauthUserProvidersUpdateColumn.refreshToken;
    case r'updatedAt':
      return EnumauthUserProvidersUpdateColumn.updatedAt;
    case r'userId':
      return EnumauthUserProvidersUpdateColumn.userId;
    default:
      return EnumauthUserProvidersUpdateColumn.$unknown;
  }
}

enum EnumauthUserRolesConstraint {
  user_roles_pkey,
  user_roles_user_id_role_key,
  $unknown
}

String toJson$EnumauthUserRolesConstraint(EnumauthUserRolesConstraint e) {
  switch (e) {
    case EnumauthUserRolesConstraint.user_roles_pkey:
      return r'user_roles_pkey';
    case EnumauthUserRolesConstraint.user_roles_user_id_role_key:
      return r'user_roles_user_id_role_key';
    case EnumauthUserRolesConstraint.$unknown:
      return r'$unknown';
  }
}

EnumauthUserRolesConstraint fromJson$EnumauthUserRolesConstraint(String value) {
  switch (value) {
    case r'user_roles_pkey':
      return EnumauthUserRolesConstraint.user_roles_pkey;
    case r'user_roles_user_id_role_key':
      return EnumauthUserRolesConstraint.user_roles_user_id_role_key;
    default:
      return EnumauthUserRolesConstraint.$unknown;
  }
}

enum EnumauthUserRolesSelectColumn { createdAt, id, role, userId, $unknown }

String toJson$EnumauthUserRolesSelectColumn(EnumauthUserRolesSelectColumn e) {
  switch (e) {
    case EnumauthUserRolesSelectColumn.createdAt:
      return r'createdAt';
    case EnumauthUserRolesSelectColumn.id:
      return r'id';
    case EnumauthUserRolesSelectColumn.role:
      return r'role';
    case EnumauthUserRolesSelectColumn.userId:
      return r'userId';
    case EnumauthUserRolesSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserRolesSelectColumn fromJson$EnumauthUserRolesSelectColumn(
    String value) {
  switch (value) {
    case r'createdAt':
      return EnumauthUserRolesSelectColumn.createdAt;
    case r'id':
      return EnumauthUserRolesSelectColumn.id;
    case r'role':
      return EnumauthUserRolesSelectColumn.role;
    case r'userId':
      return EnumauthUserRolesSelectColumn.userId;
    default:
      return EnumauthUserRolesSelectColumn.$unknown;
  }
}

enum EnumauthUserRolesUpdateColumn { createdAt, id, role, userId, $unknown }

String toJson$EnumauthUserRolesUpdateColumn(EnumauthUserRolesUpdateColumn e) {
  switch (e) {
    case EnumauthUserRolesUpdateColumn.createdAt:
      return r'createdAt';
    case EnumauthUserRolesUpdateColumn.id:
      return r'id';
    case EnumauthUserRolesUpdateColumn.role:
      return r'role';
    case EnumauthUserRolesUpdateColumn.userId:
      return r'userId';
    case EnumauthUserRolesUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumauthUserRolesUpdateColumn fromJson$EnumauthUserRolesUpdateColumn(
    String value) {
  switch (value) {
    case r'createdAt':
      return EnumauthUserRolesUpdateColumn.createdAt;
    case r'id':
      return EnumauthUserRolesUpdateColumn.id;
    case r'role':
      return EnumauthUserRolesUpdateColumn.role;
    case r'userId':
      return EnumauthUserRolesUpdateColumn.userId;
    default:
      return EnumauthUserRolesUpdateColumn.$unknown;
  }
}

enum EnumbucketsConstraint { buckets_pkey, $unknown }

String toJson$EnumbucketsConstraint(EnumbucketsConstraint e) {
  switch (e) {
    case EnumbucketsConstraint.buckets_pkey:
      return r'buckets_pkey';
    case EnumbucketsConstraint.$unknown:
      return r'$unknown';
  }
}

EnumbucketsConstraint fromJson$EnumbucketsConstraint(String value) {
  switch (value) {
    case r'buckets_pkey':
      return EnumbucketsConstraint.buckets_pkey;
    default:
      return EnumbucketsConstraint.$unknown;
  }
}

enum EnumbucketsSelectColumn {
  cacheControl,
  createdAt,
  downloadExpiration,
  id,
  maxUploadFileSize,
  minUploadFileSize,
  presignedUrlsEnabled,
  updatedAt,
  $unknown
}

String toJson$EnumbucketsSelectColumn(EnumbucketsSelectColumn e) {
  switch (e) {
    case EnumbucketsSelectColumn.cacheControl:
      return r'cacheControl';
    case EnumbucketsSelectColumn.createdAt:
      return r'createdAt';
    case EnumbucketsSelectColumn.downloadExpiration:
      return r'downloadExpiration';
    case EnumbucketsSelectColumn.id:
      return r'id';
    case EnumbucketsSelectColumn.maxUploadFileSize:
      return r'maxUploadFileSize';
    case EnumbucketsSelectColumn.minUploadFileSize:
      return r'minUploadFileSize';
    case EnumbucketsSelectColumn.presignedUrlsEnabled:
      return r'presignedUrlsEnabled';
    case EnumbucketsSelectColumn.updatedAt:
      return r'updatedAt';
    case EnumbucketsSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumbucketsSelectColumn fromJson$EnumbucketsSelectColumn(String value) {
  switch (value) {
    case r'cacheControl':
      return EnumbucketsSelectColumn.cacheControl;
    case r'createdAt':
      return EnumbucketsSelectColumn.createdAt;
    case r'downloadExpiration':
      return EnumbucketsSelectColumn.downloadExpiration;
    case r'id':
      return EnumbucketsSelectColumn.id;
    case r'maxUploadFileSize':
      return EnumbucketsSelectColumn.maxUploadFileSize;
    case r'minUploadFileSize':
      return EnumbucketsSelectColumn.minUploadFileSize;
    case r'presignedUrlsEnabled':
      return EnumbucketsSelectColumn.presignedUrlsEnabled;
    case r'updatedAt':
      return EnumbucketsSelectColumn.updatedAt;
    default:
      return EnumbucketsSelectColumn.$unknown;
  }
}

enum EnumbucketsUpdateColumn {
  cacheControl,
  createdAt,
  downloadExpiration,
  id,
  maxUploadFileSize,
  minUploadFileSize,
  presignedUrlsEnabled,
  updatedAt,
  $unknown
}

String toJson$EnumbucketsUpdateColumn(EnumbucketsUpdateColumn e) {
  switch (e) {
    case EnumbucketsUpdateColumn.cacheControl:
      return r'cacheControl';
    case EnumbucketsUpdateColumn.createdAt:
      return r'createdAt';
    case EnumbucketsUpdateColumn.downloadExpiration:
      return r'downloadExpiration';
    case EnumbucketsUpdateColumn.id:
      return r'id';
    case EnumbucketsUpdateColumn.maxUploadFileSize:
      return r'maxUploadFileSize';
    case EnumbucketsUpdateColumn.minUploadFileSize:
      return r'minUploadFileSize';
    case EnumbucketsUpdateColumn.presignedUrlsEnabled:
      return r'presignedUrlsEnabled';
    case EnumbucketsUpdateColumn.updatedAt:
      return r'updatedAt';
    case EnumbucketsUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumbucketsUpdateColumn fromJson$EnumbucketsUpdateColumn(String value) {
  switch (value) {
    case r'cacheControl':
      return EnumbucketsUpdateColumn.cacheControl;
    case r'createdAt':
      return EnumbucketsUpdateColumn.createdAt;
    case r'downloadExpiration':
      return EnumbucketsUpdateColumn.downloadExpiration;
    case r'id':
      return EnumbucketsUpdateColumn.id;
    case r'maxUploadFileSize':
      return EnumbucketsUpdateColumn.maxUploadFileSize;
    case r'minUploadFileSize':
      return EnumbucketsUpdateColumn.minUploadFileSize;
    case r'presignedUrlsEnabled':
      return EnumbucketsUpdateColumn.presignedUrlsEnabled;
    case r'updatedAt':
      return EnumbucketsUpdateColumn.updatedAt;
    default:
      return EnumbucketsUpdateColumn.$unknown;
  }
}

enum EnumfilesConstraint { files_pkey, $unknown }

String toJson$EnumfilesConstraint(EnumfilesConstraint e) {
  switch (e) {
    case EnumfilesConstraint.files_pkey:
      return r'files_pkey';
    case EnumfilesConstraint.$unknown:
      return r'$unknown';
  }
}

EnumfilesConstraint fromJson$EnumfilesConstraint(String value) {
  switch (value) {
    case r'files_pkey':
      return EnumfilesConstraint.files_pkey;
    default:
      return EnumfilesConstraint.$unknown;
  }
}

enum EnumfilesSelectColumn {
  bucketId,
  createdAt,
  etag,
  id,
  isUploaded,
  mimeType,
  name,
  size,
  updatedAt,
  uploadedByUserId,
  $unknown
}

String toJson$EnumfilesSelectColumn(EnumfilesSelectColumn e) {
  switch (e) {
    case EnumfilesSelectColumn.bucketId:
      return r'bucketId';
    case EnumfilesSelectColumn.createdAt:
      return r'createdAt';
    case EnumfilesSelectColumn.etag:
      return r'etag';
    case EnumfilesSelectColumn.id:
      return r'id';
    case EnumfilesSelectColumn.isUploaded:
      return r'isUploaded';
    case EnumfilesSelectColumn.mimeType:
      return r'mimeType';
    case EnumfilesSelectColumn.name:
      return r'name';
    case EnumfilesSelectColumn.size:
      return r'size';
    case EnumfilesSelectColumn.updatedAt:
      return r'updatedAt';
    case EnumfilesSelectColumn.uploadedByUserId:
      return r'uploadedByUserId';
    case EnumfilesSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumfilesSelectColumn fromJson$EnumfilesSelectColumn(String value) {
  switch (value) {
    case r'bucketId':
      return EnumfilesSelectColumn.bucketId;
    case r'createdAt':
      return EnumfilesSelectColumn.createdAt;
    case r'etag':
      return EnumfilesSelectColumn.etag;
    case r'id':
      return EnumfilesSelectColumn.id;
    case r'isUploaded':
      return EnumfilesSelectColumn.isUploaded;
    case r'mimeType':
      return EnumfilesSelectColumn.mimeType;
    case r'name':
      return EnumfilesSelectColumn.name;
    case r'size':
      return EnumfilesSelectColumn.size;
    case r'updatedAt':
      return EnumfilesSelectColumn.updatedAt;
    case r'uploadedByUserId':
      return EnumfilesSelectColumn.uploadedByUserId;
    default:
      return EnumfilesSelectColumn.$unknown;
  }
}

enum EnumfilesUpdateColumn {
  bucketId,
  createdAt,
  etag,
  id,
  isUploaded,
  mimeType,
  name,
  size,
  updatedAt,
  uploadedByUserId,
  $unknown
}

String toJson$EnumfilesUpdateColumn(EnumfilesUpdateColumn e) {
  switch (e) {
    case EnumfilesUpdateColumn.bucketId:
      return r'bucketId';
    case EnumfilesUpdateColumn.createdAt:
      return r'createdAt';
    case EnumfilesUpdateColumn.etag:
      return r'etag';
    case EnumfilesUpdateColumn.id:
      return r'id';
    case EnumfilesUpdateColumn.isUploaded:
      return r'isUploaded';
    case EnumfilesUpdateColumn.mimeType:
      return r'mimeType';
    case EnumfilesUpdateColumn.name:
      return r'name';
    case EnumfilesUpdateColumn.size:
      return r'size';
    case EnumfilesUpdateColumn.updatedAt:
      return r'updatedAt';
    case EnumfilesUpdateColumn.uploadedByUserId:
      return r'uploadedByUserId';
    case EnumfilesUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumfilesUpdateColumn fromJson$EnumfilesUpdateColumn(String value) {
  switch (value) {
    case r'bucketId':
      return EnumfilesUpdateColumn.bucketId;
    case r'createdAt':
      return EnumfilesUpdateColumn.createdAt;
    case r'etag':
      return EnumfilesUpdateColumn.etag;
    case r'id':
      return EnumfilesUpdateColumn.id;
    case r'isUploaded':
      return EnumfilesUpdateColumn.isUploaded;
    case r'mimeType':
      return EnumfilesUpdateColumn.mimeType;
    case r'name':
      return EnumfilesUpdateColumn.name;
    case r'size':
      return EnumfilesUpdateColumn.size;
    case r'updatedAt':
      return EnumfilesUpdateColumn.updatedAt;
    case r'uploadedByUserId':
      return EnumfilesUpdateColumn.uploadedByUserId;
    default:
      return EnumfilesUpdateColumn.$unknown;
  }
}

enum EnumusersConstraint {
  users_email_key,
  users_phone_number_key,
  users_pkey,
  $unknown
}

String toJson$EnumusersConstraint(EnumusersConstraint e) {
  switch (e) {
    case EnumusersConstraint.users_email_key:
      return r'users_email_key';
    case EnumusersConstraint.users_phone_number_key:
      return r'users_phone_number_key';
    case EnumusersConstraint.users_pkey:
      return r'users_pkey';
    case EnumusersConstraint.$unknown:
      return r'$unknown';
  }
}

EnumusersConstraint fromJson$EnumusersConstraint(String value) {
  switch (value) {
    case r'users_email_key':
      return EnumusersConstraint.users_email_key;
    case r'users_phone_number_key':
      return EnumusersConstraint.users_phone_number_key;
    case r'users_pkey':
      return EnumusersConstraint.users_pkey;
    default:
      return EnumusersConstraint.$unknown;
  }
}

enum EnumusersSelectColumn {
  activeMfaType,
  avatarUrl,
  createdAt,
  currentChallenge,
  defaultRole,
  disabled,
  displayName,
  email,
  emailVerified,
  id,
  isAnonymous,
  lastSeen,
  locale,
  metadata,
  newEmail,
  otpHash,
  otpHashExpiresAt,
  otpMethodLastUsed,
  passwordHash,
  phoneNumber,
  phoneNumberVerified,
  ticket,
  ticketExpiresAt,
  totpSecret,
  updatedAt,
  $unknown
}

String toJson$EnumusersSelectColumn(EnumusersSelectColumn e) {
  switch (e) {
    case EnumusersSelectColumn.activeMfaType:
      return r'activeMfaType';
    case EnumusersSelectColumn.avatarUrl:
      return r'avatarUrl';
    case EnumusersSelectColumn.createdAt:
      return r'createdAt';
    case EnumusersSelectColumn.currentChallenge:
      return r'currentChallenge';
    case EnumusersSelectColumn.defaultRole:
      return r'defaultRole';
    case EnumusersSelectColumn.disabled:
      return r'disabled';
    case EnumusersSelectColumn.displayName:
      return r'displayName';
    case EnumusersSelectColumn.email:
      return r'email';
    case EnumusersSelectColumn.emailVerified:
      return r'emailVerified';
    case EnumusersSelectColumn.id:
      return r'id';
    case EnumusersSelectColumn.isAnonymous:
      return r'isAnonymous';
    case EnumusersSelectColumn.lastSeen:
      return r'lastSeen';
    case EnumusersSelectColumn.locale:
      return r'locale';
    case EnumusersSelectColumn.metadata:
      return r'metadata';
    case EnumusersSelectColumn.newEmail:
      return r'newEmail';
    case EnumusersSelectColumn.otpHash:
      return r'otpHash';
    case EnumusersSelectColumn.otpHashExpiresAt:
      return r'otpHashExpiresAt';
    case EnumusersSelectColumn.otpMethodLastUsed:
      return r'otpMethodLastUsed';
    case EnumusersSelectColumn.passwordHash:
      return r'passwordHash';
    case EnumusersSelectColumn.phoneNumber:
      return r'phoneNumber';
    case EnumusersSelectColumn.phoneNumberVerified:
      return r'phoneNumberVerified';
    case EnumusersSelectColumn.ticket:
      return r'ticket';
    case EnumusersSelectColumn.ticketExpiresAt:
      return r'ticketExpiresAt';
    case EnumusersSelectColumn.totpSecret:
      return r'totpSecret';
    case EnumusersSelectColumn.updatedAt:
      return r'updatedAt';
    case EnumusersSelectColumn.$unknown:
      return r'$unknown';
  }
}

EnumusersSelectColumn fromJson$EnumusersSelectColumn(String value) {
  switch (value) {
    case r'activeMfaType':
      return EnumusersSelectColumn.activeMfaType;
    case r'avatarUrl':
      return EnumusersSelectColumn.avatarUrl;
    case r'createdAt':
      return EnumusersSelectColumn.createdAt;
    case r'currentChallenge':
      return EnumusersSelectColumn.currentChallenge;
    case r'defaultRole':
      return EnumusersSelectColumn.defaultRole;
    case r'disabled':
      return EnumusersSelectColumn.disabled;
    case r'displayName':
      return EnumusersSelectColumn.displayName;
    case r'email':
      return EnumusersSelectColumn.email;
    case r'emailVerified':
      return EnumusersSelectColumn.emailVerified;
    case r'id':
      return EnumusersSelectColumn.id;
    case r'isAnonymous':
      return EnumusersSelectColumn.isAnonymous;
    case r'lastSeen':
      return EnumusersSelectColumn.lastSeen;
    case r'locale':
      return EnumusersSelectColumn.locale;
    case r'metadata':
      return EnumusersSelectColumn.metadata;
    case r'newEmail':
      return EnumusersSelectColumn.newEmail;
    case r'otpHash':
      return EnumusersSelectColumn.otpHash;
    case r'otpHashExpiresAt':
      return EnumusersSelectColumn.otpHashExpiresAt;
    case r'otpMethodLastUsed':
      return EnumusersSelectColumn.otpMethodLastUsed;
    case r'passwordHash':
      return EnumusersSelectColumn.passwordHash;
    case r'phoneNumber':
      return EnumusersSelectColumn.phoneNumber;
    case r'phoneNumberVerified':
      return EnumusersSelectColumn.phoneNumberVerified;
    case r'ticket':
      return EnumusersSelectColumn.ticket;
    case r'ticketExpiresAt':
      return EnumusersSelectColumn.ticketExpiresAt;
    case r'totpSecret':
      return EnumusersSelectColumn.totpSecret;
    case r'updatedAt':
      return EnumusersSelectColumn.updatedAt;
    default:
      return EnumusersSelectColumn.$unknown;
  }
}

enum EnumusersUpdateColumn {
  activeMfaType,
  avatarUrl,
  createdAt,
  currentChallenge,
  defaultRole,
  disabled,
  displayName,
  email,
  emailVerified,
  id,
  isAnonymous,
  lastSeen,
  locale,
  metadata,
  newEmail,
  otpHash,
  otpHashExpiresAt,
  otpMethodLastUsed,
  passwordHash,
  phoneNumber,
  phoneNumberVerified,
  ticket,
  ticketExpiresAt,
  totpSecret,
  updatedAt,
  $unknown
}

String toJson$EnumusersUpdateColumn(EnumusersUpdateColumn e) {
  switch (e) {
    case EnumusersUpdateColumn.activeMfaType:
      return r'activeMfaType';
    case EnumusersUpdateColumn.avatarUrl:
      return r'avatarUrl';
    case EnumusersUpdateColumn.createdAt:
      return r'createdAt';
    case EnumusersUpdateColumn.currentChallenge:
      return r'currentChallenge';
    case EnumusersUpdateColumn.defaultRole:
      return r'defaultRole';
    case EnumusersUpdateColumn.disabled:
      return r'disabled';
    case EnumusersUpdateColumn.displayName:
      return r'displayName';
    case EnumusersUpdateColumn.email:
      return r'email';
    case EnumusersUpdateColumn.emailVerified:
      return r'emailVerified';
    case EnumusersUpdateColumn.id:
      return r'id';
    case EnumusersUpdateColumn.isAnonymous:
      return r'isAnonymous';
    case EnumusersUpdateColumn.lastSeen:
      return r'lastSeen';
    case EnumusersUpdateColumn.locale:
      return r'locale';
    case EnumusersUpdateColumn.metadata:
      return r'metadata';
    case EnumusersUpdateColumn.newEmail:
      return r'newEmail';
    case EnumusersUpdateColumn.otpHash:
      return r'otpHash';
    case EnumusersUpdateColumn.otpHashExpiresAt:
      return r'otpHashExpiresAt';
    case EnumusersUpdateColumn.otpMethodLastUsed:
      return r'otpMethodLastUsed';
    case EnumusersUpdateColumn.passwordHash:
      return r'passwordHash';
    case EnumusersUpdateColumn.phoneNumber:
      return r'phoneNumber';
    case EnumusersUpdateColumn.phoneNumberVerified:
      return r'phoneNumberVerified';
    case EnumusersUpdateColumn.ticket:
      return r'ticket';
    case EnumusersUpdateColumn.ticketExpiresAt:
      return r'ticketExpiresAt';
    case EnumusersUpdateColumn.totpSecret:
      return r'totpSecret';
    case EnumusersUpdateColumn.updatedAt:
      return r'updatedAt';
    case EnumusersUpdateColumn.$unknown:
      return r'$unknown';
  }
}

EnumusersUpdateColumn fromJson$EnumusersUpdateColumn(String value) {
  switch (value) {
    case r'activeMfaType':
      return EnumusersUpdateColumn.activeMfaType;
    case r'avatarUrl':
      return EnumusersUpdateColumn.avatarUrl;
    case r'createdAt':
      return EnumusersUpdateColumn.createdAt;
    case r'currentChallenge':
      return EnumusersUpdateColumn.currentChallenge;
    case r'defaultRole':
      return EnumusersUpdateColumn.defaultRole;
    case r'disabled':
      return EnumusersUpdateColumn.disabled;
    case r'displayName':
      return EnumusersUpdateColumn.displayName;
    case r'email':
      return EnumusersUpdateColumn.email;
    case r'emailVerified':
      return EnumusersUpdateColumn.emailVerified;
    case r'id':
      return EnumusersUpdateColumn.id;
    case r'isAnonymous':
      return EnumusersUpdateColumn.isAnonymous;
    case r'lastSeen':
      return EnumusersUpdateColumn.lastSeen;
    case r'locale':
      return EnumusersUpdateColumn.locale;
    case r'metadata':
      return EnumusersUpdateColumn.metadata;
    case r'newEmail':
      return EnumusersUpdateColumn.newEmail;
    case r'otpHash':
      return EnumusersUpdateColumn.otpHash;
    case r'otpHashExpiresAt':
      return EnumusersUpdateColumn.otpHashExpiresAt;
    case r'otpMethodLastUsed':
      return EnumusersUpdateColumn.otpMethodLastUsed;
    case r'passwordHash':
      return EnumusersUpdateColumn.passwordHash;
    case r'phoneNumber':
      return EnumusersUpdateColumn.phoneNumber;
    case r'phoneNumberVerified':
      return EnumusersUpdateColumn.phoneNumberVerified;
    case r'ticket':
      return EnumusersUpdateColumn.ticket;
    case r'ticketExpiresAt':
      return EnumusersUpdateColumn.ticketExpiresAt;
    case r'totpSecret':
      return EnumusersUpdateColumn.totpSecret;
    case r'updatedAt':
      return EnumusersUpdateColumn.updatedAt;
    default:
      return EnumusersUpdateColumn.$unknown;
  }
}

const possibleTypesMap = {};
